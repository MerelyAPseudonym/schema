<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1449884005773">{:repl-history {:ide [], :local [&quot;(require 'clojure.test)&quot; &quot;(dir clojure.test)&quot; &quot;(run-all-tests)&quot; &quot;(clojure.test/run-all-tests)&quot; &quot;(require 'midje.repl)&quot; &quot;(require '[clojure.tools.trace :as tools.trace])&quot; &quot;(use 'midje.repl)&quot; &quot;(load-facts)&quot; &quot;(require 'schema.coerce-test)&quot; &quot;(require 'schema.coerce-test :reload)&quot; &quot;(dir schema.coerce-test)&quot; &quot;(clojure.test/run-tests schema.coerce-test)&quot; &quot;(clojure.test/run-tests 'schema.coerce-test)&quot; &quot;(check-facts 'schema.coerce-test)&quot; &quot;(dir midje.repl)&quot; &quot;(require 'clojure.tools.namespace.repl)&quot; &quot;(require 'schema.core)&quot; &quot;(schema.core/check (schema.core/eq \&quot;Schemas are cool!\&quot;) \&quot;Schemas are cool!\&quot;)&quot; &quot;(schema.core/check (schema.core/eq \&quot;Schemas are cool!\&quot;) \&quot;Schemas are NOT cool!\&quot;)&quot; &quot;(schema.core/check (schema.core/eq \&quot;Schemas are cool!\&quot;) \&quot;Schemas aren't cool!\&quot;)&quot; &quot;(schema.core/check (schema.core/eq \&quot;Schemas are cool!\&quot;) \&quot;Not cool.\&quot;)&quot; &quot;(require 'clojure.tools.namespace.repl '[clojure.tools.trace :as tools.trace])&quot; &quot;(require 'schema.spec.core)&quot; &quot;(defn walk-demo [schema]\n  (schema.spec.core/run-checker (fn [s params]\n                                  (let [walk (schema.spec.core/checker (schema.core/spec s)\n                                                                       params)]\n                                    (fn [x]\n                                      (let [result (walk x)]\n                                        (printf \&quot;%s | checking %s against %s%n\&quot;\n                                                (if (schema.utils/error? result) \&quot;FAIL\&quot; \&quot;PASS\&quot;)\n                                                x\n                                                (schema.core/explain s))\n                                        result))))\n                                true\n                                schema))&quot; &quot;(merge {:a 1})&quot; &quot;(schema.core/defschema Old\n  {:id schema.core/Str\n   :body schema.core/Str\n   :objectType schema.core/Str\n   :link schema.core/Str})&quot; &quot;(schema.core/defschema New\n  {(schema.core/optional-key \&quot;@id\&quot;) schema.core/Str\n   (schema.core/optional-key \&quot;object\&quot;) {(schema.core/optional-key \&quot;@id\&quot;) schema.core/Str\n                                        (schema.core/required-key \&quot;@type\&quot;) schema.core/Str\n                                        (schema.core/optional-key \&quot;content\&quot;) schema.core/Str}\n   (schema.core/optional-key \&quot;url\&quot;) {(schema.core/optional-key \&quot;@type\&quot;) schema.core/Str\n                                     (schema.core/required-key \&quot;href\&quot;) schema.core/Str\n                                     (schema.core/optional-key \&quot;rel\&quot;) schema.core/Str}})&quot; &quot;(schema.core/defschema New\n  {(schema.core/optional-key \&quot;@id\&quot;) schema.core/Str\n   (schema.core/optional-key \&quot;object\&quot;) {(schema.core/optional-key \&quot;@id\&quot;) schema.core/Str\n                                        (schema.core/required-key \&quot;@type\&quot;) schema.core/Str\n                                        (schema.core/optional-key \&quot;content\&quot;) schema.core/Str}\n   (schema.core/optional-key \&quot;url\&quot;) {(schema.core/optional-key \&quot;@type\&quot;) (schema.core/eq \&quot;Link\&quot;)\n                                     (schema.core/required-key \&quot;href\&quot;) schema.core/Str\n                                     (schema.core/optional-key \&quot;rel\&quot;) schema.core/Str}})&quot; &quot;(alias 's 'schema.core)&quot; &quot;(def CommentRequest\n  {(s/optional-key :parent-comment-id) long\n   :text String\n   :share-services [(s/enum :twitter :facebook :google)]})&quot; &quot;(require 'schema.coerce :reload-all)&quot; &quot;parse-comment-request&quot; &quot;(= (parse-comment-request\n    {:parent-comment-id (int 2128123123)\n     :text \&quot;This is awesome!\&quot;\n     :share-services [\&quot;twitter\&quot; \&quot;facebook\&quot;]})\n   {:parent-comment-id 2128123123\n    :text \&quot;This is awesome!\&quot;\n    :share-services [:twitter :facebook]})&quot; &quot;(clojure.tools.namespace.repl/refresh)&quot; &quot;(clojure.tools.namespace.repl/refresh-all)&quot; &quot;(def parse-comment-request (schema.coerce/coercer CommentRequest schema.coerce/json-coercion-matcher))&quot; &quot;(walk-demo Old)&quot; &quot;((walk-demo Old) {:id \&quot;id\&quot;, :body \&quot;body\&quot;, :objectType \&quot;objectType\&quot;, :link \&quot;link\&quot;})&quot; &quot;(require 'schema.experimental.complete)&quot; &quot;(schema.experimental.complete/sample New)&quot; &quot;(schema.experimental.complete/sample Old)&quot; &quot;(schema.experimental.complete/sample schema.core/Num)&quot; &quot;(require 'schema.experimental.generators)&quot; &quot;(schema.experimental.generators/generate Old)&quot; &quot;(schema.experimental.generators/generate New)&quot; &quot;(s/spec Old)&quot; &quot;(s/explain Old)&quot; &quot;(s/explain New)&quot; &quot;(s/spec New)&quot; &quot;New&quot; &quot;(type New)&quot; &quot;(defn transform-top-level-old-id [[k v]]\n  (assert (= k :id))\n  (s/map-entry (s/optional-key \&quot;@id\&quot;)\n               v))&quot; &quot;((schema.coerce/coercer Old {(s/map-entry :id s/Str) transform-top-level-old-id})\n {:id \&quot;foo\&quot;})&quot; &quot;((walk-demo New {(s/map-entry :id s/Str) transform-top-level-old-id})\n {:id \&quot;foo\&quot;})&quot; &quot;((schema.coerce/coercer New {(s/map-entry :id s/Str) transform-top-level-old-id})\n {:id \&quot;foo\&quot;})&quot; &quot;((schema.coerce/coercer New {(s/eq \&quot;@id\&quot;) transform-top-level-old-id})\n {:id \&quot;foo\&quot;})&quot; &quot;((schema.coerce/coercer New {:id transform-top-level-old-id})\n {:id \&quot;foo\&quot;})&quot; &quot;((schema.coerce/coercer Any {:id transform-top-level-old-id})\n {:id \&quot;foo\&quot;})&quot; &quot;((schema.coerce/coercer s/Any {:id transform-top-level-old-id})\n {:id \&quot;foo\&quot;})&quot; &quot;(defn id-matcher [schema]\n  (when (= schema (s/map-entry (s/optional-key \&quot;@id\&quot;)\n                               s/Str))\n    (println \&quot;matched!\&quot;)\n    (schema.coerce/safe\n     (fn [[k v]]\n       (when (= :id k)\n         [\&quot;@id\&quot; v])))))&quot; &quot;((schema.coerce/coercer New id-matcher)\n {:id \&quot;foo\&quot;})&quot; &quot;((schema.coerce/coercer {(s/required-key \&quot;@id\&quot;) s/Str} id-matcher)\n {:id \&quot;foo\&quot;})&quot; &quot;(tools.trace/trace-ns 'schema.coerce)&quot; &quot;(tools.trace/trace-ns 'schema.spec.core)&quot; &quot;(require 'schema.coerce)&quot; &quot;(require 'schema.coerce :reload)&quot; &quot;(require '(schema core coerce))&quot; &quot;(require '[schema.core :as s])&quot; &quot;((schema.coerce/coercer {(s/required-key \&quot;@id\&quot;) s/Str}\n                        (fn [schema]\n                          (when (= (s/required-key \&quot;@id\&quot;) schema)\n                            (schema.coerce/safe\n                             (fn [x]\n                               (println \&quot;x:\&quot; x)\n                               (when (= x :id)\n                                 \&quot;@id\&quot;))))))\n {:id \&quot;foo\&quot;})&quot; &quot;((schema.coerce/coercer {(s/required-key \&quot;@id\&quot;) s/Str}\n                        (fn [schema]\n                          (println \&quot;schema:\&quot; schema)\n                          (when (= (s/required-key \&quot;@id\&quot;) schema)\n                            (schema.coerce/safe\n                             (fn [my-x]\n                               (println \&quot;my-x:\&quot; my-x)\n                               (when (= my-x :id)\n                                 \&quot;@id\&quot;))))))\n {:id \&quot;foo\&quot;})&quot; &quot;((schema.coerce/coercer {(s/required-key \&quot;@id\&quot;) s/Str}\n                        (fn [schema]\n                          (println \&quot;schema:\&quot; schema)\n                          (when (= (s/eq \&quot;@id\&quot;) schema)\n                            (schema.coerce/safe\n                             (fn [my-x]\n                               (println \&quot;my-x:\&quot; my-x)\n                               (when (= my-x :id)\n                                 \&quot;@id\&quot;))))))\n {:id \&quot;foo\&quot;})&quot; &quot;((schema.coerce/coercer {(s/required-key \&quot;@id\&quot;) s/Str}\n                        (fn [schema]\n                          (println \&quot;schema:\&quot; schema)\n                          (when (= (s/required-key \&quot;@id\&quot;) schema)\n                            (println \&quot;matched!\&quot;)\n                            (schema.coerce/safe\n                             (fn [my-x]\n                               (println \&quot;my-x:\&quot; my-x)\n                               (when (= my-x :id)\n                                 \&quot;@id\&quot;))))))\n {:id \&quot;foo\&quot;})&quot; &quot;((schema.coerce/coercer {(s/required-key \&quot;@id\&quot;) s/Str}\n                        (fn [schema]\n                          (println \&quot;schema:\&quot; schema)\n                          (when (= (s/eq \&quot;@id\&quot;) schema)\n                            (println \&quot;matched!\&quot;)\n                            (schema.coerce/safe\n                             (fn [my-x]\n                               (println \&quot;my-x:\&quot; my-x)\n                               (when (= my-x :id)\n                                 \&quot;@id\&quot;))))))\n {:id \&quot;foo\&quot;})&quot; &quot;((schema.coerce/coercer {(s/required-key \&quot;@id\&quot;) s/Str}\n                        (fn [schema]\n                          (println \&quot;schema:\&quot; schema)\n                          (when (= (s/eq \&quot;@id\&quot;) schema)\n                            (println \&quot;matched!\&quot;)\n                            (fn [my-x]\n                               (println \&quot;my-x:\&quot; my-x)\n                               (when (= my-x :id)\n                                 \&quot;@id\&quot;)))))\n {:id \&quot;foo\&quot;})&quot; &quot;((schema.coerce/coercer {(s/required-key \&quot;@id\&quot;) s/Str}\n                        (fn [schema]\n                          (println \&quot;schema:\&quot; schema)\n                          (when (= (s/eq \&quot;@id\&quot;) schema)\n                            (println \&quot;matched!\&quot;)\n                            (fn [my-x]\n                              (println \&quot;my-x:\&quot; my-x)\n                              (when (= my-x :id)\n                                \&quot;@id\&quot;)))))\n {:id \&quot;foo\&quot;})&quot; &quot;((schema.coerce/coercer {(s/required-key \&quot;@id\&quot;) s/Str}\n                        (schema.coerce/first-matcher [(fn [schema]\n                          (println \&quot;schema:\&quot; schema)\n                          (when (= (s/eq \&quot;@id\&quot;) schema)\n                            (println \&quot;matched!\&quot;)\n                            (fn [my-x]\n                              (println \&quot;my-x:\&quot; my-x)\n                              (when (= my-x :id)\n                                \&quot;@id\&quot;))))]))\n {:id \&quot;foo\&quot;})&quot; &quot;((schema.coerce/coercer {(s/required-key \&quot;@id\&quot;) s/Str}\n                        (fn [schema]\n                          (println \&quot;schema:\&quot; schema)\n                          (when (= (s/map-entry (s/eq \&quot;@id\&quot;) s/Str) schema)\n                            (println \&quot;matched!\&quot;)\n                            (schema.coerce/safe\n                             (fn [my-x]\n                               (println \&quot;my-x:\&quot; my-x)\n                               (when (= my-x :id)\n                                 \&quot;@id\&quot;))))))\n {:id \&quot;foo\&quot;})&quot; &quot;(defn coerce-and-validate [schema matcher data]\n  (let [coercer (schema.coerce/coercer schema matcher)\n        result (coercer data)]\n    (if (schema.utils/error? result)\n      (throw (Exception. (format \&quot;Value does not match schema: %s\&quot;\n                                 (schema.utils/error-val result))))\n      result)))&quot; &quot;(coerce-and-validate {(s/required-key \&quot;@id\&quot;) s/Str}\n                     (fn [schema]\n                       (println \&quot;schema:\&quot; schema)\n                       (when (= (s/map-entry (s/eq \&quot;@id\&quot;) s/Str) schema)\n                         (println \&quot;matched!\&quot;)\n                         (schema.coerce/safe\n                          (fn [my-x]\n                            (println \&quot;my-x:\&quot; my-x)\n                            (when (= my-x :id)\n                              \&quot;@id\&quot;)))))\n                     {:id \&quot;foo\&quot;})&quot; &quot;(coerce-and-validate {:id s/Num}\n                     (fn [schema]\n                       (println \&quot;schema:\&quot; schema)\n                       (when (= s/Num schema)\n                         (println \&quot;matched!\&quot;)\n                         (schema.coerce/safe\n                          (fn [my-x]\n                            (println \&quot;my-x:\&quot; my-x)\n                            1))))\n                     {:id \&quot;foo\&quot;})&quot; &quot;(coerce-and-validate {:id s/Num}\n                     (fn [schema]\n                       (println \&quot;schema:\&quot; schema)\n                       (when (= (s/map-entry :id s/Num) schema)\n                         (println \&quot;matched!\&quot;)\n                         (schema.coerce/safe\n                          (fn [my-x]\n                            (println \&quot;my-x:\&quot; my-x)\n                            1))))\n                     {:id \&quot;foo\&quot;})&quot; &quot;(coerce-and-validate {:id s/Num}\n                     (fn [schema]\n                       (println \&quot;schema:\&quot; schema)\n                       (when (= (s/map-entry (s/eq :id) s/Num) schema)\n                         (println \&quot;matched!\&quot;)\n                         (schema.coerce/safe\n                          (fn [my-x]\n                            (println \&quot;my-x:\&quot; my-x)\n                            1))))\n                     {:id \&quot;foo\&quot;})&quot; &quot;(coerce-and-validate {:id s/Num}\n                     (fn [schema]\n                       (println \&quot;schema:\&quot; schema)\n                       (when (= (s/map-entry (s/eq :id) s/Num) schema)\n                         (println \&quot;matched!\&quot;)\n                         (schema.coerce/safe\n                          (fn [my-x]\n                            (println \&quot;my-x:\&quot; my-x)\n                            [:id 1]))))\n                     {:id \&quot;foo\&quot;})&quot; &quot;(pst *e)&quot;], :remote []}}</component>
</project>