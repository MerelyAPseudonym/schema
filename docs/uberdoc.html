<!DOCTYPE html>
<html><head><meta charset="utf-8" content="text/html" http-equiv="Content-Type" /><meta content="Clojure(Script) library for declarative data description and validation" name="description" /><style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter a,
.syntaxhighlighter div,
.syntaxhighlighter code,
.syntaxhighlighter table,
.syntaxhighlighter table td,
.syntaxhighlighter table tr,
.syntaxhighlighter table tbody,
.syntaxhighlighter table thead,
.syntaxhighlighter table caption,
.syntaxhighlighter textarea {
  -moz-border-radius: 0 0 0 0 !important;
  -webkit-border-radius: 0 0 0 0 !important;
  background: none !important;
  border: 0 !important;
  bottom: auto !important;
  float: none !important;
  height: auto !important;
  left: auto !important;
  line-height: 1.1em !important;
/*  margin: 0 !important; */
  outline: 0 !important;
  overflow: visible !important;
  padding: 0 !important;
  position: static !important;
  right: auto !important;
  text-align: left !important;
  top: auto !important;
  vertical-align: baseline !important;
  width: auto !important;
  box-sizing: content-box !important;
  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace !important;
  font-weight: normal !important;
  font-style: normal !important;
  min-height: inherit !important;
  min-height: auto !important;
}

.syntaxhighlighter {
/*  width: 100% !important; */
  margin: 1em 0 1em 0 !important;
  position: relative !important;
  overflow: auto !important;
}
.syntaxhighlighter.source {
  overflow: hidden !important;
}
.syntaxhighlighter .bold {
  font-weight: bold !important;
}
.syntaxhighlighter .italic {
  font-style: italic !important;
}
.syntaxhighlighter .line {
  white-space: pre !important;
}
.syntaxhighlighter table {
/*    width: 100% !important;*/
}
.syntaxhighlighter table caption {
  text-align: left !important;
  padding: .5em 0 0.5em 1em !important;
}
.syntaxhighlighter table td.code {
  width: 100% !important;
}
.syntaxhighlighter table td.code .container {
  position: relative !important;
}
.syntaxhighlighter table td.code .container textarea {
  box-sizing: border-box !important;
  position: absolute !important;
  left: 0 !important;
  top: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border: none !important;
  background: white !important;
  padding-left: 1em !important;
  overflow: hidden !important;
  white-space: pre !important;
}
.syntaxhighlighter table td.gutter .line {
  text-align: right !important;
  padding: 0 0.5em 0 1em !important;
}
.syntaxhighlighter table td.code .line {
  padding: 0 1em !important;
}
.syntaxhighlighter.nogutter td.code .container textarea, .syntaxhighlighter.nogutter td.code .line {
  padding-left: 0em !important;
}
.syntaxhighlighter.show {
  display: block !important;
}
.syntaxhighlighter.collapsed table {
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar {
    display: none;
/*  padding: 0.1em 0.8em 0em 0.8em !important;
  font-size: 1em !important;
  position: static !important;
  width: auto !important;
  height: auto !important;*/
}
.syntaxhighlighter.collapsed .toolbar span {
  display: inline !important;
  margin-right: 1em !important;
}
.syntaxhighlighter.collapsed .toolbar span a {
  padding: 0 !important;
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar span a.expandSource {
  display: inline !important;
}
.syntaxhighlighter .toolbar {
    display: none;
/*  position: absolute !important;
  right: 1px !important;
  top: 1px !important;
  width: 11px !important;
  height: 11px !important;
  font-size: 10px !important;
  z-index: 10 !important;*/
}
.syntaxhighlighter .toolbar span.title {
  display: inline !important;
}
.syntaxhighlighter .toolbar a {
  display: block !important;
  text-align: center !important;
  text-decoration: none !important;
  padding-top: 1px !important;
}
.syntaxhighlighter .toolbar a.expandSource {
  display: none !important;
}
.syntaxhighlighter.ie {
  font-size: .9em !important;
  padding: 1px 0 1px 0 !important;
}
.syntaxhighlighter.ie .toolbar {
  line-height: 8px !important;
}
.syntaxhighlighter.ie .toolbar a {
  padding-top: 0px !important;
}
.syntaxhighlighter.printing .line.alt1 .content,
.syntaxhighlighter.printing .line.alt2 .content,
.syntaxhighlighter.printing .line.highlighted .number,
.syntaxhighlighter.printing .line.highlighted.alt1 .content,
.syntaxhighlighter.printing .line.highlighted.alt2 .content {
  background: none !important;
}
.syntaxhighlighter.printing .line .number {
  color: #bbbbbb !important;
}
.syntaxhighlighter.printing .line .content {
  color: black !important;
}
.syntaxhighlighter.printing .toolbar {
  display: none !important;
}
.syntaxhighlighter.printing a {
  text-decoration: none !important;
}
.syntaxhighlighter.printing .plain, .syntaxhighlighter.printing .plain a {
  color: black !important;
}
.syntaxhighlighter.printing .comments, .syntaxhighlighter.printing .comments a {
  color: #008200 !important;
}
.syntaxhighlighter.printing .string, .syntaxhighlighter.printing .string a {
  color: blue !important;
}
.syntaxhighlighter.printing .keyword {
  color: #006699 !important;
  font-weight: bold !important;
}
.syntaxhighlighter.printing .preprocessor {
  color: gray !important;
}
.syntaxhighlighter.printing .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter.printing .value {
  color: #009900 !important;
}
.syntaxhighlighter.printing .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .constants {
  color: #0066cc !important;
}
.syntaxhighlighter.printing .script {
  font-weight: bold !important;
}
.syntaxhighlighter.printing .color1, .syntaxhighlighter.printing .color1 a {
  color: gray !important;
}
.syntaxhighlighter.printing .color2, .syntaxhighlighter.printing .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .color3, .syntaxhighlighter.printing .color3 a {
  color: red !important;
}
.syntaxhighlighter.printing .break, .syntaxhighlighter.printing .break a {
  color: black !important;
}
</style><style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style><style type="text/css">/**
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #c3defe !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: white !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #787878 !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #d4d0c8 !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #d4d0c8 !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: #3f5fbf !important;
  background: white !important;
  border: 1px solid #d4d0c8 !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: #3f5fbf !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: #aa7700 !important;
}
.syntaxhighlighter .toolbar {
  color: #a0a0a0 !important;
  background: #d4d0c8 !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: #a0a0a0 !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #3f5fbf !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: #2a00ff !important;
}
.syntaxhighlighter .keyword {
  color: #7f0055 !important;
}
.syntaxhighlighter .preprocessor {
  color: #646464 !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #7f0055 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .xml .keyword {
  color: #3f7f7f !important;
  font-weight: normal !important;
}
.syntaxhighlighter .xml .color1, .syntaxhighlighter .xml .color1 a {
  color: #7f007f !important;
}
.syntaxhighlighter .xml .string {
  font-style: italic !important;
  color: #2a00ff !important;
}

.clojure.syntaxhighlighter .invalid { 
   background-color: #FAA !important;
}

.clojure.syntaxhighlighter .quoted {      
    font-style: italic !important;
}

.syntaxhighlighter .clojure.variable,
.syntaxhighlighter .clojure.symbol,
.syntaxhighlighter .clojure.value
{
    color: #006060 !important;
}

.syntaxhighlighter .clojure.string {
    color: #55B !important;
}

.syntaxhighlighter .clojure.functions {
    color: black !important;
}

.syntaxhighlighter .clojure.color1 {
    color: #666 !important;
}

.syntaxhighlighter .clojure.color3 {
    color: #900 !important;
}

.syntaxhighlighter .clojure.constants {
    color: #1A734D !important;
}

</style><style type="text/css">html{padding:0;margin:0;}h1{padding:0;margin:0;}h2{padding:0;margin:0;}h3{padding:0;margin:0;}h4{padding:0;margin:0;}a{color:#261A3B;}a:visited{color:#261A3B;}</style><style type="text/css">.header{margin-top:30px;}h1.project-name{font-size:34px;display:inline;}h2.project-version{font-size:18px;margin-left:10px;margin-top:0;display:inline;}.toc-link{color:#252519;font-size:12px;margin-left:10px;text-decoration:none;}.toc-link:hover{color:#5050A6;}.toc h1{font-size:34px;margin:0;}.docs-header{padding-bottom:10px;margin-bottom:25px;border-bottom:dotted #aaa 1px;}.toc h1{font-size:24px;}.toc{margin-bottom:40px;border-bottom:solid #bbb 1px;}.toc ul{margin-left:20px;margin-top:0;padding-top:0;padding-left:0px;}.toc li{list-style-type:none;padding-left:0;}.dependencies{}.dependencies table{font-size:16px;margin-left:20px;width:99.99%;border:none;}.dependencies td{white-space:nowrap;padding-right:20px;;}.dependencies .dotted{width:99%;}.dependencies .dotted hr{border-right:none;color:transparent;background-color:transparent;noshade:noshade;border-left:none;border-top:none;margin-bottom:-6px;height:0;border-bottom:dotted #bbb 1px;}.dependencies .dep-version{text-align:right;}.plugins ul{margin-left:20px;margin-top:0;padding-top:0;padding-left:0px;}.plugins li{list-style-type:none;padding-left:0;}.header p{margin-left:20px;}</style><style type="text/css">#floating-toc{text-align:right;top:10px;overflow:hidden;right:20px;position:fixed;height:20px;}#floating-toc li{list-style-type:none;padding:0;margin:0;}</style><style type="text/css">body{color:#252519;font-size:16px;background-color:#F5F5FF;padding:0;font-family:'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;;margin:0;}h1{font-size:20px;margin-top:0;}h2{font-size:18px;}h3{font-size:16px;}a.anchor{color:#252519;text-decoration:none;}a.anchor:hover{color:#5050A6;}table{border-spacing:0;margin-bottom:10px;border-bottom:solid #ddd 1px;;}code{display:inline;}p{margin-top:8px;}tr{padding:0px;margin:0px;}td.docs{vertical-align:top;background-color:#FFF;width:410px;max-width:410px;padding-right:20px;padding-left:55px;border:none;margin:0px;}td.docs pre{font-size:12px;overflow:hidden;}td.codes{vertical-align:top;font-size:10pt;overflow:hidden;background-color:#F5F5FF;width:55%;border-left:solid #E5E5EE 1px;padding-left:20px;border:none;margin:0px;}td.spacer{padding-bottom:40px;}pre code{padding:4px;display:block;}code{font-size:14px;background-color:ghostWhite;padding-right:3px;padding-left:3px;border:solid #DEDEDE 1px;}.syntaxhighlighter code{font-size:13px;}.footer{text-align:center;}</style><script type="text/javascript">/*! jQuery v1.7.1 jquery.com | jquery.org/license */
(function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cv(a){if(!ck[a]){var b=c.body,d=f("<"+a+">").appendTo(b),e=d.css("display");d.remove();if(e==="none"||e===""){cl||(cl=c.createElement("iframe"),cl.frameBorder=cl.width=cl.height=0),b.appendChild(cl);if(!cm||!cl.createElement)cm=(cl.contentWindow||cl.contentDocument).document,cm.write((c.compatMode==="CSS1Compat"?"<!doctype html>":"")+"<html><body>"),cm.close();d=cm.createElement(a),cm.body.appendChild(d),e=f.css(d,"display"),b.removeChild(cl)}ck[a]=e}return ck[a]}function cu(a,b){var c={};f.each(cq.concat.apply([],cq.slice(0,b)),function(){c[this]=a});return c}function ct(){cr=b}function cs(){setTimeout(ct,0);return cr=f.now()}function cj(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}function ci(){try{return new a.XMLHttpRequest}catch(b){}}function cc(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g<i;g++){if(g===1)for(h in a.converters)typeof h=="string"&&(e[h.toLowerCase()]=a.converters[h]);l=k,k=d[g];if(k==="*")k=l;else if(l!=="*"&&l!==k){m=l+" "+k,n=e[m]||e["* "+k];if(!n){p=b;for(o in e){j=o.split(" ");if(j[0]===l||j[0]==="*"){p=e[j[1]+" "+k];if(p){o=e[o],o===!0?n=p:p===!0&&(n=o);break}}}}!n&&!p&&f.error("No conversion from "+m.replace(" "," to ")),n!==!0&&(c=n?n(c):p(o(c)))}}return c}function cb(a,c,d){var e=a.contents,f=a.dataTypes,g=a.responseFields,h,i,j,k;for(i in g)i in d&&(c[g[i]]=d[i]);while(f[0]==="*")f.shift(),h===b&&(h=a.mimeType||c.getResponseHeader("content-type"));if(h)for(i in e)if(e[i]&&e[i].test(h)){f.unshift(i);break}if(f[0]in d)j=f[0];else{for(i in d){if(!f[0]||a.converters[i+" "+f[0]]){j=i;break}k||(k=i)}j=j||k}if(j){j!==f[0]&&f.unshift(j);return d[j]}}function ca(a,b,c,d){if(f.isArray(b))f.each(b,function(b,e){c||bE.test(a)?d(a,e):ca(a+"["+(typeof e=="object"||f.isArray(e)?b:"")+"]",e,c,d)});else if(!c&&b!=null&&typeof b=="object")for(var e in b)ca(a+"["+e+"]",b[e],c,d);else d(a,b)}function b_(a,c){var d,e,g=f.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((g[d]?a:e||(e={}))[d]=c[d]);e&&f.extend(!0,a,e)}function b$(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h=a[f],i=0,j=h?h.length:0,k=a===bT,l;for(;i<j&&(k||!l);i++)l=h[i](c,d,e),typeof l=="string"&&(!k||g[l]?l=b:(c.dataTypes.unshift(l),l=b$(a,c,d,e,l,g)));(k||!l)&&!g["*"]&&(l=b$(a,c,d,e,"*",g));return l}function bZ(a){return function(b,c){typeof b!="string"&&(c=b,b="*");if(f.isFunction(c)){var d=b.toLowerCase().split(bP),e=0,g=d.length,h,i,j;for(;e<g;e++)h=d[e],j=/^\+/.test(h),j&&(h=h.substr(1)||"*"),i=a[h]=a[h]||[],i[j?"unshift":"push"](c)}}}function bC(a,b,c){var d=b==="width"?a.offsetWidth:a.offsetHeight,e=b==="width"?bx:by,g=0,h=e.length;if(d>0){if(c!=="border")for(;g<h;g++)c||(d-=parseFloat(f.css(a,"padding"+e[g]))||0),c==="margin"?d+=parseFloat(f.css(a,c+e[g]))||0:d-=parseFloat(f.css(a,"border"+e[g]+"Width"))||0;return d+"px"}d=bz(a,b,b);if(d<0||d==null)d=a.style[b]||0;d=parseFloat(d)||0;if(c)for(;g<h;g++)d+=parseFloat(f.css(a,"padding"+e[g]))||0,c!=="padding"&&(d+=parseFloat(f.css(a,"border"+e[g]+"Width"))||0),c==="margin"&&(d+=parseFloat(f.css(a,c+e[g]))||0);return d+"px"}function bp(a,b){b.src?f.ajax({url:b.src,async:!1,dataType:"script"}):f.globalEval((b.text||b.textContent||b.innerHTML||"").replace(bf,"/*$0*/")),b.parentNode&&b.parentNode.removeChild(b)}function bo(a){var b=c.createElement("div");bh.appendChild(b),b.innerHTML=a.outerHTML;return b.firstChild}function bn(a){var b=(a.nodeName||"").toLowerCase();b==="input"?bm(a):b!=="script"&&typeof a.getElementsByTagName!="undefined"&&f.grep(a.getElementsByTagName("input"),bm)}function bm(a){if(a.type==="checkbox"||a.type==="radio")a.defaultChecked=a.checked}function bl(a){return typeof a.getElementsByTagName!="undefined"?a.getElementsByTagName("*"):typeof a.querySelectorAll!="undefined"?a.querySelectorAll("*"):[]}function bk(a,b){var c;if(b.nodeType===1){b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase();if(c==="object")b.outerHTML=a.outerHTML;else if(c!=="input"||a.type!=="checkbox"&&a.type!=="radio"){if(c==="option")b.selected=a.defaultSelected;else if(c==="input"||c==="textarea")b.defaultValue=a.defaultValue}else a.checked&&(b.defaultChecked=b.checked=a.checked),b.value!==a.value&&(b.value=a.value);b.removeAttribute(f.expando)}}function bj(a,b){if(b.nodeType===1&&!!f.hasData(a)){var c,d,e,g=f._data(a),h=f._data(b,g),i=g.events;if(i){delete h.handle,h.events={};for(c in i)for(d=0,e=i[c].length;d<e;d++)f.event.add(b,c+(i[c][d].namespace?".":"")+i[c][d].namespace,i[c][d],i[c][d].data)}h.data&&(h.data=f.extend({},h.data))}}function bi(a,b){return f.nodeName(a,"table")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function U(a){var b=V.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function T(a,b,c){b=b||0;if(f.isFunction(b))return f.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return f.grep(a,function(a,d){return a===b===c});if(typeof b=="string"){var d=f.grep(a,function(a){return a.nodeType===1});if(O.test(b))return f.filter(b,d,!c);b=f.filter(b,d)}return f.grep(a,function(a,d){return f.inArray(a,b)>=0===c})}function S(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function K(){return!0}function J(){return!1}function n(a,b,c){var d=b+"defer",e=b+"queue",g=b+"mark",h=f._data(a,d);h&&(c==="queue"||!f._data(a,e))&&(c==="mark"||!f._data(a,g))&&setTimeout(function(){!f._data(a,e)&&!f._data(a,g)&&(f.removeData(a,d,!0),h.fire())},0)}function m(a){for(var b in a){if(b==="data"&&f.isEmptyObject(a[b]))continue;if(b!=="toJSON")return!1}return!0}function l(a,c,d){if(d===b&&a.nodeType===1){var e="data-"+c.replace(k,"-$1").toLowerCase();d=a.getAttribute(e);if(typeof d=="string"){try{d=d==="true"?!0:d==="false"?!1:d==="null"?null:f.isNumeric(d)?parseFloat(d):j.test(d)?f.parseJSON(d):d}catch(g){}f.data(a,c,d)}else d=b}return d}function h(a){var b=g[a]={},c,d;a=a.split(/\s+/);for(c=0,d=a.length;c<d;c++)b[a[c]]=!0;return b}var c=a.document,d=a.navigator,e=a.location,f=function(){function J(){if(!e.isReady){try{c.documentElement.doScroll("left")}catch(a){setTimeout(J,1);return}e.ready()}}var e=function(a,b){return new e.fn.init(a,b,h)},f=a.jQuery,g=a.$,h,i=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,j=/\S/,k=/^\s+/,l=/\s+$/,m=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,n=/^[\],:{}\s]*$/,o=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,p=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,q=/(?:^|:|,)(?:\s*\[)+/g,r=/(webkit)[ \/]([\w.]+)/,s=/(opera)(?:.*version)?[ \/]([\w.]+)/,t=/(msie) ([\w.]+)/,u=/(mozilla)(?:.*? rv:([\w.]+))?/,v=/-([a-z]|[0-9])/ig,w=/^-ms-/,x=function(a,b){return(b+"").toUpperCase()},y=d.userAgent,z,A,B,C=Object.prototype.toString,D=Object.prototype.hasOwnProperty,E=Array.prototype.push,F=Array.prototype.slice,G=String.prototype.trim,H=Array.prototype.indexOf,I={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a==="body"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a=="string"){a.charAt(0)!=="<"||a.charAt(a.length-1)!==">"||a.length<3?g=i.exec(a):g=[null,a,null];if(g&&(g[1]||!d)){if(g[1]){d=d instanceof e?d[0]:d,k=d?d.ownerDocument||d:c,j=m.exec(a),j?e.isPlainObject(d)?(a=[c.createElement(j[1])],e.fn.attr.call(a,d,!0)):a=[k.createElement(j[1])]:(j=e.buildFragment([g[1]],[k]),a=(j.cacheable?e.clone(j.fragment):j.fragment).childNodes);return e.merge(this,a)}h=c.getElementById(g[2]);if(h&&h.parentNode){if(h.id!==g[2])return f.find(a);this.length=1,this[0]=h}this.context=c,this.selector=a;return this}return!d||d.jquery?(d||f).find(a):this.constructor(d).find(a)}if(e.isFunction(a))return f.ready(a);a.selector!==b&&(this.selector=a.selector,this.context=a.context);return e.makeArray(a,this)},selector:"",jquery:"1.7.1",length:0,size:function(){return this.length},toArray:function(){return F.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=this.constructor();e.isArray(a)?E.apply(d,a):e.merge(d,a),d.prevObject=this,d.context=this.context,b==="find"?d.selector=this.selector+(this.selector?" ":"")+c:b&&(d.selector=this.selector+"."+b+"("+c+")");return d},each:function(a,b){return e.each(this,a,b)},ready:function(a){e.bindReady(),A.add(a);return this},eq:function(a){a=+a;return a===-1?this.slice(a):this.slice(a,a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(F.apply(this,arguments),"slice",F.call(arguments).join(","))},map:function(a){return this.pushStack(e.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:E,sort:[].sort,splice:[].splice},e.fn.init.prototype=e.fn,e.extend=e.fn.extend=function(){var a,c,d,f,g,h,i=arguments[0]||{},j=1,k=arguments.length,l=!1;typeof i=="boolean"&&(l=i,i=arguments[1]||{},j=2),typeof i!="object"&&!e.isFunction(i)&&(i={}),k===j&&(i=this,--j);for(;j<k;j++)if((a=arguments[j])!=null)for(c in a){d=i[c],f=a[c];if(i===f)continue;l&&f&&(e.isPlainObject(f)||(g=e.isArray(f)))?(g?(g=!1,h=d&&e.isArray(d)?d:[]):h=d&&e.isPlainObject(d)?d:{},i[c]=e.extend(l,h,f)):f!==b&&(i[c]=f)}return i},e.extend({noConflict:function(b){a.$===e&&(a.$=g),b&&a.jQuery===e&&(a.jQuery=f);return e},isReady:!1,readyWait:1,holdReady:function(a){a?e.readyWait++:e.ready(!0)},ready:function(a){if(a===!0&&!--e.readyWait||a!==!0&&!e.isReady){if(!c.body)return setTimeout(e.ready,1);e.isReady=!0;if(a!==!0&&--e.readyWait>0)return;A.fireWith(c,[e]),e.fn.trigger&&e(c).trigger("ready").off("ready")}},bindReady:function(){if(!A){A=e.Callbacks("once memory");if(c.readyState==="complete")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener("DOMContentLoaded",B,!1),a.addEventListener("load",e.ready,!1);else if(c.attachEvent){c.attachEvent("onreadystatechange",B),a.attachEvent("onload",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&J()}}},isFunction:function(a){return e.type(a)==="function"},isArray:Array.isArray||function(a){return e.type(a)==="array"},isWindow:function(a){return a&&typeof a=="object"&&"setInterval"in a},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):I[C.call(a)]||"object"},isPlainObject:function(a){if(!a||e.type(a)!=="object"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!D.call(a,"constructor")&&!D.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}var d;for(d in a);return d===b||D.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw new Error(a)},parseJSON:function(b){if(typeof b!="string"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(n.test(b.replace(o,"@").replace(p,"]").replace(q,"")))return(new Function("return "+b))();e.error("Invalid JSON: "+b)},parseXML:function(c){var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,"text/xml")):(d=new ActiveXObject("Microsoft.XMLDOM"),d.async="false",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName("parsererror").length)&&e.error("Invalid XML: "+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(w,"ms-").replace(v,x)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g<h;)if(c.apply(a[g++],d)===!1)break}else if(i){for(f in a)if(c.call(a[f],f,a[f])===!1)break}else for(;g<h;)if(c.call(a[g],g,a[g++])===!1)break;return a},trim:G?function(a){return a==null?"":G.call(a)}:function(a){return a==null?"":(a+"").replace(k,"").replace(l,"")},makeArray:function(a,b){var c=b||[];if(a!=null){var d=e.type(a);a.length==null||d==="string"||d==="function"||d==="regexp"||e.isWindow(a)?E.call(c,a):e.merge(c,a)}return c},inArray:function(a,b,c){var d;if(b){if(H)return H.call(b,a,c);d=b.length,c=c?c<0?Math.max(0,d+c):c:0;for(;c<d;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,c){var d=a.length,e=0;if(typeof c.length=="number")for(var f=c.length;e<f;e++)a[d++]=c[e];else while(c[e]!==b)a[d++]=c[e++];a.length=d;return a},grep:function(a,b,c){var d=[],e;c=!!c;for(var f=0,g=a.length;f<g;f++)e=!!b(a[f],f),c!==e&&d.push(a[f]);return d},map:function(a,c,d){var f,g,h=[],i=0,j=a.length,k=a instanceof e||j!==b&&typeof j=="number"&&(j>0&&a[0]&&a[j-1]||j===0||e.isArray(a));if(k)for(;i<j;i++)f=c(a[i],i,d),f!=null&&(h[h.length]=f);else for(g in a)f=c(a[g],g,d),f!=null&&(h[h.length]=f);return h.concat.apply([],h)},guid:1,proxy:function(a,c){if(typeof c=="string"){var d=a[c];c=a,a=d}if(!e.isFunction(a))return b;var f=F.call(arguments,2),g=function(){return a.apply(c,f.concat(F.call(arguments)))};g.guid=a.guid=a.guid||g.guid||e.guid++;return g},access:function(a,c,d,f,g,h){var i=a.length;if(typeof c=="object"){for(var j in c)e.access(a,j,c[j],f,g,d);return a}if(d!==b){f=!h&&f&&e.isFunction(d);for(var k=0;k<i;k++)g(a[k],c,f?d.call(a[k],k,g(a[k],c)):d,h);return a}return i?g(a[0],c):b},now:function(){return(new Date).getTime()},uaMatch:function(a){a=a.toLowerCase();var b=r.exec(a)||s.exec(a)||t.exec(a)||a.indexOf("compatible")<0&&u.exec(a)||[];return{browser:b[1]||"",version:b[2]||"0"}},sub:function(){function a(b,c){return new a.fn.init(b,c)}e.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function(d,f){f&&f instanceof e&&!(f instanceof a)&&(f=a(f));return e.fn.init.call(this,d,f,b)},a.fn.init.prototype=a.fn;var b=a(c);return a},browser:{}}),e.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(a,b){I["[object "+b+"]"]=b.toLowerCase()}),z=e.uaMatch(y),z.browser&&(e.browser[z.browser]=!0,e.browser.version=z.version),e.browser.webkit&&(e.browser.safari=!0),j.test(" ")&&(k=/^[\s\xA0]+/,l=/[\s\xA0]+$/),h=e(c),c.addEventListener?B=function(){c.removeEventListener("DOMContentLoaded",B,!1),e.ready()}:c.attachEvent&&(B=function(){c.readyState==="complete"&&(c.detachEvent("onreadystatechange",B),e.ready())});return e}(),g={};f.Callbacks=function(a){a=a?g[a]||h(a):{};var c=[],d=[],e,i,j,k,l,m=function(b){var d,e,g,h,i;for(d=0,e=b.length;d<e;d++)g=b[d],h=f.type(g),h==="array"?m(g):h==="function"&&(!a.unique||!o.has(g))&&c.push(g)},n=function(b,f){f=f||[],e=!a.memory||[b,f],i=!0,l=j||0,j=0,k=c.length;for(;c&&l<k;l++)if(c[l].apply(b,f)===!1&&a.stopOnFalse){e=!0;break}i=!1,c&&(a.once?e===!0?o.disable():c=[]:d&&d.length&&(e=d.shift(),o.fireWith(e[0],e[1])))},o={add:function(){if(c){var a=c.length;m(arguments),i?k=c.length:e&&e!==!0&&(j=a,n(e[0],e[1]))}return this},remove:function(){if(c){var b=arguments,d=0,e=b.length;for(;d<e;d++)for(var f=0;f<c.length;f++)if(b[d]===c[f]){i&&f<=k&&(k--,f<=l&&l--),c.splice(f--,1);if(a.unique)break}}return this},has:function(a){if(c){var b=0,d=c.length;for(;b<d;b++)if(a===c[b])return!0}return!1},empty:function(){c=[];return this},disable:function(){c=d=e=b;return this},disabled:function(){return!c},lock:function(){d=b,(!e||e===!0)&&o.disable();return this},locked:function(){return!d},fireWith:function(b,c){d&&(i?a.once||d.push([b,c]):(!a.once||!e)&&n(b,c));return this},fire:function(){o.fireWith(this,arguments);return this},fired:function(){return!!e}};return o};var i=[].slice;f.extend({Deferred:function(a){var b=f.Callbacks("once memory"),c=f.Callbacks("once memory"),d=f.Callbacks("memory"),e="pending",g={resolve:b,reject:c,notify:d},h={done:b.add,fail:c.add,progress:d.add,state:function(){return e},isResolved:b.fired,isRejected:c.fired,then:function(a,b,c){i.done(a).fail(b).progress(c);return this},always:function(){i.done.apply(i,arguments).fail.apply(i,arguments);return this},pipe:function(a,b,c){return f.Deferred(function(d){f.each({done:[a,"resolve"],fail:[b,"reject"],progress:[c,"notify"]},function(a,b){var c=b[0],e=b[1],g;f.isFunction(c)?i[a](function(){g=c.apply(this,arguments),g&&f.isFunction(g.promise)?g.promise().then(d.resolve,d.reject,d.notify):d[e+"With"](this===i?d:this,[g])}):i[a](d[e])})}).promise()},promise:function(a){if(a==null)a=h;else for(var b in h)a[b]=h[b];return a}},i=h.promise({}),j;for(j in g)i[j]=g[j].fire,i[j+"With"]=g[j].fireWith;i.done(function(){e="resolved"},c.disable,d.lock).fail(function(){e="rejected"},b.disable,d.lock),a&&a.call(i,i);return i},when:function(a){function m(a){return function(b){e[a]=arguments.length>1?i.call(arguments,0):b,j.notifyWith(k,e)}}function l(a){return function(c){b[a]=arguments.length>1?i.call(arguments,0):c,--g||j.resolveWith(j,b)}}var b=i.call(arguments,0),c=0,d=b.length,e=Array(d),g=d,h=d,j=d<=1&&a&&f.isFunction(a.promise)?a:f.Deferred(),k=j.promise();if(d>1){for(;c<d;c++)b[c]&&b[c].promise&&f.isFunction(b[c].promise)?b[c].promise().then(l(c),j.reject,m(c)):--g;g||j.resolveWith(j,b)}else j!==a&&j.resolveWith(j,d?[a]:[]);return k}}),f.support=function(){var b,d,e,g,h,i,j,k,l,m,n,o,p,q=c.createElement("div"),r=c.documentElement;q.setAttribute("className","t"),q.innerHTML="   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>",d=q.getElementsByTagName("*"),e=q.getElementsByTagName("a")[0];if(!d||!d.length||!e)return{};g=c.createElement("select"),h=g.appendChild(c.createElement("option")),i=q.getElementsByTagName("input")[0],b={leadingWhitespace:q.firstChild.nodeType===3,tbody:!q.getElementsByTagName("tbody").length,htmlSerialize:!!q.getElementsByTagName("link").length,style:/top/.test(e.getAttribute("style")),hrefNormalized:e.getAttribute("href")==="/a",opacity:/^0.55/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:i.value==="on",optSelected:h.selected,getSetAttribute:q.className!=="t",enctype:!!c.createElement("form").enctype,html5Clone:c.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0},i.checked=!0,b.noCloneChecked=i.cloneNode(!0).checked,g.disabled=!0,b.optDisabled=!h.disabled;try{delete q.test}catch(s){b.deleteExpando=!1}!q.addEventListener&&q.attachEvent&&q.fireEvent&&(q.attachEvent("onclick",function(){b.noCloneEvent=!1}),q.cloneNode(!0).fireEvent("onclick")),i=c.createElement("input"),i.value="t",i.setAttribute("type","radio"),b.radioValue=i.value==="t",i.setAttribute("checked","checked"),q.appendChild(i),k=c.createDocumentFragment(),k.appendChild(q.lastChild),b.checkClone=k.cloneNode(!0).cloneNode(!0).lastChild.checked,b.appendChecked=i.checked,k.removeChild(i),k.appendChild(q),q.innerHTML="",a.getComputedStyle&&(j=c.createElement("div"),j.style.width="0",j.style.marginRight="0",q.style.width="2px",q.appendChild(j),b.reliableMarginRight=(parseInt((a.getComputedStyle(j,null)||{marginRight:0}).marginRight,10)||0)===0);if(q.attachEvent)for(o in{submit:1,change:1,focusin:1})n="on"+o,p=n in q,p||(q.setAttribute(n,"return;"),p=typeof q[n]=="function"),b[o+"Bubbles"]=p;k.removeChild(q),k=g=h=j=q=i=null,f(function(){var a,d,e,g,h,i,j,k,m,n,o,r=c.getElementsByTagName("body")[0];!r||(j=1,k="position:absolute;top:0;left:0;width:1px;height:1px;margin:0;",m="visibility:hidden;border:0;",n="style='"+k+"border:5px solid #000;padding:0;'",o="<div "+n+"><div></div></div>"+"<table "+n+" cellpadding='0' cellspacing='0'>"+"<tr><td></td></tr></table>",a=c.createElement("div"),a.style.cssText=m+"width:0;height:0;position:static;top:0;margin-top:"+j+"px",r.insertBefore(a,r.firstChild),q=c.createElement("div"),a.appendChild(q),q.innerHTML="<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>",l=q.getElementsByTagName("td"),p=l[0].offsetHeight===0,l[0].style.display="",l[1].style.display="none",b.reliableHiddenOffsets=p&&l[0].offsetHeight===0,q.innerHTML="",q.style.width=q.style.paddingLeft="1px",f.boxModel=b.boxModel=q.offsetWidth===2,typeof q.style.zoom!="undefined"&&(q.style.display="inline",q.style.zoom=1,b.inlineBlockNeedsLayout=q.offsetWidth===2,q.style.display="",q.innerHTML="<div style='width:4px;'></div>",b.shrinkWrapBlocks=q.offsetWidth!==2),q.style.cssText=k+m,q.innerHTML=o,d=q.firstChild,e=d.firstChild,h=d.nextSibling.firstChild.firstChild,i={doesNotAddBorder:e.offsetTop!==5,doesAddBorderForTableAndCells:h.offsetTop===5},e.style.position="fixed",e.style.top="20px",i.fixedPosition=e.offsetTop===20||e.offsetTop===15,e.style.position=e.style.top="",d.style.overflow="hidden",d.style.position="relative",i.subtractsBorderForOverflowNotVisible=e.offsetTop===-5,i.doesNotIncludeMarginInBodyOffset=r.offsetTop!==j,r.removeChild(a),q=a=null,f.extend(b,i))});return b}();var j=/^(?:\{.*\}|\[.*\])$/,k=/([A-Z])/g;f.extend({cache:{},uuid:0,expando:"jQuery"+(f.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(a){a=a.nodeType?f.cache[a[f.expando]]:a[f.expando];return!!a&&!m(a)},data:function(a,c,d,e){if(!!f.acceptData(a)){var g,h,i,j=f.expando,k=typeof c=="string",l=a.nodeType,m=l?f.cache:a,n=l?a[j]:a[j]&&j,o=c==="events";if((!n||!m[n]||!o&&!e&&!m[n].data)&&k&&d===b)return;n||(l?a[j]=n=++f.uuid:n=j),m[n]||(m[n]={},l||(m[n].toJSON=f.noop));if(typeof c=="object"||typeof c=="function")e?m[n]=f.extend(m[n],c):m[n].data=f.extend(m[n].data,c);g=h=m[n],e||(h.data||(h.data={}),h=h.data),d!==b&&(h[f.camelCase(c)]=d);if(o&&!h[c])return g.events;k?(i=h[c],i==null&&(i=h[f.camelCase(c)])):i=h;return i}},removeData:function(a,b,c){if(!!f.acceptData(a)){var d,e,g,h=f.expando,i=a.nodeType,j=i?f.cache:a,k=i?a[h]:h;if(!j[k])return;if(b){d=c?j[k]:j[k].data;if(d){f.isArray(b)||(b in d?b=[b]:(b=f.camelCase(b),b in d?b=[b]:b=b.split(" ")));for(e=0,g=b.length;e<g;e++)delete d[b[e]];if(!(c?m:f.isEmptyObject)(d))return}}if(!c){delete j[k].data;if(!m(j[k]))return}f.support.deleteExpando||!j.setInterval?delete j[k]:j[k]=null,i&&(f.support.deleteExpando?delete a[h]:a.removeAttribute?a.removeAttribute(h):a[h]=null)}},_data:function(a,b,c){return f.data(a,b,c,!0)},acceptData:function(a){if(a.nodeName){var b=f.noData[a.nodeName.toLowerCase()];if(b)return b!==!0&&a.getAttribute("classid")===b}return!0}}),f.fn.extend({data:function(a,c){var d,e,g,h=null;if(typeof a=="undefined"){if(this.length){h=f.data(this[0]);if(this[0].nodeType===1&&!f._data(this[0],"parsedAttrs")){e=this[0].attributes;for(var i=0,j=e.length;i<j;i++)g=e[i].name,g.indexOf("data-")===0&&(g=f.camelCase(g.substring(5)),l(this[0],g,h[g]));f._data(this[0],"parsedAttrs",!0)}}return h}if(typeof a=="object")return this.each(function(){f.data(this,a)});d=a.split("."),d[1]=d[1]?"."+d[1]:"";if(c===b){h=this.triggerHandler("getData"+d[1]+"!",[d[0]]),h===b&&this.length&&(h=f.data(this[0],a),h=l(this[0],a,h));return h===b&&d[1]?this.data(d[0]):h}return this.each(function(){var b=f(this),e=[d[0],c];b.triggerHandler("setData"+d[1]+"!",e),f.data(this,a,c),b.triggerHandler("changeData"+d[1]+"!",e)})},removeData:function(a){return this.each(function(){f.removeData(this,a)})}}),f.extend({_mark:function(a,b){a&&(b=(b||"fx")+"mark",f._data(a,b,(f._data(a,b)||0)+1))},_unmark:function(a,b,c){a!==!0&&(c=b,b=a,a=!1);if(b){c=c||"fx";var d=c+"mark",e=a?0:(f._data(b,d)||1)-1;e?f._data(b,d,e):(f.removeData(b,d,!0),n(b,c,"mark"))}},queue:function(a,b,c){var d;if(a){b=(b||"fx")+"queue",d=f._data(a,b),c&&(!d||f.isArray(c)?d=f._data(a,b,f.makeArray(c)):d.push(c));return d||[]}},dequeue:function(a,b){b=b||"fx";var c=f.queue(a,b),d=c.shift(),e={};d==="inprogress"&&(d=c.shift()),d&&(b==="fx"&&c.unshift("inprogress"),f._data(a,b+".run",e),d.call(a,function(){f.dequeue(a,b)},e)),c.length||(f.removeData(a,b+"queue "+b+".run",!0),n(a,b,"queue"))}}),f.fn.extend({queue:function(a,c){typeof a!="string"&&(c=a,a="fx");if(c===b)return f.queue(this[0],a);return this.each(function(){var b=f.queue(this,a,c);a==="fx"&&b[0]!=="inprogress"&&f.dequeue(this,a)})},dequeue:function(a){return this.each(function(){f.dequeue(this,a)})},delay:function(a,b){a=f.fx?f.fx.speeds[a]||a:a,b=b||"fx";return this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,c){function m(){--h||d.resolveWith(e,[e])}typeof a!="string"&&(c=a,a=b),a=a||"fx";var d=f.Deferred(),e=this,g=e.length,h=1,i=a+"defer",j=a+"queue",k=a+"mark",l;while(g--)if(l=f.data(e[g],i,b,!0)||(f.data(e[g],j,b,!0)||f.data(e[g],k,b,!0))&&f.data(e[g],i,f.Callbacks("once memory"),!0))h++,l.add(m);m();return d.promise()}});var o=/[\n\t\r]/g,p=/\s+/,q=/\r/g,r=/^(?:button|input)$/i,s=/^(?:button|input|object|select|textarea)$/i,t=/^a(?:rea)?$/i,u=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,v=f.support.getSetAttribute,w,x,y;f.fn.extend({attr:function(a,b){return f.access(this,a,b,!0,f.attr)},removeAttr:function(a){return this.each(function(){f.removeAttr(this,a)})},prop:function(a,b){return f.access(this,a,b,!0,f.prop)},removeProp:function(a){a=f.propFix[a]||a;return this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,g,h,i;if(f.isFunction(a))return this.each(function(b){f(this).addClass(a.call(this,b,this.className))});if(a&&typeof a=="string"){b=a.split(p);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{g=" "+e.className+" ";for(h=0,i=b.length;h<i;h++)~g.indexOf(" "+b[h]+" ")||(g+=b[h]+" ");e.className=f.trim(g)}}}return this},removeClass:function(a){var c,d,e,g,h,i,j;if(f.isFunction(a))return this.each(function(b){f(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a=="string"||a===b){c=(a||"").split(p);for(d=0,e=this.length;d<e;d++){g=this[d];if(g.nodeType===1&&g.className)if(a){h=(" "+g.className+" ").replace(o," ");for(i=0,j=c.length;i<j;i++)h=h.replace(" "+c[i]+" "," ");g.className=f.trim(h)}else g.className=""}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b=="boolean";if(f.isFunction(a))return this.each(function(c){f(this).toggleClass(a.call(this,c,this.className,b),b)});return this.each(function(){if(c==="string"){var e,g=0,h=f(this),i=b,j=a.split(p);while(e=j[g++])i=d?i:!h.hasClass(e),h[i?"addClass":"removeClass"](e)}else if(c==="undefined"||c==="boolean")this.className&&f._data(this,"__className__",this.className),this.className=this.className||a===!1?"":f._data(this,"__className__")||""})},hasClass:function(a){var b=" "+a+" ",c=0,d=this.length;for(;c<d;c++)if(this[c].nodeType===1&&(" "+this[c].className+" ").replace(o," ").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e,g=this[0];{if(!!arguments.length){e=f.isFunction(a);return this.each(function(d){var g=f(this),h;if(this.nodeType===1){e?h=a.call(this,d,g.val()):h=a,h==null?h="":typeof h=="number"?h+="":f.isArray(h)&&(h=f.map(h,function(a){return a==null?"":a+""})),c=f.valHooks[this.nodeName.toLowerCase()]||f.valHooks[this.type];if(!c||!("set"in c)||c.set(this,h,"value")===b)this.value=h}})}if(g){c=f.valHooks[g.nodeName.toLowerCase()]||f.valHooks[g.type];if(c&&"get"in c&&(d=c.get(g,"value"))!==b)return d;d=g.value;return typeof d=="string"?d.replace(q,""):d==null?"":d}}}}),f.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c,d,e,g=a.selectedIndex,h=[],i=a.options,j=a.type==="select-one";if(g<0)return null;c=j?g:0,d=j?g+1:i.length;for(;c<d;c++){e=i[c];if(e.selected&&(f.support.optDisabled?!e.disabled:e.getAttribute("disabled")===null)&&(!e.parentNode.disabled||!f.nodeName(e.parentNode,"optgroup"))){b=f(e).val();if(j)return b;h.push(b)}}if(j&&!h.length&&i.length)return f(i[g]).val();return h},set:function(a,b){var c=f.makeArray(b);f(a).find("option").each(function(){this.selected=f.inArray(f(this).val(),c)>=0}),c.length||(a.selectedIndex=-1);return c}}},attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attr:function(a,c,d,e){var g,h,i,j=a.nodeType;if(!!a&&j!==3&&j!==8&&j!==2){if(e&&c in f.attrFn)return f(a)[c](d);if(typeof a.getAttribute=="undefined")return f.prop(a,c,d);i=j!==1||!f.isXMLDoc(a),i&&(c=c.toLowerCase(),h=f.attrHooks[c]||(u.test(c)?x:w));if(d!==b){if(d===null){f.removeAttr(a,c);return}if(h&&"set"in h&&i&&(g=h.set(a,d,c))!==b)return g;a.setAttribute(c,""+d);return d}if(h&&"get"in h&&i&&(g=h.get(a,c))!==null)return g;g=a.getAttribute(c);return g===null?b:g}},removeAttr:function(a,b){var c,d,e,g,h=0;if(b&&a.nodeType===1){d=b.toLowerCase().split(p),g=d.length;for(;h<g;h++)e=d[h],e&&(c=f.propFix[e]||e,f.attr(a,e,""),a.removeAttribute(v?e:c),u.test(e)&&c in a&&(a[c]=!1))}},attrHooks:{type:{set:function(a,b){if(r.test(a.nodeName)&&a.parentNode)f.error("type property can't be changed");else if(!f.support.radioValue&&b==="radio"&&f.nodeName(a,"input")){var c=a.value;a.setAttribute("type",b),c&&(a.value=c);return b}}},value:{get:function(a,b){if(w&&f.nodeName(a,"button"))return w.get(a,b);return b in a?a.value:null},set:function(a,b,c){if(w&&f.nodeName(a,"button"))return w.set(a,b,c);a.value=b}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(a,c,d){var e,g,h,i=a.nodeType;if(!!a&&i!==3&&i!==8&&i!==2){h=i!==1||!f.isXMLDoc(a),h&&(c=f.propFix[c]||c,g=f.propHooks[c]);return d!==b?g&&"set"in g&&(e=g.set(a,d,c))!==b?e:a[c]=d:g&&"get"in g&&(e=g.get(a,c))!==null?e:a[c]}},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode("tabindex");return c&&c.specified?parseInt(c.value,10):s.test(a.nodeName)||t.test(a.nodeName)&&a.href?0:b}}}}),f.attrHooks.tabindex=f.propHooks.tabIndex,x={get:function(a,c){var d,e=f.prop(a,c);return e===!0||typeof e!="boolean"&&(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;b===!1?f.removeAttr(a,c):(d=f.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase()));return c}},v||(y={name:!0,id:!0},w=f.valHooks.button={get:function(a,c){var d;d=a.getAttributeNode(c);return d&&(y[c]?d.nodeValue!=="":d.specified)?d.nodeValue:b},set:function(a,b,d){var e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));return e.nodeValue=b+""}},f.attrHooks.tabindex.set=w.set,f.each(["width","height"],function(a,b){f.attrHooks[b]=f.extend(f.attrHooks[b],{set:function(a,c){if(c===""){a.setAttribute(b,"auto");return c}}})}),f.attrHooks.contenteditable={get:w.get,set:function(a,b,c){b===""&&(b="false"),w.set(a,b,c)}}),f.support.hrefNormalized||f.each(["href","src","width","height"],function(a,c){f.attrHooks[c]=f.extend(f.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),f.support.style||(f.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=""+b}}),f.support.optSelected||(f.propHooks.selected=f.extend(f.propHooks.selected,{get:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex);return null}})),f.support.enctype||(f.propFix.enctype="encoding"),f.support.checkOn||f.each(["radio","checkbox"],function(){f.valHooks[this]={get:function(a){return a.getAttribute("value")===null?"on":a.value}}}),f.each(["radio","checkbox"],function(){f.valHooks[this]=f.extend(f.valHooks[this],{set:function(a,b){if(f.isArray(b))return a.checked=f.inArray(f(a).val(),b)>=0}})});var z=/^(?:textarea|input|select)$/i,A=/^([^\.]*)?(?:\.(.+))?$/,B=/\bhover(\.\S+)?\b/,C=/^key/,D=/^(?:mouse|contextmenu)|click/,E=/^(?:focusinfocus|focusoutblur)$/,F=/^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,G=function(a){var b=F.exec(a);b&&(b[1]=(b[1]||"").toLowerCase(),b[3]=b[3]&&new RegExp("(?:^|\\s)"+b[3]+"(?:\\s|$)"));return b},H=function(a,b){var c=a.attributes||{};return(!b[1]||a.nodeName.toLowerCase()===b[1])&&(!b[2]||(c.id||{}).value===b[2])&&(!b[3]||b[3].test((c["class"]||{}).value))},I=function(a){return f.event.special.hover?a:a.replace(B,"mouseenter$1 mouseleave$1")};
f.event={add:function(a,c,d,e,g){var h,i,j,k,l,m,n,o,p,q,r,s;if(!(a.nodeType===3||a.nodeType===8||!c||!d||!(h=f._data(a)))){d.handler&&(p=d,d=p.handler),d.guid||(d.guid=f.guid++),j=h.events,j||(h.events=j={}),i=h.handle,i||(h.handle=i=function(a){return typeof f!="undefined"&&(!a||f.event.triggered!==a.type)?f.event.dispatch.apply(i.elem,arguments):b},i.elem=a),c=f.trim(I(c)).split(" ");for(k=0;k<c.length;k++){l=A.exec(c[k])||[],m=l[1],n=(l[2]||"").split(".").sort(),s=f.event.special[m]||{},m=(g?s.delegateType:s.bindType)||m,s=f.event.special[m]||{},o=f.extend({type:m,origType:l[1],data:e,handler:d,guid:d.guid,selector:g,quick:G(g),namespace:n.join(".")},p),r=j[m];if(!r){r=j[m]=[],r.delegateCount=0;if(!s.setup||s.setup.call(a,e,n,i)===!1)a.addEventListener?a.addEventListener(m,i,!1):a.attachEvent&&a.attachEvent("on"+m,i)}s.add&&(s.add.call(a,o),o.handler.guid||(o.handler.guid=d.guid)),g?r.splice(r.delegateCount++,0,o):r.push(o),f.event.global[m]=!0}a=null}},global:{},remove:function(a,b,c,d,e){var g=f.hasData(a)&&f._data(a),h,i,j,k,l,m,n,o,p,q,r,s;if(!!g&&!!(o=g.events)){b=f.trim(I(b||"")).split(" ");for(h=0;h<b.length;h++){i=A.exec(b[h])||[],j=k=i[1],l=i[2];if(!j){for(j in o)f.event.remove(a,j+b[h],c,d,!0);continue}p=f.event.special[j]||{},j=(d?p.delegateType:p.bindType)||j,r=o[j]||[],m=r.length,l=l?new RegExp("(^|\\.)"+l.split(".").sort().join("\\.(?:.*\\.)?")+"(\\.|$)"):null;for(n=0;n<r.length;n++)s=r[n],(e||k===s.origType)&&(!c||c.guid===s.guid)&&(!l||l.test(s.namespace))&&(!d||d===s.selector||d==="**"&&s.selector)&&(r.splice(n--,1),s.selector&&r.delegateCount--,p.remove&&p.remove.call(a,s));r.length===0&&m!==r.length&&((!p.teardown||p.teardown.call(a,l)===!1)&&f.removeEvent(a,j,g.handle),delete o[j])}f.isEmptyObject(o)&&(q=g.handle,q&&(q.elem=null),f.removeData(a,["events","handle"],!0))}},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,e,g){if(!e||e.nodeType!==3&&e.nodeType!==8){var h=c.type||c,i=[],j,k,l,m,n,o,p,q,r,s;if(E.test(h+f.event.triggered))return;h.indexOf("!")>=0&&(h=h.slice(0,-1),k=!0),h.indexOf(".")>=0&&(i=h.split("."),h=i.shift(),i.sort());if((!e||f.event.customEvent[h])&&!f.event.global[h])return;c=typeof c=="object"?c[f.expando]?c:new f.Event(h,c):new f.Event(h),c.type=h,c.isTrigger=!0,c.exclusive=k,c.namespace=i.join("."),c.namespace_re=c.namespace?new RegExp("(^|\\.)"+i.join("\\.(?:.*\\.)?")+"(\\.|$)"):null,o=h.indexOf(":")<0?"on"+h:"";if(!e){j=f.cache;for(l in j)j[l].events&&j[l].events[h]&&f.event.trigger(c,d,j[l].handle.elem,!0);return}c.result=b,c.target||(c.target=e),d=d!=null?f.makeArray(d):[],d.unshift(c),p=f.event.special[h]||{};if(p.trigger&&p.trigger.apply(e,d)===!1)return;r=[[e,p.bindType||h]];if(!g&&!p.noBubble&&!f.isWindow(e)){s=p.delegateType||h,m=E.test(s+h)?e:e.parentNode,n=null;for(;m;m=m.parentNode)r.push([m,s]),n=m;n&&n===e.ownerDocument&&r.push([n.defaultView||n.parentWindow||a,s])}for(l=0;l<r.length&&!c.isPropagationStopped();l++)m=r[l][0],c.type=r[l][1],q=(f._data(m,"events")||{})[c.type]&&f._data(m,"handle"),q&&q.apply(m,d),q=o&&m[o],q&&f.acceptData(m)&&q.apply(m,d)===!1&&c.preventDefault();c.type=h,!g&&!c.isDefaultPrevented()&&(!p._default||p._default.apply(e.ownerDocument,d)===!1)&&(h!=="click"||!f.nodeName(e,"a"))&&f.acceptData(e)&&o&&e[h]&&(h!=="focus"&&h!=="blur"||c.target.offsetWidth!==0)&&!f.isWindow(e)&&(n=e[o],n&&(e[o]=null),f.event.triggered=h,e[h](),f.event.triggered=b,n&&(e[o]=n));return c.result}},dispatch:function(c){c=f.event.fix(c||a.event);var d=(f._data(this,"events")||{})[c.type]||[],e=d.delegateCount,g=[].slice.call(arguments,0),h=!c.exclusive&&!c.namespace,i=[],j,k,l,m,n,o,p,q,r,s,t;g[0]=c,c.delegateTarget=this;if(e&&!c.target.disabled&&(!c.button||c.type!=="click")){m=f(this),m.context=this.ownerDocument||this;for(l=c.target;l!=this;l=l.parentNode||this){o={},q=[],m[0]=l;for(j=0;j<e;j++)r=d[j],s=r.selector,o[s]===b&&(o[s]=r.quick?H(l,r.quick):m.is(s)),o[s]&&q.push(r);q.length&&i.push({elem:l,matches:q})}}d.length>e&&i.push({elem:this,matches:d.slice(e)});for(j=0;j<i.length&&!c.isPropagationStopped();j++){p=i[j],c.currentTarget=p.elem;for(k=0;k<p.matches.length&&!c.isImmediatePropagationStopped();k++){r=p.matches[k];if(h||!c.namespace&&!r.namespace||c.namespace_re&&c.namespace_re.test(r.namespace))c.data=r.data,c.handleObj=r,n=((f.event.special[r.origType]||{}).handle||r.handler).apply(p.elem,g),n!==b&&(c.result=n,n===!1&&(c.preventDefault(),c.stopPropagation()))}}return c.result},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){a.which==null&&(a.which=b.charCode!=null?b.charCode:b.keyCode);return a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,d){var e,f,g,h=d.button,i=d.fromElement;a.pageX==null&&d.clientX!=null&&(e=a.target.ownerDocument||c,f=e.documentElement,g=e.body,a.pageX=d.clientX+(f&&f.scrollLeft||g&&g.scrollLeft||0)-(f&&f.clientLeft||g&&g.clientLeft||0),a.pageY=d.clientY+(f&&f.scrollTop||g&&g.scrollTop||0)-(f&&f.clientTop||g&&g.clientTop||0)),!a.relatedTarget&&i&&(a.relatedTarget=i===a.target?d.toElement:i),!a.which&&h!==b&&(a.which=h&1?1:h&2?3:h&4?2:0);return a}},fix:function(a){if(a[f.expando])return a;var d,e,g=a,h=f.event.fixHooks[a.type]||{},i=h.props?this.props.concat(h.props):this.props;a=f.Event(g);for(d=i.length;d;)e=i[--d],a[e]=g[e];a.target||(a.target=g.srcElement||c),a.target.nodeType===3&&(a.target=a.target.parentNode),a.metaKey===b&&(a.metaKey=a.ctrlKey);return h.filter?h.filter(a,g):a},special:{ready:{setup:f.bindReady},load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(a,b,c){f.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}},simulate:function(a,b,c,d){var e=f.extend(new f.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?f.event.trigger(e,null,b):f.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},f.event.handle=f.event.dispatch,f.removeEvent=c.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){a.detachEvent&&a.detachEvent("on"+b,c)},f.Event=function(a,b){if(!(this instanceof f.Event))return new f.Event(a,b);a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?K:J):this.type=a,b&&f.extend(this,b),this.timeStamp=a&&a.timeStamp||f.now(),this[f.expando]=!0},f.Event.prototype={preventDefault:function(){this.isDefaultPrevented=K;var a=this.originalEvent;!a||(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=K;var a=this.originalEvent;!a||(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=K,this.stopPropagation()},isDefaultPrevented:J,isPropagationStopped:J,isImmediatePropagationStopped:J},f.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){f.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c=this,d=a.relatedTarget,e=a.handleObj,g=e.selector,h;if(!d||d!==c&&!f.contains(c,d))a.type=e.origType,h=e.handler.apply(this,arguments),a.type=b;return h}}}),f.support.submitBubbles||(f.event.special.submit={setup:function(){if(f.nodeName(this,"form"))return!1;f.event.add(this,"click._submit keypress._submit",function(a){var c=a.target,d=f.nodeName(c,"input")||f.nodeName(c,"button")?c.form:b;d&&!d._submit_attached&&(f.event.add(d,"submit._submit",function(a){this.parentNode&&!a.isTrigger&&f.event.simulate("submit",this.parentNode,a,!0)}),d._submit_attached=!0)})},teardown:function(){if(f.nodeName(this,"form"))return!1;f.event.remove(this,"._submit")}}),f.support.changeBubbles||(f.event.special.change={setup:function(){if(z.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")f.event.add(this,"propertychange._change",function(a){a.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),f.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1,f.event.simulate("change",this,a,!0))});return!1}f.event.add(this,"beforeactivate._change",function(a){var b=a.target;z.test(b.nodeName)&&!b._change_attached&&(f.event.add(b,"change._change",function(a){this.parentNode&&!a.isSimulated&&!a.isTrigger&&f.event.simulate("change",this.parentNode,a,!0)}),b._change_attached=!0)})},handle:function(a){var b=a.target;if(this!==b||a.isSimulated||a.isTrigger||b.type!=="radio"&&b.type!=="checkbox")return a.handleObj.handler.apply(this,arguments)},teardown:function(){f.event.remove(this,"._change");return z.test(this.nodeName)}}),f.support.focusinBubbles||f.each({focus:"focusin",blur:"focusout"},function(a,b){var d=0,e=function(a){f.event.simulate(b,a.target,f.event.fix(a),!0)};f.event.special[b]={setup:function(){d++===0&&c.addEventListener(a,e,!0)},teardown:function(){--d===0&&c.removeEventListener(a,e,!0)}}}),f.fn.extend({on:function(a,c,d,e,g){var h,i;if(typeof a=="object"){typeof c!="string"&&(d=c,c=b);for(i in a)this.on(i,c,d,a[i],g);return this}d==null&&e==null?(e=c,d=c=b):e==null&&(typeof c=="string"?(e=d,d=b):(e=d,d=c,c=b));if(e===!1)e=J;else if(!e)return this;g===1&&(h=e,e=function(a){f().off(a);return h.apply(this,arguments)},e.guid=h.guid||(h.guid=f.guid++));return this.each(function(){f.event.add(this,a,e,d,c)})},one:function(a,b,c,d){return this.on.call(this,a,b,c,d,1)},off:function(a,c,d){if(a&&a.preventDefault&&a.handleObj){var e=a.handleObj;f(a.delegateTarget).off(e.namespace?e.type+"."+e.namespace:e.type,e.selector,e.handler);return this}if(typeof a=="object"){for(var g in a)this.off(g,c,a[g]);return this}if(c===!1||typeof c=="function")d=c,c=b;d===!1&&(d=J);return this.each(function(){f.event.remove(this,a,d,c)})},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},live:function(a,b,c){f(this.context).on(a,this.selector,b,c);return this},die:function(a,b){f(this.context).off(a,this.selector||"**",b);return this},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return arguments.length==1?this.off(a,"**"):this.off(b,a,c)},trigger:function(a,b){return this.each(function(){f.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return f.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||f.guid++,d=0,e=function(c){var e=(f._data(this,"lastToggle"+a.guid)||0)%d;f._data(this,"lastToggle"+a.guid,e+1),c.preventDefault();return b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),f.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){f.fn[b]=function(a,c){c==null&&(c=a,a=null);return arguments.length>0?this.on(b,null,a,c):this.trigger(b)},f.attrFn&&(f.attrFn[b]=!0),C.test(b)&&(f.event.fixHooks[b]=f.event.keyHooks),D.test(b)&&(f.event.fixHooks[b]=f.event.mouseHooks)}),function(){function x(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}if(j.nodeType===1){g||(j[d]=c,j.sizset=h);if(typeof b!="string"){if(j===b){k=!0;break}}else if(m.filter(b,[j]).length>0){k=j;break}}j=j[a]}e[h]=k}}}function w(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}j.nodeType===1&&!g&&(j[d]=c,j.sizset=h);if(j.nodeName.toLowerCase()===b){k=j;break}j=j[a]}e[h]=k}}}var a=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,d="sizcache"+(Math.random()+"").replace(".",""),e=0,g=Object.prototype.toString,h=!1,i=!0,j=/\\/g,k=/\r\n/g,l=/\W/;[0,0].sort(function(){i=!1;return 0});var m=function(b,d,e,f){e=e||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!="string")return e;var i,j,k,l,n,q,r,t,u=!0,v=m.isXML(d),w=[],x=b;do{a.exec(""),i=a.exec(x);if(i){x=i[3],w.push(i[1]);if(i[2]){l=i[3];break}}}while(i);if(w.length>1&&p.exec(b))if(w.length===2&&o.relative[w[0]])j=y(w[0]+w[1],d,f);else{j=o.relative[w[0]]?[d]:m(w.shift(),d);while(w.length)b=w.shift(),o.relative[b]&&(b+=w.shift()),j=y(b,j,f)}else{!f&&w.length>1&&d.nodeType===9&&!v&&o.match.ID.test(w[0])&&!o.match.ID.test(w[w.length-1])&&(n=m.find(w.shift(),d,v),d=n.expr?m.filter(n.expr,n.set)[0]:n.set[0]);if(d){n=f?{expr:w.pop(),set:s(f)}:m.find(w.pop(),w.length===1&&(w[0]==="~"||w[0]==="+")&&d.parentNode?d.parentNode:d,v),j=n.expr?m.filter(n.expr,n.set):n.set,w.length>0?k=s(j):u=!1;while(w.length)q=w.pop(),r=q,o.relative[q]?r=w.pop():q="",r==null&&(r=d),o.relative[q](k,r,v)}else k=w=[]}k||(k=j),k||m.error(q||b);if(g.call(k)==="[object Array]")if(!u)e.push.apply(e,k);else if(d&&d.nodeType===1)for(t=0;k[t]!=null;t++)k[t]&&(k[t]===!0||k[t].nodeType===1&&m.contains(d,k[t]))&&e.push(j[t]);else for(t=0;k[t]!=null;t++)k[t]&&k[t].nodeType===1&&e.push(j[t]);else s(k,e);l&&(m(l,h,e,f),m.uniqueSort(e));return e};m.uniqueSort=function(a){if(u){h=i,a.sort(u);if(h)for(var b=1;b<a.length;b++)a[b]===a[b-1]&&a.splice(b--,1)}return a},m.matches=function(a,b){return m(a,null,null,b)},m.matchesSelector=function(a,b){return m(b,null,null,[a]).length>0},m.find=function(a,b,c){var d,e,f,g,h,i;if(!a)return[];for(e=0,f=o.order.length;e<f;e++){h=o.order[e];if(g=o.leftMatch[h].exec(a)){i=g[1],g.splice(1,1);if(i.substr(i.length-1)!=="\\"){g[1]=(g[1]||"").replace(j,""),d=o.find[h](g,b,c);if(d!=null){a=a.replace(o.match[h],"");break}}}}d||(d=typeof b.getElementsByTagName!="undefined"?b.getElementsByTagName("*"):[]);return{set:d,expr:a}},m.filter=function(a,c,d,e){var f,g,h,i,j,k,l,n,p,q=a,r=[],s=c,t=c&&c[0]&&m.isXML(c[0]);while(a&&c.length){for(h in o.filter)if((f=o.leftMatch[h].exec(a))!=null&&f[2]){k=o.filter[h],l=f[1],g=!1,f.splice(1,1);if(l.substr(l.length-1)==="\\")continue;s===r&&(r=[]);if(o.preFilter[h]){f=o.preFilter[h](f,s,d,r,e,t);if(!f)g=i=!0;else if(f===!0)continue}if(f)for(n=0;(j=s[n])!=null;n++)j&&(i=k(j,f,n,s),p=e^i,d&&i!=null?p?g=!0:s[n]=!1:p&&(r.push(j),g=!0));if(i!==b){d||(s=r),a=a.replace(o.match[h],"");if(!g)return[];break}}if(a===q)if(g==null)m.error(a);else break;q=a}return s},m.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)};var n=m.getText=function(a){var b,c,d=a.nodeType,e="";if(d){if(d===1||d===9){if(typeof a.textContent=="string")return a.textContent;if(typeof a.innerText=="string")return a.innerText.replace(k,"");for(a=a.firstChild;a;a=a.nextSibling)e+=n(a)}else if(d===3||d===4)return a.nodeValue}else for(b=0;c=a[b];b++)c.nodeType!==8&&(e+=n(c));return e},o=m.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(a){return a.getAttribute("href")},type:function(a){return a.getAttribute("type")}},relative:{"+":function(a,b){var c=typeof b=="string",d=c&&!l.test(b),e=c&&!d;d&&(b=b.toLowerCase());for(var f=0,g=a.length,h;f<g;f++)if(h=a[f]){while((h=h.previousSibling)&&h.nodeType!==1);a[f]=e||h&&h.nodeName.toLowerCase()===b?h||!1:h===b}e&&m.filter(b,a,!0)},">":function(a,b){var c,d=typeof b=="string",e=0,f=a.length;if(d&&!l.test(b)){b=b.toLowerCase();for(;e<f;e++){c=a[e];if(c){var g=c.parentNode;a[e]=g.nodeName.toLowerCase()===b?g:!1}}}else{for(;e<f;e++)c=a[e],c&&(a[e]=d?c.parentNode:c.parentNode===b);d&&m.filter(b,a,!0)}},"":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("parentNode",b,f,a,d,c)},"~":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("previousSibling",b,f,a,d,c)}},find:{ID:function(a,b,c){if(typeof b.getElementById!="undefined"&&!c){var d=b.getElementById(a[1]);return d&&d.parentNode?[d]:[]}},NAME:function(a,b){if(typeof b.getElementsByName!="undefined"){var c=[],d=b.getElementsByName(a[1]);for(var e=0,f=d.length;e<f;e++)d[e].getAttribute("name")===a[1]&&c.push(d[e]);return c.length===0?null:c}},TAG:function(a,b){if(typeof b.getElementsByTagName!="undefined")return b.getElementsByTagName(a[1])}},preFilter:{CLASS:function(a,b,c,d,e,f){a=" "+a[1].replace(j,"")+" ";if(f)return a;for(var g=0,h;(h=b[g])!=null;g++)h&&(e^(h.className&&(" "+h.className+" ").replace(/[\t\n\r]/g," ").indexOf(a)>=0)?c||d.push(h):c&&(b[g]=!1));return!1},ID:function(a){return a[1].replace(j,"")},TAG:function(a,b){return a[1].replace(j,"").toLowerCase()},CHILD:function(a){if(a[1]==="nth"){a[2]||m.error(a[0]),a[2]=a[2].replace(/^\+|\s*/g,"");var b=/(-?)(\d*)(?:n([+\-]?\d*))?/.exec(a[2]==="even"&&"2n"||a[2]==="odd"&&"2n+1"||!/\D/.test(a[2])&&"0n+"+a[2]||a[2]);a[2]=b[1]+(b[2]||1)-0,a[3]=b[3]-0}else a[2]&&m.error(a[0]);a[0]=e++;return a},ATTR:function(a,b,c,d,e,f){var g=a[1]=a[1].replace(j,"");!f&&o.attrMap[g]&&(a[1]=o.attrMap[g]),a[4]=(a[4]||a[5]||"").replace(j,""),a[2]==="~="&&(a[4]=" "+a[4]+" ");return a},PSEUDO:function(b,c,d,e,f){if(b[1]==="not")if((a.exec(b[3])||"").length>1||/^\w/.test(b[3]))b[3]=m(b[3],null,null,c);else{var g=m.filter(b[3],c,d,!0^f);d||e.push.apply(e,g);return!1}else if(o.match.POS.test(b[0])||o.match.CHILD.test(b[0]))return!0;return b},POS:function(a){a.unshift(!0);return a}},filters:{enabled:function(a){return a.disabled===!1&&a.type!=="hidden"},disabled:function(a){return a.disabled===!0},checked:function(a){return a.checked===!0},selected:function(a){a.parentNode&&a.parentNode.selectedIndex;return a.selected===!0},parent:function(a){return!!a.firstChild},empty:function(a){return!a.firstChild},has:function(a,b,c){return!!m(c[3],a).length},header:function(a){return/h\d/i.test(a.nodeName)},text:function(a){var b=a.getAttribute("type"),c=a.type;return a.nodeName.toLowerCase()==="input"&&"text"===c&&(b===c||b===null)},radio:function(a){return a.nodeName.toLowerCase()==="input"&&"radio"===a.type},checkbox:function(a){return a.nodeName.toLowerCase()==="input"&&"checkbox"===a.type},file:function(a){return a.nodeName.toLowerCase()==="input"&&"file"===a.type},password:function(a){return a.nodeName.toLowerCase()==="input"&&"password"===a.type},submit:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"submit"===a.type},image:function(a){return a.nodeName.toLowerCase()==="input"&&"image"===a.type},reset:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"reset"===a.type},button:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&"button"===a.type||b==="button"},input:function(a){return/input|select|textarea|button/i.test(a.nodeName)},focus:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b){return b===0},last:function(a,b,c,d){return b===d.length-1},even:function(a,b){return b%2===0},odd:function(a,b){return b%2===1},lt:function(a,b,c){return b<c[3]-0},gt:function(a,b,c){return b>c[3]-0},nth:function(a,b,c){return c[3]-0===b},eq:function(a,b,c){return c[3]-0===b}},filter:{PSEUDO:function(a,b,c,d){var e=b[1],f=o.filters[e];if(f)return f(a,c,b,d);if(e==="contains")return(a.textContent||a.innerText||n([a])||"").indexOf(b[3])>=0;if(e==="not"){var g=b[3];for(var h=0,i=g.length;h<i;h++)if(g[h]===a)return!1;return!0}m.error(e)},CHILD:function(a,b){var c,e,f,g,h,i,j,k=b[1],l=a;switch(k){case"only":case"first":while(l=l.previousSibling)if(l.nodeType===1)return!1;if(k==="first")return!0;l=a;case"last":while(l=l.nextSibling)if(l.nodeType===1)return!1;return!0;case"nth":c=b[2],e=b[3];if(c===1&&e===0)return!0;f=b[0],g=a.parentNode;if(g&&(g[d]!==f||!a.nodeIndex)){i=0;for(l=g.firstChild;l;l=l.nextSibling)l.nodeType===1&&(l.nodeIndex=++i);g[d]=f}j=a.nodeIndex-e;return c===0?j===0:j%c===0&&j/c>=0}},ID:function(a,b){return a.nodeType===1&&a.getAttribute("id")===b},TAG:function(a,b){return b==="*"&&a.nodeType===1||!!a.nodeName&&a.nodeName.toLowerCase()===b},CLASS:function(a,b){return(" "+(a.className||a.getAttribute("class"))+" ").indexOf(b)>-1},ATTR:function(a,b){var c=b[1],d=m.attr?m.attr(a,c):o.attrHandle[c]?o.attrHandle[c](a):a[c]!=null?a[c]:a.getAttribute(c),e=d+"",f=b[2],g=b[4];return d==null?f==="!=":!f&&m.attr?d!=null:f==="="?e===g:f==="*="?e.indexOf(g)>=0:f==="~="?(" "+e+" ").indexOf(g)>=0:g?f==="!="?e!==g:f==="^="?e.indexOf(g)===0:f==="$="?e.substr(e.length-g.length)===g:f==="|="?e===g||e.substr(0,g.length+1)===g+"-":!1:e&&d!==!1},POS:function(a,b,c,d){var e=b[2],f=o.setFilters[e];if(f)return f(a,c,b,d)}}},p=o.match.POS,q=function(a,b){return"\\"+(b-0+1)};for(var r in o.match)o.match[r]=new RegExp(o.match[r].source+/(?![^\[]*\])(?![^\(]*\))/.source),o.leftMatch[r]=new RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[r].source.replace(/\\(\d+)/g,q));var s=function(a,b){a=Array.prototype.slice.call(a,0);if(b){b.push.apply(b,a);return b}return a};try{Array.prototype.slice.call(c.documentElement.childNodes,0)[0].nodeType}catch(t){s=function(a,b){var c=0,d=b||[];if(g.call(a)==="[object Array]")Array.prototype.push.apply(d,a);else if(typeof a.length=="number")for(var e=a.length;c<e;c++)d.push(a[c]);else for(;a[c];c++)d.push(a[c]);return d}}var u,v;c.documentElement.compareDocumentPosition?u=function(a,b){if(a===b){h=!0;return 0}if(!a.compareDocumentPosition||!b.compareDocumentPosition)return a.compareDocumentPosition?-1:1;return a.compareDocumentPosition(b)&4?-1:1}:(u=function(a,b){if(a===b){h=!0;return 0}if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],g=a.parentNode,i=b.parentNode,j=g;if(g===i)return v(a,b);if(!g)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)f.unshift(j),j=j.parentNode;c=e.length,d=f.length;for(var k=0;k<c&&k<d;k++)if(e[k]!==f[k])return v(e[k],f[k]);return k===c?v(a,f[k],-1):v(e[k],b,1)},v=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),function(){var a=c.createElement("div"),d="script"+(new Date).getTime(),e=c.documentElement;a.innerHTML="<a name='"+d+"'/>",e.insertBefore(a,e.firstChild),c.getElementById(d)&&(o.find.ID=function(a,c,d){if(typeof c.getElementById!="undefined"&&!d){var e=c.getElementById(a[1]);return e?e.id===a[1]||typeof e.getAttributeNode!="undefined"&&e.getAttributeNode("id").nodeValue===a[1]?[e]:b:[]}},o.filter.ID=function(a,b){var c=typeof a.getAttributeNode!="undefined"&&a.getAttributeNode("id");return a.nodeType===1&&c&&c.nodeValue===b}),e.removeChild(a),e=a=null}(),function(){var a=c.createElement("div");a.appendChild(c.createComment("")),a.getElementsByTagName("*").length>0&&(o.find.TAG=function(a,b){var c=b.getElementsByTagName(a[1]);if(a[1]==="*"){var d=[];for(var e=0;c[e];e++)c[e].nodeType===1&&d.push(c[e]);c=d}return c}),a.innerHTML="<a href='#'></a>",a.firstChild&&typeof a.firstChild.getAttribute!="undefined"&&a.firstChild.getAttribute("href")!=="#"&&(o.attrHandle.href=function(a){return a.getAttribute("href",2)}),a=null}(),c.querySelectorAll&&function(){var a=m,b=c.createElement("div"),d="__sizzle__";b.innerHTML="<p class='TEST'></p>";if(!b.querySelectorAll||b.querySelectorAll(".TEST").length!==0){m=function(b,e,f,g){e=e||c;if(!g&&!m.isXML(e)){var h=/^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(b);if(h&&(e.nodeType===1||e.nodeType===9)){if(h[1])return s(e.getElementsByTagName(b),f);if(h[2]&&o.find.CLASS&&e.getElementsByClassName)return s(e.getElementsByClassName(h[2]),f)}if(e.nodeType===9){if(b==="body"&&e.body)return s([e.body],f);if(h&&h[3]){var i=e.getElementById(h[3]);if(!i||!i.parentNode)return s([],f);if(i.id===h[3])return s([i],f)}try{return s(e.querySelectorAll(b),f)}catch(j){}}else if(e.nodeType===1&&e.nodeName.toLowerCase()!=="object"){var k=e,l=e.getAttribute("id"),n=l||d,p=e.parentNode,q=/^\s*[+~]/.test(b);l?n=n.replace(/'/g,"\\$&"):e.setAttribute("id",n),q&&p&&(e=e.parentNode);try{if(!q||p)return s(e.querySelectorAll("[id='"+n+"'] "+b),f)}catch(r){}finally{l||k.removeAttribute("id")}}}return a(b,e,f,g)};for(var e in a)m[e]=a[e];b=null}}(),function(){var a=c.documentElement,b=a.matchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.msMatchesSelector;if(b){var d=!b.call(c.createElement("div"),"div"),e=!1;try{b.call(c.documentElement,"[test!='']:sizzle")}catch(f){e=!0}m.matchesSelector=function(a,c){c=c.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!m.isXML(a))try{if(e||!o.match.PSEUDO.test(c)&&!/!=/.test(c)){var f=b.call(a,c);if(f||!d||a.document&&a.document.nodeType!==11)return f}}catch(g){}return m(c,null,null,[a]).length>0}}}(),function(){var a=c.createElement("div");a.innerHTML="<div class='test e'></div><div class='test'></div>";if(!!a.getElementsByClassName&&a.getElementsByClassName("e").length!==0){a.lastChild.className="e";if(a.getElementsByClassName("e").length===1)return;o.order.splice(1,0,"CLASS"),o.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!="undefined"&&!c)return b.getElementsByClassName(a[1])},a=null}}(),c.documentElement.contains?m.contains=function(a,b){return a!==b&&(a.contains?a.contains(b):!0)}:c.documentElement.compareDocumentPosition?m.contains=function(a,b){return!!(a.compareDocumentPosition(b)&16)}:m.contains=function(){return!1},m.isXML=function(a){var b=(a?a.ownerDocument||a:0).documentElement;return b?b.nodeName!=="HTML":!1};var y=function(a,b,c){var d,e=[],f="",g=b.nodeType?[b]:b;while(d=o.match.PSEUDO.exec(a))f+=d[0],a=a.replace(o.match.PSEUDO,"");a=o.relative[a]?a+"*":a;for(var h=0,i=g.length;h<i;h++)m(a,g[h],e,c);return m.filter(f,e)};m.attr=f.attr,m.selectors.attrMap={},f.find=m,f.expr=m.selectors,f.expr[":"]=f.expr.filters,f.unique=m.uniqueSort,f.text=m.getText,f.isXMLDoc=m.isXML,f.contains=m.contains}();var L=/Until$/,M=/^(?:parents|prevUntil|prevAll)/,N=/,/,O=/^.[^:#\[\.,]*$/,P=Array.prototype.slice,Q=f.expr.match.POS,R={children:!0,contents:!0,next:!0,prev:!0};f.fn.extend({find:function(a){var b=this,c,d;if(typeof a!="string")return f(a).filter(function(){for(c=0,d=b.length;c<d;c++)if(f.contains(b[c],this))return!0});var e=this.pushStack("","find",a),g,h,i;for(c=0,d=this.length;c<d;c++){g=e.length,f.find(a,this[c],e);if(c>0)for(h=g;h<e.length;h++)for(i=0;i<g;i++)if(e[i]===e[h]){e.splice(h--,1);break}}return e},has:function(a){var b=f(a);return this.filter(function(){for(var a=0,c=b.length;a<c;a++)if(f.contains(this,b[a]))return!0})},not:function(a){return this.pushStack(T(this,a,!1),"not",a)},filter:function(a){return this.pushStack(T(this,a,!0),"filter",a)},is:function(a){return!!a&&(typeof a=="string"?Q.test(a)?f(a,this.context).index(this[0])>=0:f.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c=[],d,e,g=this[0];if(f.isArray(a)){var h=1;while(g&&g.ownerDocument&&g!==b){for(d=0;d<a.length;d++)f(g).is(a[d])&&c.push({selector:a[d],elem:g,level:h});g=g.parentNode,h++}return c}var i=Q.test(a)||typeof a!="string"?f(a,b||this.context):0;for(d=0,e=this.length;d<e;d++){g=this[d];while(g){if(i?i.index(g)>-1:f.find.matchesSelector(g,a)){c.push(g);break}g=g.parentNode;if(!g||!g.ownerDocument||g===b||g.nodeType===11)break}}c=c.length>1?f.unique(c):c;return this.pushStack(c,"closest",a)},index:function(a){if(!a)return this[0]&&this[0].parentNode?this.prevAll().length:-1;if(typeof a=="string")return f.inArray(this[0],f(a));return f.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var c=typeof a=="string"?f(a,b):f.makeArray(a&&a.nodeType?[a]:a),d=f.merge(this.get(),c);return this.pushStack(S(c[0])||S(d[0])?d:f.unique(d))},andSelf:function(){return this.add(this.prevObject)}}),f.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return f.dir(a,"parentNode")},parentsUntil:function(a,b,c){return f.dir(a,"parentNode",c)},next:function(a){return f.nth(a,2,"nextSibling")},prev:function(a){return f.nth(a,2,"previousSibling")},nextAll:function(a){return f.dir(a,"nextSibling")},prevAll:function(a){return f.dir(a,"previousSibling")},nextUntil:function(a,b,c){return f.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return f.dir(a,"previousSibling",c)},siblings:function(a){return f.sibling(a.parentNode.firstChild,a)},children:function(a){return f.sibling(a.firstChild)},contents:function(a){return f.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:f.makeArray(a.childNodes)}},function(a,b){f.fn[a]=function(c,d){var e=f.map(this,b,c);L.test(a)||(d=c),d&&typeof d=="string"&&(e=f.filter(d,e)),e=this.length>1&&!R[a]?f.unique(e):e,(this.length>1||N.test(d))&&M.test(a)&&(e=e.reverse());return this.pushStack(e,a,P.call(arguments).join(","))}}),f.extend({filter:function(a,b,c){c&&(a=":not("+a+")");return b.length===1?f.find.matchesSelector(b[0],a)?[b[0]]:[]:f.find.matches(a,b)},dir:function(a,c,d){var e=[],g=a[c];while(g&&g.nodeType!==9&&(d===b||g.nodeType!==1||!f(g).is(d)))g.nodeType===1&&e.push(g),g=g[c];return e},nth:function(a,b,c,d){b=b||1;var e=0;for(;a;a=a[c])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var V="abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",W=/ jQuery\d+="(?:\d+|null)"/g,X=/^\s+/,Y=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Z=/<([\w:]+)/,$=/<tbody/i,_=/<|&#?\w+;/,ba=/<(?:script|style)/i,bb=/<(?:script|object|embed|option|style)/i,bc=new RegExp("<(?:"+V+")","i"),bd=/checked\s*(?:[^=]|=\s*.checked.)/i,be=/\/(java|ecma)script/i,bf=/^\s*<!(?:\[CDATA\[|\-\-)/,bg={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},bh=U(c);bg.optgroup=bg.option,bg.tbody=bg.tfoot=bg.colgroup=bg.caption=bg.thead,bg.th=bg.td,f.support.htmlSerialize||(bg._default=[1,"div<div>","</div>"]),f.fn.extend({text:function(a){if(f.isFunction(a))return this.each(function(b){var c=f(this);c.text(a.call(this,b,c.text()))});if(typeof a!="object"&&a!==b)return this.empty().append((this[0]&&this[0].ownerDocument||c).createTextNode(a));return f.text(this)},wrapAll:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapAll(a.call(this,b))});if(this[0]){var b=f(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapInner(a.call(this,b))});return this.each(function(){var b=f(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=f.isFunction(a);return this.each(function(c){f(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){f.nodeName(this,"body")||f(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=f.clean(arguments);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,f.clean(arguments));return a}},remove:function(a,b){for(var c=0,d;(d=this[c])!=null;c++)if(!a||f.filter(a,[d]).length)!b&&d.nodeType===1&&(f.cleanData(d.getElementsByTagName("*")),f.cleanData([d])),d.parentNode&&d.parentNode.removeChild(d);return this},empty:function()
{for(var a=0,b;(b=this[a])!=null;a++){b.nodeType===1&&f.cleanData(b.getElementsByTagName("*"));while(b.firstChild)b.removeChild(b.firstChild)}return this},clone:function(a,b){a=a==null?!1:a,b=b==null?a:b;return this.map(function(){return f.clone(this,a,b)})},html:function(a){if(a===b)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(W,""):null;if(typeof a=="string"&&!ba.test(a)&&(f.support.leadingWhitespace||!X.test(a))&&!bg[(Z.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Y,"<$1></$2>");try{for(var c=0,d=this.length;c<d;c++)this[c].nodeType===1&&(f.cleanData(this[c].getElementsByTagName("*")),this[c].innerHTML=a)}catch(e){this.empty().append(a)}}else f.isFunction(a)?this.each(function(b){var c=f(this);c.html(a.call(this,b,c.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(f.isFunction(a))return this.each(function(b){var c=f(this),d=c.html();c.replaceWith(a.call(this,b,d))});typeof a!="string"&&(a=f(a).detach());return this.each(function(){var b=this.nextSibling,c=this.parentNode;f(this).remove(),b?f(b).before(a):f(c).append(a)})}return this.length?this.pushStack(f(f.isFunction(a)?a():a),"replaceWith",a):this},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){var e,g,h,i,j=a[0],k=[];if(!f.support.checkClone&&arguments.length===3&&typeof j=="string"&&bd.test(j))return this.each(function(){f(this).domManip(a,c,d,!0)});if(f.isFunction(j))return this.each(function(e){var g=f(this);a[0]=j.call(this,e,c?g.html():b),g.domManip(a,c,d)});if(this[0]){i=j&&j.parentNode,f.support.parentNode&&i&&i.nodeType===11&&i.childNodes.length===this.length?e={fragment:i}:e=f.buildFragment(a,this,k),h=e.fragment,h.childNodes.length===1?g=h=h.firstChild:g=h.firstChild;if(g){c=c&&f.nodeName(g,"tr");for(var l=0,m=this.length,n=m-1;l<m;l++)d.call(c?bi(this[l],g):this[l],e.cacheable||m>1&&l<n?f.clone(h,!0,!0):h)}k.length&&f.each(k,bp)}return this}}),f.buildFragment=function(a,b,d){var e,g,h,i,j=a[0];b&&b[0]&&(i=b[0].ownerDocument||b[0]),i.createDocumentFragment||(i=c),a.length===1&&typeof j=="string"&&j.length<512&&i===c&&j.charAt(0)==="<"&&!bb.test(j)&&(f.support.checkClone||!bd.test(j))&&(f.support.html5Clone||!bc.test(j))&&(g=!0,h=f.fragments[j],h&&h!==1&&(e=h)),e||(e=i.createDocumentFragment(),f.clean(a,i,e,d)),g&&(f.fragments[j]=h?e:1);return{fragment:e,cacheable:g}},f.fragments={},f.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){f.fn[a]=function(c){var d=[],e=f(c),g=this.length===1&&this[0].parentNode;if(g&&g.nodeType===11&&g.childNodes.length===1&&e.length===1){e[b](this[0]);return this}for(var h=0,i=e.length;h<i;h++){var j=(h>0?this.clone(!0):this).get();f(e[h])[b](j),d=d.concat(j)}return this.pushStack(d,a,e.selector)}}),f.extend({clone:function(a,b,c){var d,e,g,h=f.support.html5Clone||!bc.test("<"+a.nodeName)?a.cloneNode(!0):bo(a);if((!f.support.noCloneEvent||!f.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!f.isXMLDoc(a)){bk(a,h),d=bl(a),e=bl(h);for(g=0;d[g];++g)e[g]&&bk(d[g],e[g])}if(b){bj(a,h);if(c){d=bl(a),e=bl(h);for(g=0;d[g];++g)bj(d[g],e[g])}}d=e=null;return h},clean:function(a,b,d,e){var g;b=b||c,typeof b.createElement=="undefined"&&(b=b.ownerDocument||b[0]&&b[0].ownerDocument||c);var h=[],i;for(var j=0,k;(k=a[j])!=null;j++){typeof k=="number"&&(k+="");if(!k)continue;if(typeof k=="string")if(!_.test(k))k=b.createTextNode(k);else{k=k.replace(Y,"<$1></$2>");var l=(Z.exec(k)||["",""])[1].toLowerCase(),m=bg[l]||bg._default,n=m[0],o=b.createElement("div");b===c?bh.appendChild(o):U(b).appendChild(o),o.innerHTML=m[1]+k+m[2];while(n--)o=o.lastChild;if(!f.support.tbody){var p=$.test(k),q=l==="table"&&!p?o.firstChild&&o.firstChild.childNodes:m[1]==="<table>"&&!p?o.childNodes:[];for(i=q.length-1;i>=0;--i)f.nodeName(q[i],"tbody")&&!q[i].childNodes.length&&q[i].parentNode.removeChild(q[i])}!f.support.leadingWhitespace&&X.test(k)&&o.insertBefore(b.createTextNode(X.exec(k)[0]),o.firstChild),k=o.childNodes}var r;if(!f.support.appendChecked)if(k[0]&&typeof (r=k.length)=="number")for(i=0;i<r;i++)bn(k[i]);else bn(k);k.nodeType?h.push(k):h=f.merge(h,k)}if(d){g=function(a){return!a.type||be.test(a.type)};for(j=0;h[j];j++)if(e&&f.nodeName(h[j],"script")&&(!h[j].type||h[j].type.toLowerCase()==="text/javascript"))e.push(h[j].parentNode?h[j].parentNode.removeChild(h[j]):h[j]);else{if(h[j].nodeType===1){var s=f.grep(h[j].getElementsByTagName("script"),g);h.splice.apply(h,[j+1,0].concat(s))}d.appendChild(h[j])}}return h},cleanData:function(a){var b,c,d=f.cache,e=f.event.special,g=f.support.deleteExpando;for(var h=0,i;(i=a[h])!=null;h++){if(i.nodeName&&f.noData[i.nodeName.toLowerCase()])continue;c=i[f.expando];if(c){b=d[c];if(b&&b.events){for(var j in b.events)e[j]?f.event.remove(i,j):f.removeEvent(i,j,b.handle);b.handle&&(b.handle.elem=null)}g?delete i[f.expando]:i.removeAttribute&&i.removeAttribute(f.expando),delete d[c]}}}});var bq=/alpha\([^)]*\)/i,br=/opacity=([^)]*)/,bs=/([A-Z]|^ms)/g,bt=/^-?\d+(?:px)?$/i,bu=/^-?\d/,bv=/^([\-+])=([\-+.\de]+)/,bw={position:"absolute",visibility:"hidden",display:"block"},bx=["Left","Right"],by=["Top","Bottom"],bz,bA,bB;f.fn.css=function(a,c){if(arguments.length===2&&c===b)return this;return f.access(this,a,c,!0,function(a,c,d){return d!==b?f.style(a,c,d):f.css(a,c)})},f.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=bz(a,"opacity","opacity");return c===""?"1":c}return a.style.opacity}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":f.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,c,d,e){if(!!a&&a.nodeType!==3&&a.nodeType!==8&&!!a.style){var g,h,i=f.camelCase(c),j=a.style,k=f.cssHooks[i];c=f.cssProps[i]||i;if(d===b){if(k&&"get"in k&&(g=k.get(a,!1,e))!==b)return g;return j[c]}h=typeof d,h==="string"&&(g=bv.exec(d))&&(d=+(g[1]+1)*+g[2]+parseFloat(f.css(a,c)),h="number");if(d==null||h==="number"&&isNaN(d))return;h==="number"&&!f.cssNumber[i]&&(d+="px");if(!k||!("set"in k)||(d=k.set(a,d))!==b)try{j[c]=d}catch(l){}}},css:function(a,c,d){var e,g;c=f.camelCase(c),g=f.cssHooks[c],c=f.cssProps[c]||c,c==="cssFloat"&&(c="float");if(g&&"get"in g&&(e=g.get(a,!0,d))!==b)return e;if(bz)return bz(a,c)},swap:function(a,b,c){var d={};for(var e in b)d[e]=a.style[e],a.style[e]=b[e];c.call(a);for(e in b)a.style[e]=d[e]}}),f.curCSS=f.css,f.each(["height","width"],function(a,b){f.cssHooks[b]={get:function(a,c,d){var e;if(c){if(a.offsetWidth!==0)return bC(a,b,d);f.swap(a,bw,function(){e=bC(a,b,d)});return e}},set:function(a,b){if(!bt.test(b))return b;b=parseFloat(b);if(b>=0)return b+"px"}}}),f.support.opacity||(f.cssHooks.opacity={get:function(a,b){return br.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=f.isNumeric(b)?"alpha(opacity="+b*100+")":"",g=d&&d.filter||c.filter||"";c.zoom=1;if(b>=1&&f.trim(g.replace(bq,""))===""){c.removeAttribute("filter");if(d&&!d.filter)return}c.filter=bq.test(g)?g.replace(bq,e):g+" "+e}}),f(function(){f.support.reliableMarginRight||(f.cssHooks.marginRight={get:function(a,b){var c;f.swap(a,{display:"inline-block"},function(){b?c=bz(a,"margin-right","marginRight"):c=a.style.marginRight});return c}})}),c.defaultView&&c.defaultView.getComputedStyle&&(bA=function(a,b){var c,d,e;b=b.replace(bs,"-$1").toLowerCase(),(d=a.ownerDocument.defaultView)&&(e=d.getComputedStyle(a,null))&&(c=e.getPropertyValue(b),c===""&&!f.contains(a.ownerDocument.documentElement,a)&&(c=f.style(a,b)));return c}),c.documentElement.currentStyle&&(bB=function(a,b){var c,d,e,f=a.currentStyle&&a.currentStyle[b],g=a.style;f===null&&g&&(e=g[b])&&(f=e),!bt.test(f)&&bu.test(f)&&(c=g.left,d=a.runtimeStyle&&a.runtimeStyle.left,d&&(a.runtimeStyle.left=a.currentStyle.left),g.left=b==="fontSize"?"1em":f||0,f=g.pixelLeft+"px",g.left=c,d&&(a.runtimeStyle.left=d));return f===""?"auto":f}),bz=bA||bB,f.expr&&f.expr.filters&&(f.expr.filters.hidden=function(a){var b=a.offsetWidth,c=a.offsetHeight;return b===0&&c===0||!f.support.reliableHiddenOffsets&&(a.style&&a.style.display||f.css(a,"display"))==="none"},f.expr.filters.visible=function(a){return!f.expr.filters.hidden(a)});var bD=/%20/g,bE=/\[\]$/,bF=/\r?\n/g,bG=/#.*$/,bH=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,bI=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,bJ=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,bK=/^(?:GET|HEAD)$/,bL=/^\/\//,bM=/\?/,bN=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bO=/^(?:select|textarea)/i,bP=/\s+/,bQ=/([?&])_=[^&]*/,bR=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,bS=f.fn.load,bT={},bU={},bV,bW,bX=["*/"]+["*"];try{bV=e.href}catch(bY){bV=c.createElement("a"),bV.href="",bV=bV.href}bW=bR.exec(bV.toLowerCase())||[],f.fn.extend({load:function(a,c,d){if(typeof a!="string"&&bS)return bS.apply(this,arguments);if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var g=a.slice(e,a.length);a=a.slice(0,e)}var h="GET";c&&(f.isFunction(c)?(d=c,c=b):typeof c=="object"&&(c=f.param(c,f.ajaxSettings.traditional),h="POST"));var i=this;f.ajax({url:a,type:h,dataType:"html",data:c,complete:function(a,b,c){c=a.responseText,a.isResolved()&&(a.done(function(a){c=a}),i.html(g?f("<div>").append(c.replace(bN,"")).find(g):c)),d&&i.each(d,[c,b,a])}});return this},serialize:function(){return f.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?f.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||bO.test(this.nodeName)||bI.test(this.type))}).map(function(a,b){var c=f(this).val();return c==null?null:f.isArray(c)?f.map(c,function(a,c){return{name:b.name,value:a.replace(bF,"\r\n")}}):{name:b.name,value:c.replace(bF,"\r\n")}}).get()}}),f.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){f.fn[b]=function(a){return this.on(b,a)}}),f.each(["get","post"],function(a,c){f[c]=function(a,d,e,g){f.isFunction(d)&&(g=g||e,e=d,d=b);return f.ajax({type:c,url:a,data:d,success:e,dataType:g})}}),f.extend({getScript:function(a,c){return f.get(a,b,c,"script")},getJSON:function(a,b,c){return f.get(a,b,c,"json")},ajaxSetup:function(a,b){b?b_(a,f.ajaxSettings):(b=a,a=f.ajaxSettings),b_(a,b);return a},ajaxSettings:{url:bV,isLocal:bJ.test(bW[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":bX},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":a.String,"text html":!0,"text json":f.parseJSON,"text xml":f.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:bZ(bT),ajaxTransport:bZ(bU),ajax:function(a,c){function w(a,c,l,m){if(s!==2){s=2,q&&clearTimeout(q),p=b,n=m||"",v.readyState=a>0?4:0;var o,r,u,w=c,x=l?cb(d,v,l):b,y,z;if(a>=200&&a<300||a===304){if(d.ifModified){if(y=v.getResponseHeader("Last-Modified"))f.lastModified[k]=y;if(z=v.getResponseHeader("Etag"))f.etag[k]=z}if(a===304)w="notmodified",o=!0;else try{r=cc(d,x),w="success",o=!0}catch(A){w="parsererror",u=A}}else{u=w;if(!w||a)w="error",a<0&&(a=0)}v.status=a,v.statusText=""+(c||w),o?h.resolveWith(e,[r,w,v]):h.rejectWith(e,[v,w,u]),v.statusCode(j),j=b,t&&g.trigger("ajax"+(o?"Success":"Error"),[v,d,o?r:u]),i.fireWith(e,[v,w]),t&&(g.trigger("ajaxComplete",[v,d]),--f.active||f.event.trigger("ajaxStop"))}}typeof a=="object"&&(c=a,a=b),c=c||{};var d=f.ajaxSetup({},c),e=d.context||d,g=e!==d&&(e.nodeType||e instanceof f)?f(e):f.event,h=f.Deferred(),i=f.Callbacks("once memory"),j=d.statusCode||{},k,l={},m={},n,o,p,q,r,s=0,t,u,v={readyState:0,setRequestHeader:function(a,b){if(!s){var c=a.toLowerCase();a=m[c]=m[c]||a,l[a]=b}return this},getAllResponseHeaders:function(){return s===2?n:null},getResponseHeader:function(a){var c;if(s===2){if(!o){o={};while(c=bH.exec(n))o[c[1].toLowerCase()]=c[2]}c=o[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){s||(d.mimeType=a);return this},abort:function(a){a=a||"abort",p&&p.abort(a),w(0,a);return this}};h.promise(v),v.success=v.done,v.error=v.fail,v.complete=i.add,v.statusCode=function(a){if(a){var b;if(s<2)for(b in a)j[b]=[j[b],a[b]];else b=a[v.status],v.then(b,b)}return this},d.url=((a||d.url)+"").replace(bG,"").replace(bL,bW[1]+"//"),d.dataTypes=f.trim(d.dataType||"*").toLowerCase().split(bP),d.crossDomain==null&&(r=bR.exec(d.url.toLowerCase()),d.crossDomain=!(!r||r[1]==bW[1]&&r[2]==bW[2]&&(r[3]||(r[1]==="http:"?80:443))==(bW[3]||(bW[1]==="http:"?80:443)))),d.data&&d.processData&&typeof d.data!="string"&&(d.data=f.param(d.data,d.traditional)),b$(bT,d,c,v);if(s===2)return!1;t=d.global,d.type=d.type.toUpperCase(),d.hasContent=!bK.test(d.type),t&&f.active++===0&&f.event.trigger("ajaxStart");if(!d.hasContent){d.data&&(d.url+=(bM.test(d.url)?"&":"?")+d.data,delete d.data),k=d.url;if(d.cache===!1){var x=f.now(),y=d.url.replace(bQ,"$1_="+x);d.url=y+(y===d.url?(bM.test(d.url)?"&":"?")+"_="+x:"")}}(d.data&&d.hasContent&&d.contentType!==!1||c.contentType)&&v.setRequestHeader("Content-Type",d.contentType),d.ifModified&&(k=k||d.url,f.lastModified[k]&&v.setRequestHeader("If-Modified-Since",f.lastModified[k]),f.etag[k]&&v.setRequestHeader("If-None-Match",f.etag[k])),v.setRequestHeader("Accept",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+(d.dataTypes[0]!=="*"?", "+bX+"; q=0.01":""):d.accepts["*"]);for(u in d.headers)v.setRequestHeader(u,d.headers[u]);if(d.beforeSend&&(d.beforeSend.call(e,v,d)===!1||s===2)){v.abort();return!1}for(u in{success:1,error:1,complete:1})v[u](d[u]);p=b$(bU,d,c,v);if(!p)w(-1,"No Transport");else{v.readyState=1,t&&g.trigger("ajaxSend",[v,d]),d.async&&d.timeout>0&&(q=setTimeout(function(){v.abort("timeout")},d.timeout));try{s=1,p.send(l,w)}catch(z){if(s<2)w(-1,z);else throw z}}return v},param:function(a,c){var d=[],e=function(a,b){b=f.isFunction(b)?b():b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};c===b&&(c=f.ajaxSettings.traditional);if(f.isArray(a)||a.jquery&&!f.isPlainObject(a))f.each(a,function(){e(this.name,this.value)});else for(var g in a)ca(g,a[g],c,e);return d.join("&").replace(bD,"+")}}),f.extend({active:0,lastModified:{},etag:{}});var cd=f.now(),ce=/(\=)\?(&|$)|\?\?/i;f.ajaxSetup({jsonp:"callback",jsonpCallback:function(){return f.expando+"_"+cd++}}),f.ajaxPrefilter("json jsonp",function(b,c,d){var e=b.contentType==="application/x-www-form-urlencoded"&&typeof b.data=="string";if(b.dataTypes[0]==="jsonp"||b.jsonp!==!1&&(ce.test(b.url)||e&&ce.test(b.data))){var g,h=b.jsonpCallback=f.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,i=a[h],j=b.url,k=b.data,l="$1"+h+"$2";b.jsonp!==!1&&(j=j.replace(ce,l),b.url===j&&(e&&(k=k.replace(ce,l)),b.data===k&&(j+=(/\?/.test(j)?"&":"?")+b.jsonp+"="+h))),b.url=j,b.data=k,a[h]=function(a){g=[a]},d.always(function(){a[h]=i,g&&f.isFunction(i)&&a[h](g[0])}),b.converters["script json"]=function(){g||f.error(h+" was not called");return g[0]},b.dataTypes[0]="json";return"script"}}),f.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(a){f.globalEval(a);return a}}}),f.ajaxPrefilter("script",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),f.ajaxTransport("script",function(a){if(a.crossDomain){var d,e=c.head||c.getElementsByTagName("head")[0]||c.documentElement;return{send:function(f,g){d=c.createElement("script"),d.async="async",a.scriptCharset&&(d.charset=a.scriptCharset),d.src=a.url,d.onload=d.onreadystatechange=function(a,c){if(c||!d.readyState||/loaded|complete/.test(d.readyState))d.onload=d.onreadystatechange=null,e&&d.parentNode&&e.removeChild(d),d=b,c||g(200,"success")},e.insertBefore(d,e.firstChild)},abort:function(){d&&d.onload(0,1)}}}});var cf=a.ActiveXObject?function(){for(var a in ch)ch[a](0,1)}:!1,cg=0,ch;f.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&ci()||cj()}:ci,function(a){f.extend(f.support,{ajax:!!a,cors:!!a&&"withCredentials"in a})}(f.ajaxSettings.xhr()),f.support.ajax&&f.ajaxTransport(function(c){if(!c.crossDomain||f.support.cors){var d;return{send:function(e,g){var h=c.xhr(),i,j;c.username?h.open(c.type,c.url,c.async,c.username,c.password):h.open(c.type,c.url,c.async);if(c.xhrFields)for(j in c.xhrFields)h[j]=c.xhrFields[j];c.mimeType&&h.overrideMimeType&&h.overrideMimeType(c.mimeType),!c.crossDomain&&!e["X-Requested-With"]&&(e["X-Requested-With"]="XMLHttpRequest");try{for(j in e)h.setRequestHeader(j,e[j])}catch(k){}h.send(c.hasContent&&c.data||null),d=function(a,e){var j,k,l,m,n;try{if(d&&(e||h.readyState===4)){d=b,i&&(h.onreadystatechange=f.noop,cf&&delete ch[i]);if(e)h.readyState!==4&&h.abort();else{j=h.status,l=h.getAllResponseHeaders(),m={},n=h.responseXML,n&&n.documentElement&&(m.xml=n),m.text=h.responseText;try{k=h.statusText}catch(o){k=""}!j&&c.isLocal&&!c.crossDomain?j=m.text?200:404:j===1223&&(j=204)}}}catch(p){e||g(-1,p)}m&&g(j,k,m,l)},!c.async||h.readyState===4?d():(i=++cg,cf&&(ch||(ch={},f(a).unload(cf)),ch[i]=d),h.onreadystatechange=d)},abort:function(){d&&d(0,1)}}}});var ck={},cl,cm,cn=/^(?:toggle|show|hide)$/,co=/^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,cp,cq=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]],cr;f.fn.extend({show:function(a,b,c){var d,e;if(a||a===0)return this.animate(cu("show",3),a,b,c);for(var g=0,h=this.length;g<h;g++)d=this[g],d.style&&(e=d.style.display,!f._data(d,"olddisplay")&&e==="none"&&(e=d.style.display=""),e===""&&f.css(d,"display")==="none"&&f._data(d,"olddisplay",cv(d.nodeName)));for(g=0;g<h;g++){d=this[g];if(d.style){e=d.style.display;if(e===""||e==="none")d.style.display=f._data(d,"olddisplay")||""}}return this},hide:function(a,b,c){if(a||a===0)return this.animate(cu("hide",3),a,b,c);var d,e,g=0,h=this.length;for(;g<h;g++)d=this[g],d.style&&(e=f.css(d,"display"),e!=="none"&&!f._data(d,"olddisplay")&&f._data(d,"olddisplay",e));for(g=0;g<h;g++)this[g].style&&(this[g].style.display="none");return this},_toggle:f.fn.toggle,toggle:function(a,b,c){var d=typeof a=="boolean";f.isFunction(a)&&f.isFunction(b)?this._toggle.apply(this,arguments):a==null||d?this.each(function(){var b=d?a:f(this).is(":hidden");f(this)[b?"show":"hide"]()}):this.animate(cu("toggle",3),a,b,c);return this},fadeTo:function(a,b,c,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){function g(){e.queue===!1&&f._mark(this);var b=f.extend({},e),c=this.nodeType===1,d=c&&f(this).is(":hidden"),g,h,i,j,k,l,m,n,o;b.animatedProperties={};for(i in a){g=f.camelCase(i),i!==g&&(a[g]=a[i],delete a[i]),h=a[g],f.isArray(h)?(b.animatedProperties[g]=h[1],h=a[g]=h[0]):b.animatedProperties[g]=b.specialEasing&&b.specialEasing[g]||b.easing||"swing";if(h==="hide"&&d||h==="show"&&!d)return b.complete.call(this);c&&(g==="height"||g==="width")&&(b.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY],f.css(this,"display")==="inline"&&f.css(this,"float")==="none"&&(!f.support.inlineBlockNeedsLayout||cv(this.nodeName)==="inline"?this.style.display="inline-block":this.style.zoom=1))}b.overflow!=null&&(this.style.overflow="hidden");for(i in a)j=new f.fx(this,b,i),h=a[i],cn.test(h)?(o=f._data(this,"toggle"+i)||(h==="toggle"?d?"show":"hide":0),o?(f._data(this,"toggle"+i,o==="show"?"hide":"show"),j[o]()):j[h]()):(k=co.exec(h),l=j.cur(),k?(m=parseFloat(k[2]),n=k[3]||(f.cssNumber[i]?"":"px"),n!=="px"&&(f.style(this,i,(m||1)+n),l=(m||1)/j.cur()*l,f.style(this,i,l+n)),k[1]&&(m=(k[1]==="-="?-1:1)*m+l),j.custom(l,m,n)):j.custom(l,h,""));return!0}var e=f.speed(b,c,d);if(f.isEmptyObject(a))return this.each(e.complete,[!1]);a=f.extend({},a);return e.queue===!1?this.each(g):this.queue(e.queue,g)},stop:function(a,c,d){typeof a!="string"&&(d=c,c=a,a=b),c&&a!==!1&&this.queue(a||"fx",[]);return this.each(function(){function h(a,b,c){var e=b[c];f.removeData(a,c,!0),e.stop(d)}var b,c=!1,e=f.timers,g=f._data(this);d||f._unmark(!0,this);if(a==null)for(b in g)g[b]&&g[b].stop&&b.indexOf(".run")===b.length-4&&h(this,g,b);else g[b=a+".run"]&&g[b].stop&&h(this,g,b);for(b=e.length;b--;)e[b].elem===this&&(a==null||e[b].queue===a)&&(d?e[b](!0):e[b].saveState(),c=!0,e.splice(b,1));(!d||!c)&&f.dequeue(this,a)})}}),f.each({slideDown:cu("show",1),slideUp:cu("hide",1),slideToggle:cu("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){f.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),f.extend({speed:function(a,b,c){var d=a&&typeof a=="object"?f.extend({},a):{complete:c||!c&&b||f.isFunction(a)&&a,duration:a,easing:c&&b||b&&!f.isFunction(b)&&b};d.duration=f.fx.off?0:typeof d.duration=="number"?d.duration:d.duration in f.fx.speeds?f.fx.speeds[d.duration]:f.fx.speeds._default;if(d.queue==null||d.queue===!0)d.queue="fx";d.old=d.complete,d.complete=function(a){f.isFunction(d.old)&&d.old.call(this),d.queue?f.dequeue(this,d.queue):a!==!1&&f._unmark(this)};return d},easing:{linear:function(a,b,c,d){return c+d*a},swing:function(a,b,c,d){return(-Math.cos(a*Math.PI)/2+.5)*d+c}},timers:[],fx:function(a,b,c){this.options=b,this.elem=a,this.prop=c,b.orig=b.orig||{}}}),f.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(f.fx.step[this.prop]||f.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a,b=f.css(this.elem,this.prop);return isNaN(a=parseFloat(b))?!b||b==="auto"?0:b:a},custom:function(a,c,d){function h(a){return e.step(a)}var e=this,g=f.fx;this.startTime=cr||cs(),this.end=c,this.now=this.start=a,this.pos=this.state=0,this.unit=d||this.unit||(f.cssNumber[this.prop]?"":"px"),h.queue=this.options.queue,h.elem=this.elem,h.saveState=function(){e.options.hide&&f._data(e.elem,"fxshow"+e.prop)===b&&f._data(e.elem,"fxshow"+e.prop,e.start)},h()&&f.timers.push(h)&&!cp&&(cp=setInterval(g.tick,g.interval))},show:function(){var a=f._data(this.elem,"fxshow"+this.prop);this.options.orig[this.prop]=a||f.style(this.elem,this.prop),this.options.show=!0,a!==b?this.custom(this.cur(),a):this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur()),f(this.elem).show()},hide:function(){this.options.orig[this.prop]=f._data(this.elem,"fxshow"+this.prop)||f.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(a){var b,c,d,e=cr||cs(),g=!0,h=this.elem,i=this.options;if(a||e>=i.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),i.animatedProperties[this.prop]=!0;for(b in i.animatedProperties)i.animatedProperties[b]!==!0&&(g=!1);if(g){i.overflow!=null&&!f.support.shrinkWrapBlocks&&f.each(["","X","Y"],function(a,b){h.style["overflow"+b]=i.overflow[a]}),i.hide&&f(h).hide();if(i.hide||i.show)for(b in i.animatedProperties)f.style(h,b,i.orig[b]),f.removeData(h,"fxshow"+b,!0),f.removeData(h,"toggle"+b,!0);d=i.complete,d&&(i.complete=!1,d.call(h))}return!1}i.duration==Infinity?this.now=e:(c=e-this.startTime,this.state=c/i.duration,this.pos=f.easing[i.animatedProperties[this.prop]](this.state,c,0,1,i.duration),this.now=this.start+(this.end-this.start)*this.pos),this.update();return!0}},f.extend(f.fx,{tick:function(){var a,b=f.timers,c=0;for(;c<b.length;c++)a=b[c],!a()&&b[c]===a&&b.splice(c--,1);b.length||f.fx.stop()},interval:13,stop:function(){clearInterval(cp),cp=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){f.style(a.elem,"opacity",a.now)},_default:function(a){a.elem.style&&a.elem.style[a.prop]!=null?a.elem.style[a.prop]=a.now+a.unit:a.elem[a.prop]=a.now}}}),f.each(["width","height"],function(a,b){f.fx.step[b]=function(a){f.style(a.elem,b,Math.max(0,a.now)+a.unit)}}),f.expr&&f.expr.filters&&(f.expr.filters.animated=function(a){return f.grep(f.timers,function(b){return a===b.elem}).length});var cw=/^t(?:able|d|h)$/i,cx=/^(?:body|html)$/i;"getBoundingClientRect"in c.documentElement?f.fn.offset=function(a){var b=this[0],c;if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);try{c=b.getBoundingClientRect()}catch(d){}var e=b.ownerDocument,g=e.documentElement;if(!c||!f.contains(g,b))return c?{top:c.top,left:c.left}:{top:0,left:0};var h=e.body,i=cy(e),j=g.clientTop||h.clientTop||0,k=g.clientLeft||h.clientLeft||0,l=i.pageYOffset||f.support.boxModel&&g.scrollTop||h.scrollTop,m=i.pageXOffset||f.support.boxModel&&g.scrollLeft||h.scrollLeft,n=c.top+l-j,o=c.left+m-k;return{top:n,left:o}}:f.fn.offset=function(a){var b=this[0];if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);var c,d=b.offsetParent,e=b,g=b.ownerDocument,h=g.documentElement,i=g.body,j=g.defaultView,k=j?j.getComputedStyle(b,null):b.currentStyle,l=b.offsetTop,m=b.offsetLeft;while((b=b.parentNode)&&b!==i&&b!==h){if(f.support.fixedPosition&&k.position==="fixed")break;c=j?j.getComputedStyle(b,null):b.currentStyle,l-=b.scrollTop,m-=b.scrollLeft,b===d&&(l+=b.offsetTop,m+=b.offsetLeft,f.support.doesNotAddBorder&&(!f.support.doesAddBorderForTableAndCells||!cw.test(b.nodeName))&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),e=d,d=b.offsetParent),f.support.subtractsBorderForOverflowNotVisible&&c.overflow!=="visible"&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),k=c}if(k.position==="relative"||k.position==="static")l+=i.offsetTop,m+=i.offsetLeft;f.support.fixedPosition&&k.position==="fixed"&&(l+=Math.max(h.scrollTop,i.scrollTop),m+=Math.max(h.scrollLeft,i.scrollLeft));return{top:l,left:m}},f.offset={bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;f.support.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(f.css(a,"marginTop"))||0,c+=parseFloat(f.css(a,"marginLeft"))||0);return{top:b,left:c}},setOffset:function(a,b,c){var d=f.css(a,"position");d==="static"&&(a.style.position="relative");var e=f(a),g=e.offset(),h=f.css(a,"top"),i=f.css(a,"left"),j=(d==="absolute"||d==="fixed")&&f.inArray("auto",[h,i])>-1,k={},l={},m,n;j?(l=e.position(),m=l.top,n=l.left):(m=parseFloat(h)||0,n=parseFloat(i)||0),f.isFunction(b)&&(b=b.call(a,c,g)),b.top!=null&&(k.top=b.top-g.top+m),b.left!=null&&(k.left=b.left-g.left+n),"using"in b?b.using.call(a,k):e.css(k)}},f.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),c=this.offset(),d=cx.test(b[0].nodeName)?{top:0,left:0}:b.offset();c.top-=parseFloat(f.css(a,"marginTop"))||0,c.left-=parseFloat(f.css(a,"marginLeft"))||0,d.top+=parseFloat(f.css(b[0],"borderTopWidth"))||0,d.left+=parseFloat(f.css(b[0],"borderLeftWidth"))||0;return{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||c.body;while(a&&!cx.test(a.nodeName)&&f.css(a,"position")==="static")a=a.offsetParent;return a})}}),f.each(["Left","Top"],function(a,c){var d="scroll"+c;f.fn[d]=function(c){var e,g;if(c===b){e=this[0];if(!e)return null;g=cy(e);return g?"pageXOffset"in g?g[a?"pageYOffset":"pageXOffset"]:f.support.boxModel&&g.document.documentElement[d]||g.document.body[d]:e[d]}return this.each(function(){g=cy(this),g?g.scrollTo(a?f(g).scrollLeft():c,a?c:f(g).scrollTop()):this[d]=c})}}),f.each(["Height","Width"],function(a,c){var d=c.toLowerCase();f.fn["inner"+c]=function(){var a=this[0];return a?a.style?parseFloat(f.css(a,d,"padding")):this[d]():null},f.fn["outer"+c]=function(a){var b=this[0];return b?b.style?parseFloat(f.css(b,d,a?"margin":"border")):this[d]():null},f.fn[d]=function(a){var e=this[0];if(!e)return a==null?null:this;if(f.isFunction(a))return this.each(function(b){var c=f(this);c[d](a.call(this,b,c[d]()))});if(f.isWindow(e)){var g=e.document.documentElement["client"+c],h=e.document.body;return e.document.compatMode==="CSS1Compat"&&g||h&&h["client"+c]||g}if(e.nodeType===9)return Math.max(e.documentElement["client"+c],e.body["scroll"+c],e.documentElement["scroll"+c],e.body["offset"+c],e.documentElement["offset"+c]);if(a===b){var i=f.css(e,d),j=parseFloat(i);return f.isNumeric(j)?j:i}return this.css(d,typeof a=="string"?a:a+"px")}}),a.jQuery=a.$=f,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return f})})(window);
</script><script type="text/javascript">//XRegExp 1.5.0 <xregexp.com> MIT License
var XRegExp;if(XRegExp){throw Error("can't load XRegExp twice in the same frame")}(function(){XRegExp=function(w,r){var q=[],u=XRegExp.OUTSIDE_CLASS,x=0,p,s,v,t,y;if(XRegExp.isRegExp(w)){if(r!==undefined){throw TypeError("can't supply flags when constructing one RegExp from another")}return j(w)}if(g){throw Error("can't call the XRegExp constructor within token definition functions")}r=r||"";p={hasNamedCapture:false,captureNames:[],hasFlag:function(z){return r.indexOf(z)>-1},setFlag:function(z){r+=z}};while(x<w.length){s=o(w,x,u,p);if(s){q.push(s.output);x+=(s.match[0].length||1)}else{if(v=m.exec.call(i[u],w.slice(x))){q.push(v[0]);x+=v[0].length}else{t=w.charAt(x);if(t==="["){u=XRegExp.INSIDE_CLASS}else{if(t==="]"){u=XRegExp.OUTSIDE_CLASS}}q.push(t);x++}}}y=RegExp(q.join(""),m.replace.call(r,h,""));y._xregexp={source:w,captureNames:p.hasNamedCapture?p.captureNames:null};return y};XRegExp.version="1.5.0";XRegExp.INSIDE_CLASS=1;XRegExp.OUTSIDE_CLASS=2;var c=/\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,h=/[^gimy]+|([\s\S])(?=[\s\S]*\1)/g,n=/^(?:[?*+]|{\d+(?:,\d*)?})\??/,g=false,k=[],m={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},a=m.exec.call(/()??/,"")[1]===undefined,e=function(){var p=/^/g;m.test.call(p,"");return !p.lastIndex}(),f=function(){var p=/x/g;m.replace.call("x",p,"");return !p.lastIndex}(),b=RegExp.prototype.sticky!==undefined,i={};i[XRegExp.INSIDE_CLASS]=/^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;i[XRegExp.OUTSIDE_CLASS]=/^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;XRegExp.addToken=function(s,r,q,p){k.push({pattern:j(s,"g"+(b?"y":"")),handler:r,scope:q||XRegExp.OUTSIDE_CLASS,trigger:p||null})};XRegExp.cache=function(r,p){var q=r+"/"+(p||"");return XRegExp.cache[q]||(XRegExp.cache[q]=XRegExp(r,p))};XRegExp.copyAsGlobal=function(p){return j(p,"g")};XRegExp.escape=function(p){return p.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")};XRegExp.execAt=function(s,r,t,q){r=j(r,"g"+((q&&b)?"y":""));r.lastIndex=t=t||0;var p=r.exec(s);if(q){return(p&&p.index===t)?p:null}else{return p}};XRegExp.freezeTokens=function(){XRegExp.addToken=function(){throw Error("can't run addToken after freezeTokens")}};XRegExp.isRegExp=function(p){return Object.prototype.toString.call(p)==="[object RegExp]"};XRegExp.iterate=function(u,p,v,s){var t=j(p,"g"),r=-1,q;while(q=t.exec(u)){v.call(s,q,++r,u,t);if(t.lastIndex===q.index){t.lastIndex++}}if(p.global){p.lastIndex=0}};XRegExp.matchChain=function(q,p){return function r(s,x){var v=p[x].regex?p[x]:{regex:p[x]},u=j(v.regex,"g"),w=[],t;for(t=0;t<s.length;t++){XRegExp.iterate(s[t],u,function(y){w.push(v.backref?(y[v.backref]||""):y[0])})}return((x===p.length-1)||!w.length)?w:r(w,x+1)}([q],0)};RegExp.prototype.apply=function(q,p){return this.exec(p[0])};RegExp.prototype.call=function(p,q){return this.exec(q)};RegExp.prototype.exec=function(t){var r=m.exec.apply(this,arguments),q,p;if(r){if(!a&&r.length>1&&l(r,"")>-1){p=RegExp(this.source,m.replace.call(d(this),"g",""));m.replace.call(t.slice(r.index),p,function(){for(var u=1;u<arguments.length-2;u++){if(arguments[u]===undefined){r[u]=undefined}}})}if(this._xregexp&&this._xregexp.captureNames){for(var s=1;s<r.length;s++){q=this._xregexp.captureNames[s-1];if(q){r[q]=r[s]}}}if(!e&&this.global&&!r[0].length&&(this.lastIndex>r.index)){this.lastIndex--}}return r};if(!e){RegExp.prototype.test=function(q){var p=m.exec.call(this,q);if(p&&this.global&&!p[0].length&&(this.lastIndex>p.index)){this.lastIndex--}return !!p}}String.prototype.match=function(q){if(!XRegExp.isRegExp(q)){q=RegExp(q)}if(q.global){var p=m.match.apply(this,arguments);q.lastIndex=0;return p}return q.exec(this)};String.prototype.replace=function(r,s){var t=XRegExp.isRegExp(r),q,p,u;if(t&&typeof s.valueOf()==="string"&&s.indexOf("${")===-1&&f){return m.replace.apply(this,arguments)}if(!t){r=r+""}else{if(r._xregexp){q=r._xregexp.captureNames}}if(typeof s==="function"){p=m.replace.call(this,r,function(){if(q){arguments[0]=new String(arguments[0]);for(var v=0;v<q.length;v++){if(q[v]){arguments[0][q[v]]=arguments[v+1]}}}if(t&&r.global){r.lastIndex=arguments[arguments.length-2]+arguments[0].length}return s.apply(null,arguments)})}else{u=this+"";p=m.replace.call(u,r,function(){var v=arguments;return m.replace.call(s,c,function(x,w,A){if(w){switch(w){case"$":return"$";case"&":return v[0];case"`":return v[v.length-1].slice(0,v[v.length-2]);case"'":return v[v.length-1].slice(v[v.length-2]+v[0].length);default:var y="";w=+w;if(!w){return x}while(w>v.length-3){y=String.prototype.slice.call(w,-1)+y;w=Math.floor(w/10)}return(w?v[w]||"":"$")+y}}else{var z=+A;if(z<=v.length-3){return v[z]}z=q?l(q,A):-1;return z>-1?v[z+1]:x}})})}if(t&&r.global){r.lastIndex=0}return p};String.prototype.split=function(u,p){if(!XRegExp.isRegExp(u)){return m.split.apply(this,arguments)}var w=this+"",r=[],v=0,t,q;if(p===undefined||+p<0){p=Infinity}else{p=Math.floor(+p);if(!p){return[]}}u=XRegExp.copyAsGlobal(u);while(t=u.exec(w)){if(u.lastIndex>v){r.push(w.slice(v,t.index));if(t.length>1&&t.index<w.length){Array.prototype.push.apply(r,t.slice(1))}q=t[0].length;v=u.lastIndex;if(r.length>=p){break}}if(u.lastIndex===t.index){u.lastIndex++}}if(v===w.length){if(!m.test.call(u,"")||q){r.push("")}}else{r.push(w.slice(v))}return r.length>p?r.slice(0,p):r};function j(r,q){if(!XRegExp.isRegExp(r)){throw TypeError("type RegExp expected")}var p=r._xregexp;r=XRegExp(r.source,d(r)+(q||""));if(p){r._xregexp={source:p.source,captureNames:p.captureNames?p.captureNames.slice(0):null}}return r}function d(p){return(p.global?"g":"")+(p.ignoreCase?"i":"")+(p.multiline?"m":"")+(p.extended?"x":"")+(p.sticky?"y":"")}function o(v,u,w,p){var r=k.length,y,s,x;g=true;try{while(r--){x=k[r];if((w&x.scope)&&(!x.trigger||x.trigger.call(p))){x.pattern.lastIndex=u;s=x.pattern.exec(v);if(s&&s.index===u){y={output:x.handler.call(p,s,w),match:s};break}}}}catch(q){throw q}finally{g=false}return y}function l(s,q,r){if(Array.prototype.indexOf){return s.indexOf(q,r)}for(var p=r||0;p<s.length;p++){if(s[p]===q){return p}}return -1}XRegExp.addToken(/\(\?#[^)]*\)/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"});XRegExp.addToken(/\((?!\?)/,function(){this.captureNames.push(null);return"("});XRegExp.addToken(/\(\?<([$\w]+)>/,function(p){this.captureNames.push(p[1]);this.hasNamedCapture=true;return"("});XRegExp.addToken(/\\k<([\w$]+)>/,function(q){var p=l(this.captureNames,q[1]);return p>-1?"\\"+(p+1)+(isNaN(q.input.charAt(q.index+q[0].length))?"":"(?:)"):q[0]});XRegExp.addToken(/\[\^?]/,function(p){return p[0]==="[]"?"\\b\\B":"[\\s\\S]"});XRegExp.addToken(/^\(\?([imsx]+)\)/,function(p){this.setFlag(p[1]);return""});XRegExp.addToken(/(?:\s+|#.*)+/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("x")});XRegExp.addToken(/\./,function(){return"[\\s\\S]"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("s")})})();
</script><script type="text/javascript">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
//
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
var SyntaxHighlighter = function() { 

// CommonJS
if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')
{
	XRegExp = require('XRegExp').XRegExp;
}

// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : '',
		
		/** First line number. */
		'first-line' : 1,
		
		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : false,
		
		/** Lines to highlight. */
		'highlight' : null,
		
		/** Title to be displayed above the code block. */
		'title' : null,
		
		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
		
		/** Gets or sets tab size. */
		'tab-size' : 4,
		
		/** Enables or disables gutter. */
		'gutter' : true,
		
		/** Enables or disables toolbar. */
		'toolbar' : true,
		
		/** Enables quick code copy and paste from double click. */
		'quick-code' : true,
		
		/** Forces code view to be collapsed. */
		'collapse' : false,
		
		/** Enables or disables automatic links. */
		'auto-links' : true,
		
		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,
		
		'html-script' : false
	},
	
	config : {
		space : '&nbsp;',
		
		/** Enables use of <SCRIPT type="syntaxhighlighter" /> tags. */
		useScriptTags : true,
		
		/** Blogger mode flag. */
		bloggerMode : false,
		
		stripBrs : false,
		
		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
		
		strings : {
			expandSource : 'expand source',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
			
			// this is populated by the build script
			aboutDialog : '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>About SyntaxHighlighter</title></head><body style="font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;"><div style="text-align:center;margin-top:1.5em;"><div style="font-size:xx-large;">SyntaxHighlighter</div><div style="font-size:.75em;margin-bottom:3em;"><div>version 3.0.83 (July 02 2010)</div><div><a href="http://alexgorbatchev.com/SyntaxHighlighter" target="_blank" style="color:#005896">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402" style="color:#005896">donate</a> to <br/>keep development active!</div></div></body></html>'
		}
	},
	
	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		highlighters : {}
	},
	
	/** This object is populated by user included external brush files. */
	brushes : {},

	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /"([^\\"\n]|\\.)*"/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: new XRegExp('"([^\\\\"]|\\\\.)*"', 'gs'),
		multiLineSingleQuotedString	: new XRegExp("'([^\\\\']|\\\\.)*'", 'gs'),
		xmlComments					: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
		url							: /\w+:\/\/[\w-.\/?%&=:@;]*/g,
		
		/** <?= ?> tags. */
		phpScriptTags 				: { left: /(&lt;|<)\?=?/g, right: /\?(&gt;|>)/g },
		
		/** <%= %> tags. */
		aspScriptTags				: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },
		
		scriptScriptTags			: { left: /(&lt;|<)\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi }
	},

	toolbar: {
		/**
		 * Generates HTML markup for the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @return {String} Returns HTML markup.
		 */
		getHtml: function(highlighter)
		{
			var html = '<div class="toolbar">',
				items = sh.toolbar.items,
				list = items.list
				;
			
			function defaultGetHtml(highlighter, name)
			{
				return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);
			};
			
			for (var i = 0; i < list.length; i++)
				html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);
			
			html += '</div>';
			
			return html;
		},
		
		/**
		 * Generates HTML markup for a regular button in the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @param {String} commandName		Command name that would be executed.
		 * @param {String} label			Label text to display.
		 * @return {String}					Returns HTML markup.
		 */
		getButtonHtml: function(highlighter, commandName, label)
		{
			return '<span><a href="#" class="toolbar_item'
				+ ' command_' + commandName
				+ ' ' + commandName
				+ '">' + label + '</a></span>'
				;
		},
		
		/**
		 * Event handler for a toolbar anchor.
		 */
		handler: function(e)
		{
			var target = e.target,
				className = target.className || ''
				;

			function getValue(name)
			{
				var r = new RegExp(name + '_(\\w+)'),
					match = r.exec(className)
					;

				return match ? match[1] : null;
			};
			
			var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),
				commandName = getValue('command')
				;
			
			// execute the toolbar command
			if (highlighter && commandName)
				sh.toolbar.items[commandName].execute(highlighter);

			// disable default A click behaviour
			e.preventDefault();
		},
		
		/** Collection of toolbar items. */
		items : {
			// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.
			list: ['expandSource', 'help'],

			expandSource: {
				getHtml: function(highlighter)
				{
					if (highlighter.getParam('collapse') != true)
						return '';
						
					var title = highlighter.getParam('title');
					return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);
				},
			
				execute: function(highlighter)
				{
					var div = getHighlighterDivById(highlighter.id);
					removeClass(div, 'collapsed');
				}
			},

			/** Command to display the about dialog window. */
			help: {
				execute: function(highlighter)
				{	
					var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),
						doc = wnd.document
						;
					
					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				}
			}
		}
	},

	/**
	 * Finds all elements on the page which should be processes by SyntaxHighlighter.
	 *
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are returned which qualify.
	 *
	 * @return {Array}	Returns list of <code>{ target: DOMElement, params: Object }</code> objects.
	 */
	findElements: function(globalParams, element)
	{
		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			conf = sh.config,
			result = []
			;

		// support for <SCRIPT TYPE="syntaxhighlighter" /> feature
		if (conf.useScriptTags)
			elements = elements.concat(getSyntaxHighlighterScriptTags());

		if (elements.length === 0) 
			return result;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var item = {
				target: elements[i], 
				// local params take precedence over globals
				params: merge(globalParams, parseParams(elements[i].className))
			};

			if (item.params['brush'] == null)
				continue;
				
			result.push(item);
		}
		
		return result;
	},

	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight: function(globalParams, element)
	{
		var elements = this.findElements(globalParams, element),
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;

		if (elements.length === 0) 
			return;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var element = elements[i],
				target = element.target,
				params = element.params,
				brushName = params.brush,
				code
				;

			if (brushName == null)
				continue;

			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = findBrush(brushName);
				
				if (brush)
					highlighter = new brush();
				else
					continue;
			}
			
			code = target[propertyName];
			
			// remove CDATA from <SCRIPT/> tags if it's present
			if (conf.useScriptTags)
				code = stripCData(code);
				
			// Inject title if the attribute is present
			if ((target.title || '') != '')
				params.title = target.title;
				
			params['brush'] = brushName;
			highlighter.init(params);
			element = highlighter.getDiv(code);
			
			// carry over ID
			if ((target.id || '') != '')
				element.id = target.id;
			
			target.parentNode.replaceChild(element, target);
		}
	},

	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all: function(params)
	{
		attachEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh

sh['all']			= sh.all;
sh['highlight']		= sh.highlight;

/**
 * Checks if target DOM elements has specified CSS class.
 * @param {DOMElement} target Target DOM element to check.
 * @param {String} className Name of the CSS class to check for.
 * @return {Boolean} Returns true if class name is present, false otherwise.
 */
function hasClass(target, className)
{
	return target.className.indexOf(className) != -1;
};

/**
 * Adds CSS class name to the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className New CSS class to add.
 */
function addClass(target, className)
{
	if (!hasClass(target, className))
		target.className += ' ' + className;
};

/**
 * Removes CSS class name from the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className CSS class to remove.
 */
function removeClass(target, className)
{
	target.className = target.className.replace(className, '');
};

/**
 * Converts the source to array object. Mostly used for function arguments and 
 * lists returned by getElementsByTagName() which aren't Array objects.
 * @param {List} source Source list.
 * @return {Array} Returns array.
 */
function toArray(source)
{
	var result = [];
	
	for (var i = 0; i < source.length; i++) 
		result.push(source[i]);
		
	return result;
};

/**
 * Splits block of text into lines.
 * @param {String} block Block of text.
 * @return {Array} Returns array of lines.
 */
function splitLines(block)
{
	return block.split('\n');
}

/**
 * Generates HTML ID for the highlighter.
 * @param {String} highlighterId Highlighter ID.
 * @return {String} Returns HTML ID.
 */
function getHighlighterId(id)
{
	var prefix = 'highlighter_';
	return id.indexOf(prefix) == 0 ? id : prefix + id;
};

/**
 * Finds Highlighter instance by ID.
 * @param {String} highlighterId Highlighter ID.
 * @return {Highlighter} Returns instance of the highlighter.
 */
function getHighlighterById(id)
{
	return sh.vars.highlighters[getHighlighterId(id)];
};

/**
 * Finds highlighter's DIV container.
 * @param {String} highlighterId Highlighter ID.
 * @return {Element} Returns highlighter's DIV element.
 */
function getHighlighterDivById(id)
{
	return document.getElementById(getHighlighterId(id));
};

/**
 * Stores highlighter so that getHighlighterById() can do its thing. Each
 * highlighter must call this method to preserve itself.
 * @param {Highilghter} highlighter Highlighter instance.
 */
function storeHighlighter(highlighter)
{
	sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;
};

/**
 * Looks for a child or parent node which has specified classname.
 * Equivalent to jQuery's $(container).find(".className")
 * @param {Element} target Target element.
 * @param {String} search Class name or node name to look for.
 * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
 * @return {Element} Returns found child or parent element on null.
 */
function findElement(target, search, reverse /* optional */)
{
	if (target == null)
		return null;
		
	var nodes			= reverse != true ? target.childNodes : [ target.parentNode ],
		propertyToFind	= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',
		expectedValue,
		found
		;

	expectedValue = propertyToFind != 'nodeName'
		? search.substr(1)
		: search.toUpperCase()
		;
		
	// main return of the found node
	if ((target[propertyToFind] || '').indexOf(expectedValue) != -1)
		return target;
	
	for (var i = 0; nodes && i < nodes.length && found == null; i++)
		found = findElement(nodes[i], search, reverse);
	
	return found;
};

/**
 * Looks for a parent node which has specified classname.
 * This is an alias to <code>findElement(container, className, true)</code>.
 * @param {Element} target Target element.
 * @param {String} className Class name to look for.
 * @return {Element} Returns found parent element on null.
 */
function findParentElement(target, className)
{
	return findElement(target, className, true);
};

/**
 * Finds an index of element in the array.
 * @ignore
 * @param {Object} searchElement
 * @param {Number} fromIndex
 * @return {Number} Returns index of element if found; -1 otherwise.
 */
function indexOf(array, searchElement, fromIndex)
{
	fromIndex = Math.max(fromIndex || 0, 0);

	for (var i = fromIndex; i < array.length; i++)
		if(array[i] == searchElement)
			return i;
	
	return -1;
};

/**
 * Generates a unique element ID.
 */
function guid(prefix)
{
	return (prefix || '') + Math.round(Math.random() * 1000000).toString();
};

/**
 * Merges two objects. Values from obj2 override values in obj1.
 * Function is NOT recursive and works only for one dimensional objects.
 * @param {Object} obj1 First object.
 * @param {Object} obj2 Second object.
 * @return {Object} Returns combination of both objects.
 */
function merge(obj1, obj2)
{
	var result = {}, name;

	for (name in obj1) 
		result[name] = obj1[name];
	
	for (name in obj2) 
		result[name] = obj2[name];
		
	return result;
};

/**
 * Attempts to convert string to boolean.
 * @param {String} value Input string.
 * @return {Boolean} Returns true if input was "true", false if input was "false" and value otherwise.
 */
function toBoolean(value)
{
	var result = { "true" : true, "false" : false }[value];
	return result == null ? value : result;
};

/**
 * Opens up a centered popup window.
 * @param {String} url		URL to open in the window.
 * @param {String} name		Popup name.
 * @param {int} width		Popup width.
 * @param {int} height		Popup height.
 * @param {String} options	window.open() options.
 * @return {Window}			Returns window instance.
 */
function popup(url, name, width, height, options)
{
	var x = (screen.width - width) / 2,
		y = (screen.height - height) / 2
		;
		
	options +=	', left=' + x + 
				', top=' + y +
				', width=' + width +
				', height=' + height
		;
	options = options.replace(/^,/, '');

	var win = window.open(url, name, options);
	win.focus();
	return win;
};

/**
 * Adds event handler to the target object.
 * @param {Object} obj		Target object.
 * @param {String} type		Name of the event.
 * @param {Function} func	Handling function.
 */
function attachEvent(obj, type, func, scope)
{
	function handler(e)
	{
		e = e || window.event;
		
		if (!e.target)
		{
			e.target = e.srcElement;
			e.preventDefault = function()
			{
				this.returnValue = false;
			};
		}
			
		func.call(scope || window, e);
	};
	
	if (obj.attachEvent) 
	{
		obj.attachEvent('on' + type, handler);
	}
	else 
	{
		obj.addEventListener(type, handler, false);
	}
};

/**
 * Displays an alert.
 * @param {String} str String to display.
 */
function alert(str)
{
	window.alert(sh.config.strings.alert + str);
};

/**
 * Finds a brush by its alias.
 *
 * @param {String} alias		Brush alias.
 * @param {Boolean} showAlert	Suppresses the alert if false.
 * @return {Brush}				Returns bursh constructor if found, null otherwise.
 */
function findBrush(alias, showAlert)
{
	var brushes = sh.vars.discoveredBrushes,
		result = null
		;
	
	if (brushes == null) 
	{
		brushes = {};
		
		// Find all brushes
		for (var brush in sh.brushes) 
		{
			var info = sh.brushes[brush],
				aliases = info.aliases
				;
			
			if (aliases == null) 
				continue;
			
			// keep the brush name
			info.brushName = brush.toLowerCase();
			
			for (var i = 0; i < aliases.length; i++) 
				brushes[aliases[i]] = brush;
		}
		
		sh.vars.discoveredBrushes = brushes;
	}
	
	result = sh.brushes[brushes[alias]];

	if (result == null && showAlert != false)
		alert(sh.config.strings.noBrush + alias);
	
	return result;
};

/**
 * Executes a callback on each line and replaces each line with result from the callback.
 * @param {Object} str			Input string.
 * @param {Object} callback		Callback function taking one string argument and returning a string.
 */
function eachLine(str, callback)
{
	var lines = splitLines(str);
	
	for (var i = 0; i < lines.length; i++)
		lines[i] = callback(lines[i], i);
		
	return lines.join('\n');
};

/**
 * This is a special trim which only removes first and last empty lines
 * and doesn't affect valid leading space on the first line.
 * 
 * @param {String} str   Input string
 * @return {String}      Returns string without empty first and last lines.
 */
function trimFirstAndLastLines(str)
{
	return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, '');
};

/**
 * Parses key/value pairs into hash object.
 * 
 * Understands the following formats:
 * - name: word;
 * - name: [word, word];
 * - name: "string";
 * - name: 'string';
 * 
 * For example:
 *   name1: value; name2: [value, value]; name3: 'value'
 *   
 * @param {String} str    Input string.
 * @return {Object}       Returns deserialized object.
 */
function parseParams(str)
{
	var match, 
		result = {},
		arrayRegex = new XRegExp("^\\[(?<values>(.*?))\\]$"),
		regex = new XRegExp(
			"(?<name>[\\w-]+)" +
			"\\s*:\\s*" +
			"(?<value>" +
				"[\\w-%#]+|" +		// word
				"\\[.*?\\]|" +		// [] array
				'".*?"|' +			// "" string
				"'.*?'" +			// '' string
			")\\s*;?",
			"g"
		)
		;

	while ((match = regex.exec(str)) != null) 
	{
		var value = match.value
			.replace(/^['"]|['"]$/g, '') // strip quotes from end of strings
			;
		
		// try to parse array value
		if (value != null && arrayRegex.test(value))
		{
			var m = arrayRegex.exec(value);
			value = m.values.length > 0 ? m.values.split(/\s*,\s*/) : [];
		}
		
		result[match.name] = value;
	}
	
	return result;
};

/**
 * Wraps each line of the string into <code/> tag with given style applied to it.
 * 
 * @param {String} str   Input string.
 * @param {String} css   Style name to apply to the string.
 * @return {String}      Returns input string with each line surrounded by <span/> tag.
 */
function wrapLinesWithCode(str, css)
{
	if (str == null || str.length == 0 || str == '\n') 
		return str;

	str = str.replace(/</g, '&lt;');

	// Replace two or more sequential spaces with &nbsp; leaving last space untouched.
	str = str.replace(/ {2,}/g, function(m)
	{
		var spaces = '';
		
		for (var i = 0; i < m.length - 1; i++)
			spaces += sh.config.space;
		
		return spaces + ' ';
	});

	// Split each line and apply <span class="...">...</span> to them so that
	// leading spaces aren't included.
	if (css != null) 
		str = eachLine(str, function(line)
		{
			if (line.length == 0) 
				return '';
			
			var spaces = '';
			
			line = line.replace(/^(&nbsp;| )+/, function(s)
			{
				spaces = s;
				return '';
			});
			
			if (line.length == 0) 
				return spaces;
			
			return spaces + '<code class="' + css + '">' + line + '</code>';
		});

	return str;
};

/**
 * Pads number with zeros until it's length is the same as given length.
 * 
 * @param {Number} number	Number to pad.
 * @param {Number} length	Max string length with.
 * @return {String}			Returns a string padded with proper amount of '0'.
 */
function padNumber(number, length)
{
	var result = number.toString();
	
	while (result.length < length)
		result = '0' + result;
	
	return result;
};

/**
 * Replaces tabs with spaces.
 * 
 * @param {String} code		Source code.
 * @param {Number} tabSize	Size of the tab.
 * @return {String}			Returns code with all tabs replaces by spaces.
 */
function processTabs(code, tabSize)
{
	var tab = '';
	
	for (var i = 0; i < tabSize; i++)
		tab += ' ';

	return code.replace(/\t/g, tab);
};

/**
 * Replaces tabs with smart spaces.
 * 
 * @param {String} code    Code to fix the tabs in.
 * @param {Number} tabSize Number of spaces in a column.
 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
 */
function processSmartTabs(code, tabSize)
{
	var lines = splitLines(code),
		tab = '\t',
		spaces = ''
		;
	
	// Create a string with 1000 spaces to copy spaces from... 
	// It's assumed that there would be no indentation longer than that.
	for (var i = 0; i < 50; i++) 
		spaces += '                    '; // 20 spaces * 50
			
	// This function inserts specified amount of spaces in the string
	// where a tab is while removing that given tab.
	function insertSpaces(line, pos, count)
	{
		return line.substr(0, pos)
			+ spaces.substr(0, count)
			+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
			;
	};

	// Go through all the lines and do the 'smart tabs' magic.
	code = eachLine(code, function(line)
	{
		if (line.indexOf(tab) == -1) 
			return line;
		
		var pos = 0;
		
		while ((pos = line.indexOf(tab)) != -1) 
		{
			// This is pretty much all there is to the 'smart tabs' logic.
			// Based on the position within the line and size of a tab,
			// calculate the amount of spaces we need to insert.
			var spaces = tabSize - pos % tabSize;
			line = insertSpaces(line, pos, spaces);
		}
		
		return line;
	});
	
	return code;
};

/**
 * Performs various string fixes based on configuration.
 */
function fixInputString(str)
{
	var br = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
	
	if (sh.config.bloggerMode == true)
		str = str.replace(br, '\n');

	if (sh.config.stripBrs == true)
		str = str.replace(br, '');
		
	return str;
};

/**
 * Removes all white space at the begining and end of a string.
 * 
 * @param {String} str   String to trim.
 * @return {String}      Returns string without leading and following white space characters.
 */
function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '');
};

/**
 * Unindents a block of text by the lowest common indent amount.
 * @param {String} str   Text to unindent.
 * @return {String}      Returns unindented text block.
 */
function unindent(str)
{
	var lines = splitLines(fixInputString(str)),
		indents = new Array(),
		regex = /^\s*/,
		min = 1000
		;
	
	// go through every line and check for common number of indents
	for (var i = 0; i < lines.length && min > 0; i++) 
	{
		var line = lines[i];
		
		if (trim(line).length == 0) 
			continue;
		
		var matches = regex.exec(line);
		
		// In the event that just one line doesn't have leading white space
		// we can't unindent anything, so bail completely.
		if (matches == null) 
			return str;
			
		min = Math.min(matches[0].length, min);
	}
	
	// trim minimum common number of white space from the begining of every line
	if (min > 0) 
		for (var i = 0; i < lines.length; i++) 
			lines[i] = lines[i].substr(min);
	
	return lines.join('\n');
};

/**
 * Callback method for Array.sort() which sorts matches by
 * index position and then by length.
 * 
 * @param {Match} m1	Left object.
 * @param {Match} m2    Right object.
 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
 */
function matchesSortCallback(m1, m2)
{
	// sort matches by index first
	if(m1.index < m2.index)
		return -1;
	else if(m1.index > m2.index)
		return 1;
	else
	{
		// if index is the same, sort by length
		if(m1.length < m2.length)
			return -1;
		else if(m1.length > m2.length)
			return 1;
	}
	
	return 0;
};

/**
 * Executes given regular expression on provided code and returns all
 * matches that are found.
 * 
 * @param {String} code    Code to execute regular expression on.
 * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.
 * @return {Array}         Returns a list of Match objects.
 */ 
function getMatches(code, regexInfo)
{
	function defaultAdd(match, regexInfo)
	{
		return match[0];
	};
	
	var index = 0,
		match = null,
		matches = [],
		func = regexInfo.func ? regexInfo.func : defaultAdd
		;
	
	while((match = regexInfo.regex.exec(code)) != null)
	{
		var resultMatch = func(match, regexInfo);
		
		if (typeof(resultMatch) == 'string')
			resultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];

		matches = matches.concat(resultMatch);
	}
	
	return matches;
};

/**
 * Turns all URLs in the code into <a/> tags.
 * @param {String} code Input code.
 * @return {String} Returns code with </a> tags.
 */
function processUrls(code)
{
	var gt = /(.*)((&gt;|&lt;).*)/;
	
	return code.replace(sh.regexLib.url, function(m)
	{
		var suffix = '',
			match = null
			;
		
		// We include &lt; and &gt; in the URL for the common cases like <http://google.com>
		// The problem is that they get transformed into &lt;http://google.com&gt;
		// Where as &gt; easily looks like part of the URL string.
	
		if (match = gt.exec(m))
		{
			m = match[1];
			suffix = match[2];
		}
		
		return '<a href="' + m + '">' + m + '</a>' + suffix;
	});
};

/**
 * Finds all <SCRIPT TYPE="syntaxhighlighter" /> elementss.
 * @return {Array} Returns array of all found SyntaxHighlighter tags.
 */
function getSyntaxHighlighterScriptTags()
{
	var tags = document.getElementsByTagName('script'),
		result = []
		;
	
	for (var i = 0; i < tags.length; i++)
		if (tags[i].type == 'syntaxhighlighter')
			result.push(tags[i]);
			
	return result;
};

/**
 * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used
 * there in most cases for XHTML compliance.
 * @param {String} original	Input code.
 * @return {String} Returns code without leading <![CDATA[]]> tags.
 */
function stripCData(original)
{
	var left = '<![CDATA[',
		right = ']]>',
		// for some reason IE inserts some leading blanks here
		copy = trim(original),
		changed = false,
		leftLength = left.length,
		rightLength = right.length
		;
	
	if (copy.indexOf(left) == 0)
	{
		copy = copy.substring(leftLength);
		changed = true;
	}
	
	var copyLength = copy.length;
	
	if (copy.indexOf(right) == copyLength - rightLength)
	{
		copy = copy.substring(0, copyLength - rightLength);
		changed = true;
	}
	
	return changed ? copy : original;
};


/**
 * Quick code mouse double click handler.
 */
function quickCodeHandler(e)
{
	var target = e.target,
		highlighterDiv = findParentElement(target, '.syntaxhighlighter'),
		container = findParentElement(target, '.container'),
		textarea = document.createElement('textarea'),
		highlighter
		;

	if (!container || !highlighterDiv || findElement(container, 'textarea'))
		return;

	highlighter = getHighlighterById(highlighterDiv.id);
	
	// add source class name
	addClass(highlighterDiv, 'source');

	// Have to go over each line and grab it's text, can't just do it on the
	// container because Firefox loses all \n where as Webkit doesn't.
	var lines = container.childNodes,
		code = []
		;
	
	for (var i = 0; i < lines.length; i++)
		code.push(lines[i].innerText || lines[i].textContent);
	
	// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit
	code = code.join('\r');
	
	// inject <textarea/> tag
	textarea.appendChild(document.createTextNode(code));
	container.appendChild(textarea);
	
	// preselect all text
	textarea.focus();
	textarea.select();
	
	// set up handler for lost focus
	attachEvent(textarea, 'blur', function(e)
	{
		textarea.parentNode.removeChild(textarea);
		removeClass(highlighterDiv, 'source');
	});
};

/**
 * Match object.
 */
sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};

sh.Match.prototype.toString = function()
{
	return this.value;
};

/**
 * Simulates HTML code with a scripting language embedded.
 * 
 * @param {String} scriptBrushName Brush name of the scripting language.
 */
sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null,
		ref = this,
		methodsToExpose = 'getDiv getHtml init'.split(' ')
		;

	if (brushClass == null)
		return;
	
	scriptBrush = new brushClass();
	
	for(var i = 0; i < methodsToExpose.length; i++)
		// make a closure so we don't lose the name after i changes
		(function() {
			var name = methodsToExpose[i];
			
			ref[name] = function()
			{
				return xmlBrush[name].apply(xmlBrush, arguments);
			};
		})();
	
	if (scriptBrush.htmlScript == null)
	{
		alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
	
	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
	
	function offsetMatches(matches, offset)
	{
		for (var j = 0; j < matches.length; j++) 
			matches[j].index += offset;
	}
	
	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;

		// add all matches from the code
		for (var i = 0; i < regexList.length; i++)
		{
			result = getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
		
		// add left script bracket
		if (htmlScript.left != null && match.left != null)
		{
			result = getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
		
		// add right script bracket
		if (htmlScript.right != null && match.right != null)
		{
			result = getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
		
		for (var j = 0; j < matches.length; j++)
			matches[j].brushName = brushClass.brushName;
			
		return matches;
	}
};

/**
 * Main Highlither class.
 * @constructor
 */
sh.Highlighter = function()
{
	// not putting any code in here because of the prototype inheritance
};

sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam: function(name, defaultValue)
	{
		var result = this.params[name];
		return toBoolean(result == null ? defaultValue : result);
	},
	
	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
	
	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
		
		if (regexList != null)
			for (var i = 0; i < regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == "object")
					result = result.concat(getMatches(code, regexList[i]));
		
		// sort and remove nested the matches
		return this.removeNestedMatches(result.sort(matchesSortCallback));
	},
	
	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function(matches)
	{
		// Optimized by Jose Prado (http://joseprado.com)
		for (var i = 0; i < matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
			
			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
			
			for (var j = i + 1; j < matches.length && matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
				
				if (itemJ === null) 
					continue;
				else if (itemJ.index > itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index && itemJ.length > itemI.length)
					matches[i] = null;
				else if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) 
					matches[j] = null;
			}
		}
		
		return matches;
	},
	
	/**
	 * Creates an array containing integer line numbers starting from the 'first-line' param.
	 * @return {Array} Returns array of integers.
	 */
	figureOutLineNumbers: function(code)
	{
		var lines = [],
			firstLine = parseInt(this.getParam('first-line'))
			;
		
		eachLine(code, function(line, index)
		{
			lines.push(index + firstLine);
		});
		
		return lines;
	},
	
	/**
	 * Determines if specified line number is in the highlighted list.
	 */
	isLineHighlighted: function(lineNumber)
	{
		var list = this.getParam('highlight', []);
		
		if (typeof(list) != 'object' && list.push == null) 
			list = [ list ];
		
		return indexOf(list, lineNumber.toString()) != -1;
	},
	
	/**
	 * Generates HTML markup for a single line of code while determining alternating line style.
	 * @param {Integer} lineNumber	Line number.
	 * @param {String} code Line	HTML markup.
	 * @return {String}				Returns HTML markup.
	 */
	getLineHtml: function(lineIndex, lineNumber, code)
	{
		var classes = [
			'line',
			'number' + lineNumber,
			'index' + lineIndex,
			'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()
		];
		
		if (this.isLineHighlighted(lineNumber))
		 	classes.push('highlighted');
		
		if (lineNumber == 0)
			classes.push('break');
			
		return '<div class="' + classes.join(' ') + '">' + code + '</div>';
	},
	
	/**
	 * Generates HTML markup for line number column.
	 * @param {String} code			Complete code HTML markup.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns HTML markup.
	 */
	getLineNumbersHtml: function(code, lineNumbers)
	{
		var html = '',
			count = splitLines(code).length,
			firstLine = parseInt(this.getParam('first-line')),
			pad = this.getParam('pad-line-numbers')
			;
		
		if (pad == true)
			pad = (firstLine + count - 1).toString().length;
		else if (isNaN(pad) == true)
			pad = 0;
			
		for (var i = 0; i < count; i++)
		{
			var lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,
				code = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)
				;
				
			html += this.getLineHtml(i, lineNumber, code);
		}
		
		return html;
	},
	
	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code			Code to highlight.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns highlighted code in HTML form.
	 */
	getCodeLinesHtml: function(html, lineNumbers)
	{
		html = trim(html);
		
		var lines = splitLines(html),
			padLength = this.getParam('pad-line-numbers'),
			firstLine = parseInt(this.getParam('first-line')),
			html = '',
			brushName = this.getParam('brush')
			;

		for (var i = 0; i < lines.length; i++)
		{
			var line = lines[i],
				indent = /^(&nbsp;|\s)+/.exec(line),
				spaces = null,
				lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
				;

			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
				spaces = spaces.replace(' ', sh.config.space);
			}

			line = trim(line);
			
			if (line.length == 0)
				line = sh.config.space;
			
			html += this.getLineHtml(
				i,
				lineNumber, 
				(spaces != null ? '<code class="' + brushName + ' spaces">' + spaces + '</code>' : '') + line
			);
		}
		
		return html;
	},
	
	/**
	 * Returns HTML for the table title or empty string if title is null.
	 */
	getTitleHtml: function(title)
	{
		return title ? '<caption>' + title + '</caption>' : '';
	},
	
	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	getMatchesHtml: function(code, matches)
	{
		var pos = 0, 
			result = '',
			brushName = this.getParam('brush', '')
			;
		
		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : '';
		};
		
		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i < matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
			
			if (match === null || match.length === 0) 
				continue;
			
			matchBrushName = getBrushNameCss(match);
			
			result += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ wrapLinesWithCode(match.value, matchBrushName + match.css)
					;

			pos = match.index + match.length + (match.offset || 0);
		}

		// don't forget to add whatever's remaining in the string
		result += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');

		return result;
	},
	
	/**
	 * Generates HTML markup for the whole syntax highlighter.
	 * @param {String} code Source code.
	 * @return {String} Returns HTML markup.
	 */
	getHtml: function(code)
	{
		var html = '',
			classes = [ 'syntaxhighlighter' ],
			tabSize,
			matches,
			lineNumbers
			;
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;

		className = 'syntaxhighlighter';

		if (this.getParam('collapse') == true)
			classes.push('collapsed');
		
		if ((gutter = this.getParam('gutter')) == false)
			classes.push('nogutter');

		// add custom user style name
		classes.push(this.getParam('class-name'));

		// add brush alias to the class name for custom CSS
		classes.push(this.getParam('brush'));

		code = trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;

		tabSize = this.getParam('tab-size');

		// replace tabs with spaces
		code = this.getParam('smart-tabs') == true
			? processSmartTabs(code, tabSize)
			: processTabs(code, tabSize)
			;

		// unindent code by the common indentation
		code = unindent(code);

		if (gutter)
			lineNumbers = this.figureOutLineNumbers(code);
		
		// find matches in the code using brushes regex list
		matches = this.findMatches(this.regexList, code);
		// processes found matches into the html
		html = this.getMatchesHtml(code, matches);
		// finally, split all lines so that they wrap well
		html = this.getCodeLinesHtml(html, lineNumbers);

		// finally, process the links
		if (this.getParam('auto-links'))
			html = processUrls(html);
		
		if (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))
			classes.push('ie');
		
		html = 
			'<div id="' + getHighlighterId(this.id) + '" class="' + classes.join(' ') + '">'
				+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')
				+ '<table border="0" cellpadding="0" cellspacing="0">'
					+ this.getTitleHtml(this.getParam('title'))
					+ '<tbody>'
						+ '<tr>'
							+ (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(code) + '</td>' : '')
							+ '<td class="code">'
								+ '<div class="container">'
									+ html
								+ '</div>'
							+ '</td>'
						+ '</tr>'
					+ '</tbody>'
				+ '</table>'
			+ '</div>'
			;
			
		return html;
	},
	
	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @return {Element}        Returns container DIV element with all markup.
	 */
	getDiv: function(code)
	{
		if (code === null) 
			code = '';
		
		this.code = code;

		var div = this.create('div');

		// create main HTML
		div.innerHTML = this.getHtml(code);
		
		// set up click handlers
		if (this.getParam('toolbar'))
			attachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);
		
		if (this.getParam('quick-code'))
			attachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);
		
		return div;
	},
	
	/**
	 * Initializes the highlighter/brush.
	 *
	 * Constructor isn't used for initialization so that nothing executes during necessary
	 * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.
	 *
	 * @param {Hash} params Highlighter parameters.
	 */
	init: function(params)
	{
		this.id = guid();
		
		// register this instance in the highlighters list
		storeHighlighter(this);
		
		// local params take precedence over defaults
		this.params = merge(sh.defaults, params || {})
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
	},
	
	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, '')
			.replace(/\s+/g, '|')
			;
		
		return '\\b(?:' + str + ')\\b';
	},
	
	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				"(?<left>" + regexGroup.left.source + ")" +
				"(?<code>.*?)" +
				"(?<right>" + regexGroup.right.source + ")",
				"sgi"
				)
		};
	}
}; // end of Highlighter

return sh;
}(); // end of anonymous function

// CommonJS
typeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;
</script><script type="text/javascript">// (inc clojure-brush) ;; an improved SyntaxHighlighter brush for clojure
//
// Copyright (C) 2011 Andrew Brehaut
//
// Distributed under the Eclipse Public License, the same as Clojure.
//
// https://github.com/brehaut/inc-clojure-brush
//
// Written by Andrew Brehaut
// V0.9.1, November 2011

if (typeof net == "undefined") net = {};
if (!(net.brehaut)) net.brehaut = {};

net.brehaut.ClojureTools = (function (SH) {
  "use strict";
  // utiliies
  if (!Object.create) Object.create = function object(o) {
    function F() {};
    F.prototype = o;  
    return new F();
  };
        
  // data
  
  function Token(value, index, tag, length) {
    this.value = value;
    this.index = index;
    this.length = length || value.length;
    this.tag = tag;
    this.secondary_tags = {};
  }
  
  // null_token exists so that LispNodes that have not had a closing tag attached
  // can have a dummy token to simplify annotation
  var null_token = new Token("", -1, "null", -1);
  
  /* LispNodes are aggregate nodes for sexpressions. 
   *
   */
  function LispNode(tag, children, opening) {
    this.tag = tag;            // current metadata for syntax inference
    this.parent = null;        // the parent expression
    this.list = children;      // all the child forms in order
    this.opening = opening;    // the token that opens this form.
    this.closing = null_token; // the token that closes this form.
    this.meta = null;          // metadata nodes will be attached here if they are found
  }

  var null_lispnode = new LispNode("null", [], null_token);

  
  function PrefixNode(tag, token, attached_node) {
    this.tag = tag;
    this.token = token;
    this.attached_node = attached_node;
    this.parent = null;
  }

  
  
  // tokenize

  function tokenize(code) {
    var tokens = [];
    var tn = 0;
    
    var zero = "0".charCodeAt(0);
    var nine = "9".charCodeAt(0); 
    var lower_a = "a".charCodeAt(0);
    var lower_f = "f".charCodeAt(0);    
    var upper_a = "A".charCodeAt(0);
    var upper_f = "F".charCodeAt(0);
    
    var dispatch = false; // have we just seen a # character?
    
    // i tracks the start of the current window
    // extent is the window for slicing
    
    for (var i = 0, 
             extent = i, 
             j = code.length; 
             i < j && extent <= j;) {          
                
      var c = code[i];
      
      // we care about capturing the whole token when dispatch is used, so back up the
      // starting index by 1
      if (dispatch) i--; 
      
      switch (c) {
        // dispatch alters the value of the next thing read
        case "#":
          dispatch = true;
          i++;
          extent++;
          continue;
          
        case " ":    // ignore whitespace
        case "\t":
        case "\n":
        case "\r":
        case ",":   
          extent++
          break; 
          
        // simple terms
        case "^":
        case "`":
        case ")":
        case "[":
        case "]":
        case "}":
        case "@":
          tokens[tn++] = new Token(c, i, c, ++extent - i);
          break;
        
        case "'":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#'" : "'", extent - i);
          break
        
        case "(":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "(", extent - i);
          break;          
          
        case "{":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#{" : "{", extent - i);
          break;  
        
        case "\\":
          if (code.slice(i + 1, i + 8) === "newline") {
            tokens[tn++] = new Token("\\newline", i, "value", 8);
            extent = i + 9; 
          }
          else if (code.slice(i + 1, i + 6) === "space") {
            tokens[tn++] = new Token("\\space", i, "value", 6);
            extent = i + 6;
          }
          else if (code.slice(i + 1, i + 4) === "tab") {
            tokens[tn++] = new Token("\\tab", i, "value", 4);
            extent = i + 5;
          } // work around fun bug with &,>,< in character literals
          else if (code.slice(i + 1, i + 6) === "&amp;") {
            tokens[tn++] = new Token("\\&amp;", i, "value", 6);
            extent = i + 6; 
          }
          else if (code.slice(i + 1, i + 5) === "&lt;") {
            tokens[tn++] = new Token("\\&lt;", i, "value", 5);
            extent = i + 5;
          }
          else if (code.slice(i + 1, i + 5) === "&gt;") {
            tokens[tn++] = new Token("\\&gt;", i, "value", 5);
            extent = i + 5;
          }
          
          else {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "value", 2);
          }
          break;
        
        case "~": // slice
          if (code[i + 1] === "@") {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "splice", 2);
          }
          else {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "unquote", 2);
          }
          break;
        
        // complicated terms
        case "\"": // strings and regexps
          for (extent++; extent <= j; extent++) {
            if (code[extent] === "\\") extent++;
            else if (code[extent] === "\"") break;
          }
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "regexp" : "string", extent - i);       
          break;
          
        case ";":
          for (; extent <= j && code[extent] !== "\n" && code[extent] !== "\r"; extent++);
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "comments", extent - i);   
          break;
        
        case "+": // numbers; fall through to symbol for + and - not prefixing a number
        case "-":
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        // todo: exponents, hex
        // http://my.safaribooksonline.com/9781449310387/14?reader=pf&readerfullscreen=&readerleftmenu=1
          var c2 = code.charCodeAt(i + 1);
          if (((c === "+" || c === "-") && (c2 >= zero && c2 <= nine)) // prefixes
              || (c !== "+" && c !== "-")) {
            if (c === "+" || c === "-") extent++; 
            for (; extent <= j; extent++) {
              var charCode = code.charCodeAt(extent);
              if (charCode < zero || charCode > nine) break;
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "r" || c === "R" || c === "/" || c === ".") // interstitial characters
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "x" || c === "X") && 
                ((c2 >= zero && c2 <= nine) 
                 || (c2 >= lower_a && c2 <= lower_f)
                 || (c2 >= upper_a && c2 <= upper_f))) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (((charCode >= zero && charCode <= nine) 
                    || (charCode >= lower_a && charCode <= lower_f)
                    || (charCode >= upper_a && charCode <= upper_f))) continue;
                break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "e" || c === "E") 
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            if (c === "N" || c === "M") extent++;

            tokens[tn++] = new Token(code.slice(i, extent), i, "value", extent - i);
            break;
          }

        case "_":
          if (dispatch && c === "_") {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "skip", extent - i);
            break;
          } // if not a skip, fall through to symbols
        
        // Allow just about any other symbol as a symbol. This is far more permissive than 
        // clojure actually allows, but should catch any weirdo crap that accidentally gets
        // into the code.
        default: 
          for (extent++; extent <= j; extent++) {
            switch (code[extent]) {
              case " ":
              case "\t":
              case "\n":
              case "\r":
              case "\\":
              case ",":
              case "{":
              case "}":
              case "(":
              case ")":
              case "[":
              case "]":
              case "^":
              case "`":
              case "@":   
                break;
              case ";":   
                // theres a weird bug via syntax highligher that gives us escaped entities.
                // need to watch out for these
                if (code.slice(extent-3, extent+1) === "&lt;"
                    ||code.slice(extent-3, extent+1) === "&gt;"
                    ||code.slice(extent-4, extent+1) === "&amp;") {
                  continue;
                }
                break;
              default:
                continue;
            }
            break;
          }
          
          var value = code.slice(i, extent);
          var tag = "symbol";
          if (value[0] == ":") {
            tag = "keyword";
          }
          else if (value === "true" || value === "false" || value === "nil") {
            tag = "value";
          }
          tokens[tn++] = new Token(value, i, tag, extent - i);
      }
      
      dispatch = false;
      i = extent;
    } 

    return tokens;
  }


  function build_tree(tokens) {
    var toplevel = {
      list: [], 
      tag: "toplevel", 
      parent: null, 
      opening: null,
      closing: null,
      depth: -1
    };
    
    // loop variables hoisted out as semi globals to track position in token stream
    var i = -1;
    var j = tokens.length;
    
    function parse_one(t) {
      // ignore special tokens and forms that dont belong in the tree
      for (; t && (t.tag === "comments" || t.tag === "invalid" || t.tag == "skip") && i < j; ) {
        if (t.tag === "skip") {
          t.tag = "preprocessor";
          annotate_comment(parse_one(tokens[++i]));
        }
        t = tokens[++i];
      }
      
      if (!t) return {}; // hackity hack
      
      switch (t.tag) {
        case "{":
          return build_aggregate(new LispNode("map", [], t), "}");
        case "(":
          return build_aggregate(new LispNode("list", [], t), ")");
        case "#{":
          return build_aggregate(new LispNode("set", [], t), "}");
        case "[":
          return build_aggregate(new LispNode("vector", [], t), "]");
        case "'":
          return new PrefixNode("quote", t, parse_one(tokens[++i]));
        case "#'":
          return new PrefixNode("varquote", t, parse_one(tokens[++i]));  
        case "@":
          return new PrefixNode("deref", t, parse_one(tokens[++i]));  
        case "`":
          return new PrefixNode("quasiquote", t, parse_one(tokens[++i]));  
        case "unquote":
          return new PrefixNode("unquote", t, parse_one(tokens[++i]));
        case "splice":
          return new PrefixNode("splice", t, parse_one(tokens[++i]));  
        case "^":
          t.tag = "meta";
          var meta = parse_one(tokens[++i]);
          var next = parse_one(tokens[++i]);
          next.meta = meta;
          return next;
      }
      
      return t;
    }
    
    // build_aggregate collects to ether sub forms for one aggregate for. 
    function build_aggregate(current, expected_closing) {
      for (i++; i < j; i++) {
        var t = tokens[i];

        if (t.tag === "}" || t.tag === ")" || t.tag === "]") {
          if (t.tag !== expected_closing) t.tag = "invalid";
          current.closing = t;
          if (expected_closing) return current;
        }
        var node = parse_one(t);

        node.parent = current;
        current.list[current.list.length] = node;
      }
      
      return current;
    }
    
    build_aggregate(toplevel, null);
    
    return toplevel;
  }

  // annotation rules to apply to a form based on its head

  var show_locals = true;  // HACK. would rather not use a (semi)-global.

  /* annotate_comment is a special case annotation. 
   * in addition to its role in styling specific forms, it is called by parse_one to
   * ignore any forms skipped with #_
   */ 
  function annotate_comment(exp) {
    exp.tag = "comments";

    if (exp.list) {
      exp.opening.tag = "comments";
      exp.closing.tag = "comments";
    
      for (var i = 0; i < exp.list.length; i++) {
        var child = exp.list[i];
        if (child.list) {
          annotate_comment(child);
        }
        if (child.attached_node) {
          annotate_comment(child.attached_node);
        }
        else {
          child.tag = "comments";
        }
      }
    }
  }

  /* custom annotation rules are stored here */
  var annotation_rules = {};
  
  // this function is exposed to allow ad hoc extension of the customisation rules
  function register_annotation_rule(names, rule) {
    for (var i = 0; i < names.length; i++) {
      annotation_rules[names[i]] = rule;
    }
  }


  function annotate_destructuring (exp, scope) {
    if (exp.list) {
      if (exp.tag === "vector") {
        for (var i = 0; i < exp.list.length; i++) {
          annotate_destructuring(exp.list[i], scope);
        }
      } 
      else if (exp.tag === "map") {
        for (var i = 0; i < exp.list.length; i += 2) {
          var key = exp.list[i];
          var val = exp.list[i + 1];
          
          if (key.tag === "keyword" && val.tag === "vector") {
            for (var ii = 0, jj = val.list.length; ii < jj; ii++) {
              if (val.list[ii].tag !== "symbol") continue;
              val.list[ii].tag = "variable";
              scope[val.list[ii].value] = true;
            }
          }
          else {
            annotate_destructuring(key, scope);
            annotate_expressions(val, scope);
          }
        } 
      }
    } 
    else if (exp.tag === "symbol" && (exp.value !== "&" && exp.value !== "&amp;")){
      exp.tag = "variable";
      scope[exp.value] = true;
    }
  }

  function _annotate_binding_vector (exp, scope) {
    if (exp.tag !== "vector") return;
  
    var bindings = exp.list;

    if (bindings.length % 2 === 1) return;
    
    for (var i = 0; i < bindings.length; i += 2) {
      annotate_destructuring(bindings[i], scope);
      annotate_expressions(bindings[i + 1], scope);
    }    
  }

  function annotate_binding (exp, scope) {
    var bindings = exp.list[1];
    if (!show_locals) return; // HACK

    if (bindings) {
      scope = Object.create(scope);
      _annotate_binding_vector(bindings, scope);
    }
    for (var i = 2; i < exp.list.length; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function _annotate_function_body (exp, scope, start_idx) {
    var argvec = exp.list[start_idx];
    if (argvec.tag !== "vector") return;

    scope = Object.create(scope);

    for (var i = 0, j = argvec.list.length; i < j; i++) {
      annotate_destructuring(argvec.list[i], scope);
    }
    
    for (var i = start_idx, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function annotate_function (exp, scope) {
    for (var i = 1, j = exp.list.length; i < j; i++) {
      var child = exp.list[i];
      
      if (child.tag === "vector") {
        _annotate_function_body (exp, scope, i);
        return;
      }
      else if (child.tag === "list") {
        _annotate_function_body(child, scope, 0)
      }
    }
  }
  
  function annotate_letfn (exp, scope) {
    scope = Object.create(scope);
    var bindings = exp.list[1];
    
    var fn;
    for (var i = 0, j = bindings.list.length; i < j; i++) {
      fn = bindings.list[i];
      if (!fn.list[0]) continue;
      fn.list[0].tag = "variable";
      scope[fn.list[0].value] = true;
    }
    
    for (i = 0, j = bindings.list.length; i < j; i++) {
      var fn = bindings.list[i];
      annotate_function(fn, scope);
    }
    
    for (i = 2, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }

  register_annotation_rule(
    ["comment"],
    annotate_comment
  );
  
  register_annotation_rule(
    ["let", "when-let", "if-let", "binding", "doseq", "for", "dotimes", "let*"],
    annotate_binding
  );
  
  register_annotation_rule(
    ["defn", "defn-", "fn", "bound-fn", "defmacro", "fn*", "defmethod"],
    annotate_function
  );
  
  register_annotation_rule(
    ["letfn"],
    annotate_letfn
  );

  // standard annotations

  function _annotate_metadata_recursive(meta, scope) {
    if (!meta) return;

    if (meta.list !== undefined && meta.list !== null) {
      for (var i = 0, j = meta.list.length; i < j; i++) {
        meta.opening.secondary_tags.meta = true
        meta.closing.secondary_tags.meta = true
        _annotate_metadata_recursive(meta.list[i], scope);
      }
    }
    else if (meta.attached_node) {
      meta.token.secondary_tags.meta = true;
      _annotate_metadata_recursive(meta.attached_node, scope);
    }
    else {
      meta.secondary_tags.meta = true;
    }
  }
  
  function annotate_metadata(exp) {
    if (!(exp && exp.meta)) return;
    var meta = exp.meta;
    
     annotate_expressions(meta, {});    
    _annotate_metadata_recursive(meta, {});
  }


  function annotate_quoted(exp, scope) {
    if (!exp) return;

    if (exp.list !== undefined && exp.list !== null) {
      for (var i = 0, j = exp.list.length; i < j; i++) {
        exp.opening.secondary_tags.quoted = true
        exp.closing.secondary_tags.quoted = true
        annotate_quoted(exp.list[i], scope);
      }
    }
    else if (exp.attached_node) {
      if (exp.tag === "unquote" || exp.tag === "splice") return;
      exp.token.secondary_tags.quoted = true;
      annotate_quoted(exp.attached_node, scope);
    }
    else {
      exp.secondary_tags.quoted = true;
    }
  }


  function annotate_expressions(exp, scope) {
    annotate_metadata(exp);
    
    switch (exp.tag) {
      case "toplevel": 
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "list": // functions, macros, special forms, comments
        var head = exp.list[0];
      
        if (head) {
          if (head.tag === "list" || head.tag === "vector" 
           || head.tag === "map" || head.tag === "set") {
            annotate_expressions(head, scope);
          }
          else if (head.attached_node) {
            annotate_expressions(head.attached_node, scope);
          }
          else {
            head.tag = (head.value.match(/(^\.)|(\.$)|[A-Z].*\//)
                        ? "method"
                        : "function");
          }

          // apply specific rules
          if (annotation_rules.hasOwnProperty(head.value)) {
            annotation_rules[head.value](exp, scope);
          } 
          else {
            for (var i = 1; i < exp.list.length; i++) {
              annotate_expressions(exp.list[i], scope);
            }
          } 
        }
        else { // empty list
          exp.opening.tag = "value";
          exp.closing.tag = "value";
        }
      
        break;
      
      case "vector": // data
      case "map":
      case "set":
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "symbol":
        if (exp.value.match(/[A-Z].*\/[A-Z_]+/)) {
          exp.tag = "constant";
        }
        else if (show_locals && scope[exp.value]) {
          exp.tag = "variable";
        }
        else if (exp.tag === "symbol" && exp.value.match(/([A-Z].*\/)?[A-Z_]+/)) {
          exp.tag = "type";
        }
        break;
      
      case "quote":
      case "quasiquote":
        annotate_quoted(exp.attached_node, scope);
        
      default:
        if (exp.attached_node) annotate_expressions(exp.attached_node, scope);
    }
  }

  // translation of tag to css:
  var css_translation = {
    "constant":     "constants",
    "keyword":      "constants",
    "method":       "color1",
    "type":         "color3", 
    "function":     "functions",
    "string":       "string",
    "regexp":       "string",
    "value":        "value",
    "comments":     "comments",
    "symbol":       "symbol",
    "variable":     "variable",
    "splice":       "preprocessor", 
    "unquote":      "preprocessor",     
    "preprocessor": "preprocessor",
    "meta":         "preprocessor", 
    "'":            "preprocessor", 
    "#'":           "preprocessor",    
    "(":            "plain",
    ")":            "plain",
    "{":            "keyword",
    "}":            "keyword",
    "#{":           "keyword",   
    "[":            "keyword",
    "]":            "keyword",
    "invalid":      "invalid",
    "@":            "plain" 
  };
  
  function translate_tags_to_css(tokens) {
    for (var i = 0, j = tokens.length; i < j; i++) {
      var token = tokens[i];
      token.css = css_translation[token.tag];
      for (var k in token.secondary_tags) if (token.secondary_tags.hasOwnProperty(k))
        token.css += " " + k ;
    };
  }
  
  
  // create the new brush

  SH.brushes.Clojure = function () {};
  SH.brushes.Clojure.prototype = new SyntaxHighlighter.Highlighter();
  
  SH.brushes.Clojure.prototype.findMatches = function find_matches (regexpList, code) {
    // this is a nasty global hack. need to resolve this
    if (this.params && this.params.locals) {
      show_locals = this.params.locals === true || this.params.locals === "true"; 
    }
    else {
      show_locals = true;
    }
    
    var tokens = tokenize(code);
    annotate_expressions(build_tree(tokens), {});
    translate_tags_to_css(tokens);

    return tokens;
  };
  
  SH.brushes.Clojure.aliases = ['clojure', 'Clojure', 'clj'];
  SH.brushes.Clojure.register_annotation_rule = register_annotation_rule;

  return {
    tokenize: tokenize,
    build_tree: build_tree
  };
})(SyntaxHighlighter);
</script><title>prismatic/schema -- Marginalia</title></head><body><table><tr><td class="docs"><div class="header"><h1 class="project-name"><a href="http://github.com/prismatic/schema">prismatic/schema</a></h1><h2 class="project-version">1.0.4-SNAPSHOT</h2><br /><p>Clojure(Script) library for declarative data description and validation</p>
</div></td><td class="codes" style="text-align: center; vertical-align: middle;color: #666;padding-right:20px"><br /><br /><br />(this space intentionally left almost blank)</td></tr><tr><td class="docs"><div class="toc"><a name="toc"><h3>namespaces</h3></a><ul><li><a href="#schema.coerce">schema.coerce</a></li><li><a href="#schema.coerce-test">schema.coerce-test</a></li><li><a href="#schema.core">schema.core</a></li><li><a href="#schema.core-test">schema.core-test</a></li><li><a href="#schema.experimental.abstract-map">schema.experimental.abstract-map</a></li><li><a href="#schema.experimental.abstract-map-test">schema.experimental.abstract-map-test</a></li><li><a href="#schema.experimental.complete">schema.experimental.complete</a></li><li><a href="#schema.experimental.complete-test">schema.experimental.complete-test</a></li><li><a href="#schema.experimental.generators">schema.experimental.generators</a></li><li><a href="#schema.experimental.generators-test">schema.experimental.generators-test</a></li><li><a href="#schema.macros">schema.macros</a></li><li><a href="#schema.macros-test">schema.macros-test</a></li><li><a href="#schema.potemkin">schema.potemkin</a></li><li><a href="#schema.spec.collection">schema.spec.collection</a></li><li><a href="#schema.spec.core">schema.spec.core</a></li><li><a href="#schema.spec.leaf">schema.spec.leaf</a></li><li><a href="#schema.spec.variant">schema.spec.variant</a></li><li><a href="#schema.test">schema.test</a></li><li><a href="#schema.test-macros">schema.test-macros</a></li><li><a href="#schema.test-test">schema.test-test</a></li><li><a href="#schema.utils">schema.utils</a></li></ul></div></td><td class="codes">&nbsp;</td></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.coerce" name="schema.coerce"><h1 class="project-name">schema.coerce</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Extension of schema for input coercion (coercing an input to match a schema)</p>
</td><td class="codes"><pre class="brush: clojure">(ns schema.coerce
  (:require
         [clojure.edn :as edn]
         [schema.macros :as macros]
   [schema.core :as s :include-macros true]
   [schema.spec.core :as spec]
   [schema.utils :as utils]
   [clojure.string :as str]))</pre></td></tr><tr><td class="docs"><p>Generic input coercion</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A Schema for Schemas</p>
</td><td class="codes"><pre class="brush: clojure">(def Schema
  (s/protocol s/Schema))</pre></td></tr><tr><td class="docs"><p>A function from schema to coercion function, or nil if no special coercion is needed.
   The returned function is applied to the corresponding data before validation (or walking/
   coercion of its sub-schemas, if applicable)</p>
</td><td class="codes"><pre class="brush: clojure">(def CoercionMatcher
  (s/=&gt; (s/maybe (s/=&gt; s/Any s/Any)) Schema))</pre></td></tr><tr><td class="docs"><p>Produce a function that simultaneously coerces and validates a datum.  Returns
   a coerced value, or a schema.utils.ErrorContainer describing the error.</p>
</td><td class="codes"><pre class="brush: clojure">(s/defn coercer
  [schema coercion-matcher :- CoercionMatcher]
  (spec/run-checker
   (fn [s params]
     (let [c (spec/checker (s/spec s) params)]
       (if-let [coercer (coercion-matcher s)]
         (fn [x]
           (macros/try-catchall
            (let [v (coercer x)]
              (if (utils/error? v)
                v
                (c v)))
            (catch t (macros/validation-error s x t))))
         c)))
   true
   schema))</pre></td></tr><tr><td class="docs"><p>Like <code>coercer</code>, but is guaranteed to return a value that satisfies schema (or throw).</p>
</td><td class="codes"><pre class="brush: clojure">(s/defn coercer!
  [schema coercion-matcher :- CoercionMatcher]
  (let [c (coercer schema coercion-matcher)]
    (fn [value]
      (let [coerced (c value)]
        (when-let [error (utils/error-val coerced)]
          (macros/error! (utils/format* &quot;Value cannot be coerced to match schema: %s&quot; (pr-str error))
                         {:schema schema :value value :error error}))
        coerced))))</pre></td></tr><tr><td class="docs"><p>Coercion helpers</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defn first-matcher :- CoercionMatcher
  &quot;A matcher that takes the first match from matchers.&quot;
  [matchers :- [CoercionMatcher]]
  (fn [schema] (first (keep #(% schema) matchers))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn string-&gt;keyword [s]
  (if (string? s) (keyword s) s))</pre></td></tr><tr><td class="docs"><p>returns true for strings that are equal, ignoring case, to the string 'true'
   (following java.lang.Boolean/parseBoolean semantics)</p>
</td><td class="codes"><pre class="brush: clojure">(defn string-&gt;boolean
  [s]
  (if (string? s) (= &quot;true&quot; (str/lower-case s)) s))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn keyword-enum-matcher [schema]
  (when (or (and (instance?       schema.core.EnumSchema                     schema)
                 (every? keyword? (.-vs ^schema.core.EnumSchema schema)))
            (and (instance?       schema.core.EqSchema                   schema)
                 (keyword? (.-v ^schema.core.EqSchema schema))))
    string-&gt;keyword))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set-matcher [schema]
  (if (instance?       clojure.lang.APersistentSet                                    schema)
    (fn [x] (if (sequential? x) (set x) x))))</pre></td></tr><tr><td class="docs"><p>Take a single-arg function f, and return a single-arg function that acts as identity
   if f throws an exception, and like f otherwise.  Useful because coercers are not explicitly
   guarded for exceptions, and failing to coerce will generally produce a more useful error
   in this case.</p>
</td><td class="codes"><pre class="brush: clojure">(defn safe
  [f]
  (fn [x] (macros/try-catchall (f x) (catch e x))))</pre></td></tr><tr><td class="docs"><p>Coerce x to a long if this can be done without losing precision, otherwise return x.</p>
</td><td class="codes"><pre class="brush: clojure">      (def safe-long-cast
        (safe
         (fn [x]
           (let [l (long x)]
             (if (== l x)
               l
               x)))))</pre></td></tr><tr><td class="docs"><p>Returns instance of UUID if input is a string.
   Note: in CLJS, this does not guarantee a specific UUID string representation,
         similar to #uuid reader</p>
</td><td class="codes"><pre class="brush: clojure">(def string-&gt;uuid
  (safe #(java.util.UUID/fromString ^String %)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:no-doc +json-coercions+
  (merge
   {s/Keyword string-&gt;keyword
    s/Bool string-&gt;boolean
    s/Uuid string-&gt;uuid}
         {clojure.lang.Keyword string-&gt;keyword
          s/Int safe-long-cast
          Long safe-long-cast
          Double (safe double)
          Boolean string-&gt;boolean}))</pre></td></tr><tr><td class="docs"><p>A matcher that coerces keywords and keyword eq/enums from strings, and longs and doubles
     from numbers on the JVM (without losing precision)</p>
</td><td class="codes"><pre class="brush: clojure">(defn json-coercion-matcher
  [schema]
  (or (+json-coercions+ schema)
      (keyword-enum-matcher schema)
      (set-matcher schema)))</pre></td></tr><tr><td class="docs"><p>Reads one object from a string. Returns nil when string is nil or empty</p>
</td><td class="codes"><pre class="brush: clojure">(def edn-read-string
        edn/read-string                          )</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:no-doc +string-coercions+
  (merge
   +json-coercions+
   {s/Num (safe edn-read-string)
    s/Int (safe edn-read-string)}
         {s/Int (safe #(safe-long-cast (edn-read-string %)))
          Long (safe #(safe-long-cast (edn-read-string %)))
          Double (safe #(Double/parseDouble %))}))</pre></td></tr><tr><td class="docs"><p>A matcher that coerces keywords, keyword eq/enums, s/Num and s/Int,
     and long and doubles (JVM only) from strings.</p>
</td><td class="codes"><pre class="brush: clojure">(defn string-coercion-matcher
  [schema]
  (or (+string-coercions+ schema)
      (keyword-enum-matcher schema)
      (set-matcher schema)))</pre></td></tr><tr><td class="docs"><p>This file autogenerated from src/cljx/schema/coerce.cljx</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.coerce-test" name="schema.coerce-test"><h1 class="project-name">schema.coerce-test</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns schema.coerce-test
        (:use clojure.test)
  (:require
   [schema.core :as s]
   [schema.utils :as utils]
   [schema.coerce :as coerce]))</pre></td></tr><tr><td class="docs"><p>s/Num s/Int</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def Generic
  {:i s/Int
   (s/optional-key :b) s/Bool
   (s/optional-key :n) s/Num
   (s/optional-key :s) s/Str
   (s/optional-key :k1) {s/Int s/Keyword}
   (s/optional-key :k2) s/Keyword
   (s/optional-key :e) (s/enum :a :b :c)
   (s/optional-key :eq) (s/eq :k)
   (s/optional-key :set) #{s/Keyword}
   (s/optional-key :u) s/Uuid})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def JSON
  {(s/optional-key :is) [s/Int]})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def JVM
  {(s/optional-key :jb) Boolean
   (s/optional-key :l) long
   (s/optional-key :d) Double
   (s/optional-key :jk) clojure.lang.Keyword})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn err-ks [res]
  (set (keys (utils/error-val res))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest json-coercer-test
  (let [coercer (coerce/coercer
                 (merge Generic JSON)
                 coerce/json-coercion-matcher)
        res {:i 1 :is [1 2] :n 3.0 :s &quot;asdf&quot; :k1 {1 :hi} :k2 :bye :e :a :eq :k :set #{:a :b}}]
    (is (= res
           (coercer {:i 1.0 :is [1.0 2.0] :n 3.0 :s &quot;asdf&quot; :k1 {1.0 &quot;hi&quot;} :k2 &quot;bye&quot; :e &quot;a&quot; :eq &quot;k&quot; :set [&quot;a&quot; &quot;a&quot; &quot;b&quot;]})))
    (is (= res (coercer res)))
    (is (= {:i 1 :b true} (coercer {:i 1.0 :b &quot;TRUE&quot;})))
    (is (= {:i 1 :b false} (coercer {:i 1.0 :b &quot;Yes&quot;})))
    (is (= #{:i :set} (err-ks (coercer {:i 1.1 :n 3 :set &quot;a&quot;})))))
        (testing &quot;jvm specific&quot;
          (let [coercer (coerce/coercer JVM coerce/json-coercion-matcher)
                res {:l 1 :d 1.0 :jk :asdf}]
            (is (= res (coercer {:l 1.0 :d 1 :jk &quot;asdf&quot;})))
            (is (= res (coercer res)))
            (is (= {:jb true} (coercer {:jb &quot;TRUE&quot;})))
            (is (= {:jb false} (coercer {:jb &quot;Yes&quot;})))
            (is (= #{:l :jk} (err-ks (coercer {:l 1.2 :jk 1.0}))))
            (is (= #{:d} (err-ks (coercer {:d nil}))))
            (is (= #{:d} (err-ks (coercer {:d &quot;1.0&quot;}))))))
        (testing &quot;malformed uuid&quot;
          (let [coercer (coerce/coercer Generic coerce/json-coercion-matcher)]
            (is (= #{:u} (err-ks (coercer {:i 1 :u &quot;uuid-wannabe&quot;})))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest string-coercer-test
  (let [coercer (coerce/coercer Generic coerce/string-coercion-matcher)]
    (is (= {:b true :i 1 :n 3.0 :s &quot;asdf&quot; :k1 {1 :hi} :k2 :bye :e :a :eq :k :u #uuid &quot;550e8400-e29b-41d4-a716-446655440000&quot; :set #{:a :b}}
           (coercer {:b &quot;true&quot; :i &quot;1&quot; :n &quot;3.0&quot; :s &quot;asdf&quot; :k1 {&quot;1&quot; &quot;hi&quot;} :k2 &quot;bye&quot; :e &quot;a&quot; :eq &quot;k&quot; :u &quot;550e8400-e29b-41d4-a716-446655440000&quot; :set [&quot;a&quot; &quot;a&quot; &quot;b&quot;]})))
    (is (= #{:i} (err-ks (coercer {:i &quot;1.1&quot;})))))
        (testing &quot;jvm specific&quot;
          (let [coercer (coerce/coercer JVM coerce/string-coercion-matcher)
                res {:jb false :l 2 :d 1.0 :jk :asdf}]
            (is (= res (coercer {:jb &quot;false&quot; :l &quot;2.0&quot; :d &quot;1&quot; :jk &quot;asdf&quot;})))
            (is (= #{:l} (err-ks (coercer {:l &quot;1.2&quot;})))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest coercer!-test
  (let [coercer (coerce/coercer! {:k s/Keyword :i s/Int} coerce/string-coercion-matcher)]
    (is (= {:k :key :i 12} (coercer {:k &quot;key&quot; :i &quot;12&quot;})))
    (is (thrown-with-msg?       Exception                  #&quot;keyword\? 12&quot; (coercer {:k 12 :i 12})))))</pre></td></tr><tr><td class="docs"><p>Test that recursion (which rebinds subschema-walker) works with coercion.</p>
</td><td class="codes"><pre class="brush: clojure">(do
  (def NestedVecs
    [(s/one s/Num &quot;Node ID&quot;) (s/recursive #'NestedVecs)])
  (deftest recursive-coercion-test
    (is (= [1 [2 [3] [4]]]
           ((coerce/coercer NestedVecs coerce/string-coercion-matcher)
            [&quot;1&quot; [&quot;2&quot; [&quot;3&quot;] [&quot;4&quot;]]])))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest constrained-test
  (is (= 1 ((coerce/coercer! (s/constrained s/Int odd?) coerce/string-coercion-matcher) &quot;1&quot;)))
  (is (= {1 1} ((coerce/coercer! (s/constrained {s/Int s/Int} #(odd? (count %))) coerce/string-coercion-matcher) {&quot;1&quot; &quot;1&quot;}))))</pre></td></tr><tr><td class="docs"><p>This file autogenerated from test/cljx/schema/coerce_test.cljx</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.core" name="schema.core"><h1 class="project-name">schema.core</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A library for data shape definition and validation. A Schema is just Clojure data,
   which can be used to document and validate Clojure functions and data.</p>

<p>   For example,</p>

<p>   (def FooBar {:foo Keyword :bar [Number]}) ;; a schema</p>

<p>   (check FooBar {:foo :k :bar [1.0 2.0 3.0]})
   ==> nil</p>

<p>   representing successful validation, but the following all return helpful errors
   describing how the provided data fails to measure up to schema FooBar's standards.</p>

<p>   (check FooBar {:bar [1.0 2.0 3.0]})
   ==> {:foo missing-required-key}</p>

<p>   (check FooBar {:foo 1 :bar [1.0 2.0 3.0]})
   ==> {:foo (not (keyword? 1))}</p>

<p>   (check FooBar {:foo :k :bar [1.0 2.0 3.0] :baz 1})
   ==> {:baz disallowed-key}</p>

<p>   Schema lets you describe your leaf values using the Any, Keyword, Symbol, Number,
   String, and Int definitions below, or (in Clojure) you can use arbitrary Java
   classes or primitive casts to describe simple values.</p>

<p>   From there, you can build up schemas for complex types using Clojure syntax
   (map literals for maps, set literals for sets, vector literals for sequences,
   with details described below), plus helpers below that provide optional values,
   enumerations, arbitrary predicates, and more.</p>

<p>   Assuming you (:require [schema.core :as s :include-macros true]),
   Schema also provides macros for defining records with schematized elements
   (s/defrecord), and named or anonymous functions (s/fn and s/defn) with
   schematized inputs and return values.  In addition to producing better-documented
   records and functions, these macros allow you to retrieve the schema associated
   with the defined record or function.  Moreover, functions include optional
   <em>validation</em>, which will throw an error if the inputs or outputs do not
   match the provided schemas:</p>

<p>   (s/defrecord FooBar
    [foo :- Int
     bar :- String])</p>

<p>   (s/defn quux :- Int
    [foobar :- Foobar
     mogrifier :- Number]
    (* mogrifier (+ (:foo foobar) (Long/parseLong (:bar foobar)))))</p>

<p>   (quux (FooBar. 10 "5") 2)
   ==> 30</p>

<p>   (fn-schema quux)
   ==> (=> Int (record user.FooBar {:foo Int, :bar java.lang.String}) java.lang.Number)</p>

<p>   (s/with-fn-validation (quux (FooBar. 10.2 "5") 2))
   ==> Input to quux does not match schema: [(named {:foo (not (integer? 10.2))} foobar) nil]</p>

<p>   As you can see, the preferred syntax for providing type hints to schema's defrecord,
   fn, and defn macros is to follow each element, argument, or function name with a
   :- schema.  Symbols without schemas default to a schema of Any.  In Clojure,
   class (e.g., clojure.lang.String) and primitive schemas (long, double) are also
   propagated to tag metadata to ensure you get the type hinting and primitive
   behavior you ask for.</p>

<p>   If you don't like this style, standard Clojure-style typehints are also supported:</p>

<p>   (fn-schema (s/fn [^String x]))
   ==> (=> Any java.lang.String)</p>

<p>   You can directly type hint a symbol as a class, primitive, or simple
   schema.</p>

<p>   See the docstrings of defrecord, fn, and defn for more details about how
   to use these macros.</p>
</td><td class="codes"><pre class="brush: clojure">(ns schema.core
  ;; don't exclude def because it's not a var.
  (:refer-clojure :exclude [Keyword Symbol atom defrecord defn letfn defmethod fn])
  (:require
   [clojure.string :as str]
         [schema.macros :as macros]
   [schema.utils :as utils]
   [schema.spec.core :as spec :include-macros true]
   [schema.spec.leaf :as leaf]
   [schema.spec.variant :as variant]
   [schema.spec.collection :as collection]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">      (def clj-1195-fixed?
        (do (defprotocol CLJ1195Check
              (dummy-method [this]))
            (try
              (eval '(extend-protocol CLJ1195Check nil
                                      (dummy-method [_])))
              true
              (catch RuntimeException _
                false))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">      (when-not clj-1195-fixed?
        ;; don't exclude fn because of bug in extend-protocol
        (refer-clojure :exclude '[Keyword Symbol atom defrecord defn letfn defmethod]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">      (set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs"><p>Schema protocol</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol Schema
  (spec [this]
    &quot;A spec is a record of some type that expresses the structure of this schema
     in a declarative and/or imperative way.  See schema.spec.* for examples.&quot;)
  (explain [this]
    &quot;Expand this schema to a human-readable format suitable for pprinting,
     also expanding class schematas at the leaves.  Example:
     user&gt; (s/explain {:a s/Keyword :b [s/Int]} )
     {:a Keyword, :b [Int]}&quot;))</pre></td></tr><tr><td class="docs"><p>Schemas print as their explains</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(do (clojure.core/defmethod print-method schema.core.Schema [s writer]
      (print-method (explain s) writer))
    (prefer-method print-method schema.core.Schema clojure.lang.IRecord)
    (prefer-method print-method schema.core.Schema java.util.Map)
    (prefer-method print-method schema.core.Schema clojure.lang.IPersistentMap))</pre></td></tr><tr><td class="docs"><p>Compile an efficient checker for schema, which returns nil for valid values and
   error descriptions otherwise.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn checker
  [schema]
  (comp utils/error-val
        (spec/run-checker
         (clojure.core/fn [s params] (spec/checker (spec s) params)) false schema)))</pre></td></tr><tr><td class="docs"><p>Return nil if x matches schema; otherwise, returns a value that looks like the
   'bad' parts of x with ValidationErrors at the leaves describing the failures.</p>

<p>   If you will be checking many datums, it is much more efficient to create
   a 'checker' once and call it on each of them.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn check
  [schema x]
  ((checker schema) x))</pre></td></tr><tr><td class="docs"><p>Compile an efficient validator for schema.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn validator
  [schema]
  (let [c (checker schema)]
    (clojure.core/fn [value]
      (when-let [error (c value)]
        (macros/error! (utils/format* &quot;Value does not match schema: %s&quot; (pr-str error))
                       {:schema schema :value value :error error}))
      value)))</pre></td></tr><tr><td class="docs"><p>Throw an exception if value does not satisfy schema; otherwise, return value.
   If you will be validating many datums, it is much more efficient to create
   a 'validator' once and call it on each of them.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn validate
  [schema value]
  ((validator schema) value))</pre></td></tr><tr><td class="docs"><p>Platform-specific leaf Schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>On the JVM, a Class itself is a schema. In JS, we treat functions as prototypes so any
function prototype checks objects for compatibility.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn instance-precondition [s klass]
  (spec/precondition
   s
         #(instance? klass %)
   #(list 'instance? klass %)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol Schema
        Class
                 
  (spec [this]
    (let [pre (instance-precondition this this)]
      (if-let [class-schema (utils/class-schema this)]
        (variant/variant-spec pre [{:schema class-schema}])
        (leaf/leaf-spec pre))))
  (explain [this]
    (if-let [more-schema (utils/class-schema this)]
      (explain more-schema)
      (condp = this
              java.lang.String            'Str
              java.lang.Boolean                   'Bool
              java.lang.Number                  'Num
              java.util.regex.Pattern            'Regex
              java.util.Date                'Inst
              java.util.UUID                       'Uuid
              (symbol (.getName ^Class this))            ))))</pre></td></tr><tr><td class="docs"><p>On the JVM, the primitive coercion functions (double, long, etc)
alias to the corresponding boxed number classes</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(do
  (defmacro extend-primitive [cast-sym class-sym]
    (let [qualified-cast-sym `(class @(resolve '~cast-sym))]
      `(extend-protocol Schema
         ~qualified-cast-sym
         (spec [this#]
           (variant/variant-spec spec/+no-precondition+ [{:schema ~class-sym}]))
         (explain [this#]
           '~cast-sym))))
  (extend-primitive double Double)
  (extend-primitive float Float)
  (extend-primitive long Long)
  (extend-primitive int Integer)
  (extend-primitive short Short)
  (extend-primitive char Character)
  (extend-primitive byte Byte)
  (extend-primitive boolean Boolean)
  (extend-primitive doubles (Class/forName &quot;[D&quot;))
  (extend-primitive floats (Class/forName &quot;[F&quot;))
  (extend-primitive longs (Class/forName &quot;[J&quot;))
  (extend-primitive ints (Class/forName &quot;[I&quot;))
  (extend-primitive shorts (Class/forName &quot;[S&quot;))
  (extend-primitive chars (Class/forName &quot;[C&quot;))
  (extend-primitive bytes (Class/forName &quot;[B&quot;))
  (extend-primitive booleans (Class/forName &quot;[Z&quot;)))</pre></td></tr><tr><td class="docs"><p>Cross-platform Schema leaves</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Any matches anything (including nil)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord AnythingSchema [_]
  ;; _ is to work around bug in Clojure where eval-ing defrecord with no fields
  ;; loses type info, which makes this unusable in schema-fn.
  ;; http://dev.clojure.org/jira/browse/CLJ-1093
  Schema
  (spec [this] (leaf/leaf-spec spec/+no-precondition+))
  (explain [this] 'Any))</pre></td></tr><tr><td class="docs"><p>Any value, including nil.</p>
</td><td class="codes"><pre class="brush: clojure">(def Any
  (AnythingSchema. nil))</pre></td></tr><tr><td class="docs"><p>eq (to a single allowed value)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord EqSchema [v]
  Schema
  (spec [this] (leaf/leaf-spec (spec/precondition this #(= v %) #(list '= v %))))
  (explain [this] (list 'eq v)))</pre></td></tr><tr><td class="docs"><p>A value that must be (= v).</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn eq
  [v]
  (EqSchema. v))</pre></td></tr><tr><td class="docs"><p>isa (a child of parent)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord Isa [h parent]
  Schema
  (spec [this] (leaf/leaf-spec (spec/precondition this #(isa? h % parent) #(list 'isa? % parent))))
  (explain [this] (list 'isa? parent)))</pre></td></tr><tr><td class="docs"><p>A value that must be a child of parent.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn isa
  ([parent]
     (Isa. nil parent))
  ([h parent]
     (Isa. h parent)))</pre></td></tr><tr><td class="docs"><p>enum (in a set of allowed values)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord EnumSchema [vs]
  Schema
  (spec [this] (leaf/leaf-spec (spec/precondition this #(contains? vs %) #(list vs %))))
  (explain [this] (cons 'enum vs)))</pre></td></tr><tr><td class="docs"><p>A value that must be = to some element of vs.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn enum
  [&amp; vs]
  (EnumSchema. (set vs)))</pre></td></tr><tr><td class="docs"><p>pred (matches all values for which p? returns truthy)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord Predicate [p? pred-name]
  Schema
  (spec [this] (leaf/leaf-spec (spec/precondition this p? #(list pred-name %))))
  (explain [this]
    (cond (= p? integer?) 'Int
          (= p? keyword?) 'Keyword
          (= p? symbol?) 'Symbol
          (= p? string?) 'Str
          :else (list 'pred pred-name))))</pre></td></tr><tr><td class="docs"><p>A value for which p? returns true (and does not throw).
   Optional pred-name can be passed for nicer validation errors.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn pred
  ([p?] (pred p? (symbol (utils/fn-name p?))))
  ([p? pred-name]
     (when-not (ifn? p?)
       (macros/error! (utils/format* &quot;Not a function: %s&quot; p?)))
     (Predicate. p? pred-name)))</pre></td></tr><tr><td class="docs"><p>protocol (which value must <code>satisfies?</code>)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn protocol-name [protocol]
  (-&gt; protocol meta :proto-sym))</pre></td></tr><tr><td class="docs"><p>In cljs, satisfies? is a macro so we must precompile (partial satisfies? p)
and put it in metadata of the record so that equality is preserved, along with the name.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord Protocol [p]
  Schema
  (spec [this]
    (leaf/leaf-spec
     (spec/precondition
      this
      #((:proto-pred (meta this)) %)
      #(list 'satisfies? (protocol-name this) %))))
  (explain [this] (list 'protocol (protocol-name this))))</pre></td></tr><tr><td class="docs"><p>A value that must satsify? protocol p.</p>

<p>   Internaly, we must make sure not to capture the value of the protocol at
   schema creation time, since that's impossible in cljs and breaks later
   extends in Clojure.</p>

<p>   A macro for cljs sake, since <code>satisfies?</code> is a macro in cljs.</p>

<p>The cljs version is macros/protocol by necessity, since cljs <code>satisfies?</code> is a macro.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro protocol
  [p]
  `(with-meta (-&gt;Protocol ~p)
     {:proto-pred #(satisfies? ~p %)
      :proto-sym '~p}))</pre></td></tr><tr><td class="docs"><p>regex (validates matching Strings)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol Schema
        java.util.regex.Pattern
                  
  (spec [this]
    (leaf/leaf-spec
     (some-fn
      (spec/simple-precondition this string?)
      (spec/precondition this #(re-find this %) #(list 're-find (explain this) %)))))
  (explain [this]
          (symbol (str &quot;#\&quot;&quot; this &quot;\&quot;&quot;))
                                                             ))</pre></td></tr><tr><td class="docs"><p>Cross-platform Schemas for atomic value types</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Satisfied only by String.
   Is (pred string?) and not js/String in cljs because of keywords.</p>
</td><td class="codes"><pre class="brush: clojure">(def Str
        java.lang.String                      )</pre></td></tr><tr><td class="docs"><p>Boolean true or false</p>
</td><td class="codes"><pre class="brush: clojure">(def Bool
        java.lang.Boolean                  )</pre></td></tr><tr><td class="docs"><p>Any number</p>
</td><td class="codes"><pre class="brush: clojure">(def Num
        java.lang.Number                 )</pre></td></tr><tr><td class="docs"><p>Any integral number</p>
</td><td class="codes"><pre class="brush: clojure">(def Int
  (pred integer?))</pre></td></tr><tr><td class="docs"><p>A keyword</p>
</td><td class="codes"><pre class="brush: clojure">(def Keyword
  (pred keyword?))</pre></td></tr><tr><td class="docs"><p>A symbol</p>
</td><td class="codes"><pre class="brush: clojure">(def Symbol
  (pred symbol?))</pre></td></tr><tr><td class="docs"><p>A regular expression</p>
</td><td class="codes"><pre class="brush: clojure">(def Regex
        java.util.regex.Pattern)</pre></td></tr><tr><td class="docs"><p>The local representation of #inst ...</p>
</td><td class="codes"><pre class="brush: clojure">(def Inst
        java.util.Date               )</pre></td></tr><tr><td class="docs"><p>The local representation of #uuid ...</p>
</td><td class="codes"><pre class="brush: clojure">(def Uuid
        java.util.UUID                      )</pre></td></tr><tr><td class="docs"><p>Variant schemas (and other unit containers)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>maybe (nil)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord Maybe [schema]
  Schema
  (spec [this]
    (variant/variant-spec
     spec/+no-precondition+
     [{:guard nil? :schema (eq nil)}
      {:schema schema}]))
  (explain [this] (list 'maybe (explain schema))))</pre></td></tr><tr><td class="docs"><p>A value that must either be nil or satisfy schema</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn maybe
  [schema]
  (Maybe. schema))</pre></td></tr><tr><td class="docs"><p>named (schema elements)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord NamedSchema [schema name]
  Schema
  (spec [this]
    (variant/variant-spec
     spec/+no-precondition+
     [{:schema schema :wrap-error #(utils/-&gt;NamedError name %)}]))
  (explain [this] (list 'named (explain schema) name)))</pre></td></tr><tr><td class="docs"><p>A value that must satisfy schema, and has a name for documentation purposes.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn named
  [schema name]
  (NamedSchema. schema name))</pre></td></tr><tr><td class="docs"><p>either (satisfies this schema or that one)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord Either [schemas]
  Schema
  (spec [this]
    (variant/variant-spec
     spec/+no-precondition+
     (for [s schemas]
       {:guard (complement (checker s)) ;; since the guard determines which option we check against
        :schema s})
     #(list 'some-matching-either-clause? %)))
  (explain [this] (cons 'either (map explain schemas))))</pre></td></tr><tr><td class="docs"><p>A value that must satisfy at least one schema in schemas.
   Note that <code>either</code> does not work properly with coercion</p>

<p>   DEPRECATED: prefer <code>conditional</code> or <code>cond-pre</code></p>

<p>   WARNING: either does not work with coercion.  It is also slow and gives
   bad error messages.  Please consider using <code>conditional</code> and friends
   instead; they are more efficient, provide better error messages,
   and work with coercion.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn ^{:deprecated &quot;1.0.0&quot;} either
  [&amp; schemas]
  (Either. schemas))</pre></td></tr><tr><td class="docs"><p>conditional (choice of schema, based on predicates on the value)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord ConditionalSchema [preds-and-schemas error-symbol]
  Schema
  (spec [this]
    (variant/variant-spec
     spec/+no-precondition+
     (for [[p s] preds-and-schemas]
       {:guard p :schema s})
     #(list (or error-symbol
                (if (= 1 (count preds-and-schemas))
                  (symbol (utils/fn-name (ffirst preds-and-schemas)))
                  'some-matching-condition?))
            %)))
  (explain [this]
    (cons 'conditional
          (concat
           (mapcat (clojure.core/fn [[pred schema]] [(symbol (utils/fn-name pred)) (explain schema)])
                   preds-and-schemas)
           (when error-symbol [error-symbol])))))</pre></td></tr><tr><td class="docs"><p>Define a conditional schema.  Takes args like cond,
   (conditional pred1 schema1 pred2 schema2 ...),
   and checks the first schema where pred is true on the value.
   Unlike cond, throws if the value does not match any condition.
   :else may be used as a final condition in the place of (constantly true).
   More efficient than either, since only one schema must be checked.
   An optional final argument can be passed, a symbol to appear in
   error messages when none of the conditions match.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn conditional
  [&amp; preds-and-schemas]
  (macros/assert!
   (and (seq preds-and-schemas)
        (or (even? (count preds-and-schemas))
            (symbol? (last preds-and-schemas))))
   &quot;Expected even, nonzero number of args (with optional trailing symbol); got %s&quot;
   (count preds-and-schemas))
  (ConditionalSchema.
   (for [[pred schema] (partition 2 preds-and-schemas)]
     [(if (= pred :else) (constantly true) pred) schema])
   (if (odd? (count preds-and-schemas)) (last preds-and-schemas))))</pre></td></tr><tr><td class="docs"><p>cond-pre (conditional based on surface type)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol HasPrecondition
  (precondition [this]
    &quot;Return a predicate representing the Precondition for this schema:
     the predicate returns true if the precondition is satisfied.
     (See spec.core for more details)&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol HasPrecondition
  schema.spec.leaf.LeafSpec
  (precondition [this]
    (complement (.-pre ^schema.spec.leaf.LeafSpec this)))

  schema.spec.variant.VariantSpec
  (precondition [^schema.spec.variant.VariantSpec this]
    (every-pred
     (complement (.-pre this))
     (apply some-fn
            (for [{:keys [guard schema]} (.-options this)]
              (if guard
                (every-pred guard (precondition (spec schema)))
                (precondition (spec schema)))))))

  schema.spec.collection.CollectionSpec
  (precondition [this]
    (complement (.-pre ^schema.spec.collection.CollectionSpec this))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord CondPre [schemas]
  Schema
  (spec [this]
    (variant/variant-spec
     spec/+no-precondition+
     (for [s schemas]
       {:guard (precondition (spec s))
        :schema s})
     #(list 'matches-some-precondition? %)))
  (explain [this]
    (cons 'cond-pre
          (map explain schemas))))</pre></td></tr><tr><td class="docs"><p>A replacement for <code>either</code> that constructs a conditional schema
   based on the schema spec preconditions of the component schemas.</p>

<p>   EXPERIMENTAL</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn cond-pre
  [&amp; schemas]
  (CondPre. schemas))</pre></td></tr><tr><td class="docs"><p>constrained (post-condition on schema)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord Constrained [schema postcondition post-name]
  Schema
  (spec [this]
    (variant/variant-spec
     spec/+no-precondition+
     [{:schema schema}]
     nil
     (spec/precondition this postcondition #(list post-name %))))
  (explain [this]
    (list 'constrained (explain schema) post-name)))</pre></td></tr><tr><td class="docs"><p>A schema with an additional post-condition.  Differs from <code>conditional</code>
   with a single schema, in that the predicate checked <em>after</em> the main
   schema.  This can lead to better error messages, and is often better
   suited for coercion.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn constrained
  ([s p?] (constrained s p? (symbol (utils/fn-name p?))))
  ([s p? pred-name]
     (when-not (ifn? p?)
       (macros/error! (utils/format* &quot;Not a function: %s&quot; p?)))
     (Constrained. s p? pred-name)))</pre></td></tr><tr><td class="docs"><p>both (satisfies this schema and that one)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord Both [schemas]
  Schema
  (spec [this] this)
  (explain [this] (cons 'both (map explain schemas)))
  HasPrecondition
  (precondition [this]
    (apply every-pred (map (comp precondition spec) schemas)))
  spec/CoreSpec
  (subschemas [this] schemas)
  (checker [this params]
    (reduce
     (clojure.core/fn [f t]
       (clojure.core/fn [x]
         (let [tx (t x)]
           (if (utils/error? tx)
             tx
             (f (or tx x))))))
     (map #(spec/sub-checker {:schema %} params) (reverse schemas)))))</pre></td></tr><tr><td class="docs"><p>A value that must satisfy every schema in schemas.</p>

<p>   DEPRECATED: prefer 'conditional' with a single condition
   instead, or <code>constrained</code>.</p>

<p>   When used with coercion, coerces each schema in sequence.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn ^{:deprecated &quot;1.0.0&quot;} both
  [&amp; schemas]
  (Both. schemas))</pre></td></tr><tr><td class="docs"><p>if the predicate returns truthy, use the if-schema, otherwise use the else-schema</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn if
  [pred if-schema else-schema]
  (conditional pred if-schema (constantly true) else-schema))</pre></td></tr><tr><td class="docs"><p>Recursive schemas
Supports recursively defined schemas by using the level of indirection offered by by
Clojure and ClojureScript vars.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn var-name [v]
  (let [{:keys [ns name]} (meta v)]
    (symbol (str       (ns-name ns)           &quot;/&quot; name))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord Recursive [derefable]
  Schema
  (spec [this] (variant/variant-spec spec/+no-precondition+ [{:schema @derefable}]))
  (explain [this]
    (list 'recursive
          (if       (var? derefable)                                 
              (list 'var (var-name derefable))
              (format &quot;%s@%x&quot;
                      (.getName (class derefable))
                      (System/identityHashCode derefable))))))</pre></td></tr><tr><td class="docs"><p>Support for (mutually) recursive schemas by passing a var that points to a schema,
   e.g (recursive #'ExampleRecursiveSchema).</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn recursive
  [schema]
  (when-not       (instance? clojure.lang.IDeref schema)                                  
            (macros/error! (utils/format* &quot;Not an IDeref: %s&quot; schema)))
  (Recursive. schema))</pre></td></tr><tr><td class="docs"><p>Atom schema</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- atom? [x]
        (instance? clojure.lang.Atom x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord Atomic [schema]
  Schema
  (spec [this]
    (collection/collection-spec
     (spec/simple-precondition this atom?)
     clojure.core/atom
     [(collection/one-element true schema (clojure.core/fn [item-fn coll] (item-fn @coll) nil))]
     (clojure.core/fn [_ xs _] (clojure.core/atom (first xs)))))
  (explain [this] (list 'atom (explain schema))))</pre></td></tr><tr><td class="docs"><p>An atom containing a value matching 'schema'.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn atom
  [schema]
  (-&gt;Atomic schema))</pre></td></tr><tr><td class="docs"><p>Map Schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A map schema is itself a Clojure map, which can provide value schemas for specific required
and optional keys, as well as a single, optional schema for additional key-value pairs.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Specific keys are mapped to value schemas, and given as either:
 - (required-key k), a required key (= k)
 - a keyword, also a required key
 - (optional-key k), an optional key (= k)
For example, {:a Int (optional-key :b) String} describes a map with key :a mapping to an
integer, an optional key :b mapping to a String, and no other keys.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>There can also be a single additional key, itself a schema, mapped to the schema for
corresponding values, which applies to all key-value pairs not covered by an explicit
key.
For example, {Int String} is a mapping from integers to strings, and
{:a Int Int String} is a mapping from :a to an integer, plus zero or more additional
mappings from integers to strings.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Definitions for required and optional keys, and single entry validators</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord RequiredKey [k])</pre></td></tr><tr><td class="docs"><p>A required key in a map</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn required-key
  [k]
  (if (keyword? k)
    k
    (RequiredKey. k)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn required-key? [ks]
  (or (keyword? ks)
      (instance? RequiredKey ks)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord OptionalKey [k])</pre></td></tr><tr><td class="docs"><p>An optional key in a map</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn optional-key
  [k]
  (OptionalKey. k))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn optional-key? [ks]
  (instance? OptionalKey ks))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn explicit-schema-key [ks]
  (cond (keyword? ks) ks
        (instance? RequiredKey ks) (.-k ^RequiredKey ks)
        (optional-key? ks) (.-k ^OptionalKey ks)
        :else (macros/error! (utils/format* &quot;Bad explicit key: %s&quot; ks))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn specific-key? [ks]
  (or (required-key? ks)
      (optional-key? ks)))</pre></td></tr><tr><td class="docs"><p>A schema for a single map entry.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord MapEntry [key-schema val-schema]
  Schema
  (spec [this]
    (collection/collection-spec
     spec/+no-precondition+
     vec
     [(collection/one-element true key-schema (clojure.core/fn [item-fn e] (item-fn (key e)) e))
      (collection/one-element true val-schema (clojure.core/fn [item-fn e] (item-fn (val e)) nil))]
     (clojure.core/fn [[k] [xk xv] _]
       (if-let [k-err (utils/error-val xk)]
         [k-err 'invalid-key]
         [k (utils/error-val xv)]))))
  (explain [this]
    (list
     'map-entry
     (explain key-schema)
     (explain val-schema))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn map-entry [key-schema val-schema]
  (MapEntry. key-schema val-schema))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn find-extra-keys-schema [map-schema]
  (let [key-schemata (remove specific-key? (keys map-schema))]
    (macros/assert! (&lt; (count key-schemata) 2)
                    &quot;More than one non-optional/required key schemata: %s&quot;
                    (vec key-schemata))
    (first key-schemata)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn- explain-kspec [kspec]
  (if (specific-key? kspec)
    (if (keyword? kspec)
      kspec
      (list (cond (required-key? kspec) 'required-key
                  (optional-key? kspec) 'optional-key)
            (explicit-schema-key kspec)))
    (explain kspec)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- map-elements [this]
  (let [extra-keys-schema (find-extra-keys-schema this)]
    (let [duplicate-keys (-&gt;&gt; (dissoc this extra-keys-schema)
                              keys
                              (group-by explicit-schema-key)
                              vals
                              (filter #(&gt; (count %) 1))
                              (apply concat)
                              (mapv explain-kspec))]
      (macros/assert! (empty? duplicate-keys)
                      &quot;Schema has multiple variants of the same explicit key: %s&quot; duplicate-keys))
    (concat
     (for [[k v] (dissoc this extra-keys-schema)]
       (let [rk (explicit-schema-key k)
             required? (required-key? k)]
         (collection/one-element
          required? (map-entry (eq rk) v)
          (clojure.core/fn [item-fn m]
            (let [e (find m rk)]
              (cond e (item-fn e)
                    required? (item-fn (utils/error [rk 'missing-required-key])))
              (if e
                (dissoc       (if (instance? clojure.lang.PersistentStructMap m) (into {} m) m)         
                        rk)
                m))))))
     (when extra-keys-schema
       [(collection/all-elements (apply map-entry (find this extra-keys-schema)))]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- map-error []
  (clojure.core/fn [_ elts extra]
    (into {} (concat (keep utils/error-val elts) (for [[k _] extra] [k 'disallowed-key])))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- map-spec [this]
  (collection/collection-spec
   (spec/simple-precondition this map?)
   #(into {} %)
   (map-elements this)
   (map-error)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn- map-explain [this]
  (into {} (for [[k v] this] [(explain-kspec k) (explain v)])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol Schema
        clojure.lang.APersistentMap
                                     
  (spec [this] (map-spec this))
  (explain [this] (map-explain this))
                                    
                                      
                                            )</pre></td></tr><tr><td class="docs"><p>Set schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A set schema is a Clojure set with a single element, a schema that all values must satisfy</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol Schema
        clojure.lang.APersistentSet
                                    
  (spec [this]
    (macros/assert! (= (count this) 1) &quot;Set schema must have exactly one element&quot;)
    (collection/collection-spec
     (spec/simple-precondition this set?)
     set
     [(collection/all-elements (first this))]
     (clojure.core/fn [_ xs _] (set (keep utils/error-val xs)))))
  (explain [this] (set [(explain (first this))])))</pre></td></tr><tr><td class="docs"><p>Queue schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A queue schema is satisfied by PersistentQueues containing values that all satisfy
a specific sub-schema.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn queue? [x]
  (instance?
         clojure.lang.PersistentQueue
   x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn as-queue [col]
  (reduce
   conj
         clojure.lang.PersistentQueue/EMPTY
   col))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord Queue [schema]
  Schema
  (spec [this]
    (collection/collection-spec
     (spec/simple-precondition this queue?)
     as-queue
     [(collection/all-elements schema)]
     (clojure.core/fn [_ xs _] (as-queue (keep utils/error-val xs)))))
  (explain [this] (list 'queue (explain schema))))</pre></td></tr><tr><td class="docs"><p>Defines a schema satisfied by instances of clojure.lang.PersistentQueue
  (clj.core/PersistentQueue in ClojureScript) whose values satisfy x.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn queue
  [x]
  (Queue. x))</pre></td></tr><tr><td class="docs"><p>Sequence Schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A sequence schema looks like [one* optional* rest-schema?].
one matches a single required element, and must be the output of 'one' below.
optional matches a single optional element, and must be the output of 'optional' below.
Finally, rest-schema is any schema, which must match any remaining elements.
(if optional elements are present, they must be matched before the rest-schema is applied).</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord One [schema optional? name])</pre></td></tr><tr><td class="docs"><p>A single required element of a sequence (not repeated, the implicit default)</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn one
  ([schema name]
     (One. schema false name)))</pre></td></tr><tr><td class="docs"><p>A single optional element of a sequence (not repeated, the implicit default)</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn optional
  ([schema name]
     (One. schema true name)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn parse-sequence-schema [s]
  &quot;Parses and validates a sequence schema, returning a vector in the form
  [singles multi] where singles is a sequence of 'one' and 'optional' schemas
  and multi is the rest-schema (which may be nil). A valid sequence schema is
  a vector in the form [one* optional* rest-schema?].&quot;
  (let [[required more] (split-with #(and (instance? One %) (not (:optional? %))) s)
        [optional more] (split-with #(and (instance? One %) (:optional? %)) more)]
    (macros/assert!
     (and (&lt;= (count more) 1) (every? #(not (instance? One %)) more))
     &quot;%s is not a valid sequence schema; %s%s%s&quot; s
     &quot;a valid sequence schema consists of zero or more `one` elements, &quot;
     &quot;followed by zero or more `optional` elements, followed by an optional &quot;
     &quot;schema that will match the remaining elements.&quot;)
    [(concat required optional) (first more)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol Schema
        clojure.lang.APersistentVector
                                   
  (spec [this]
    (collection/collection-spec
     (spec/precondition
      this
      (clojure.core/fn [x] (or (nil? x) (sequential? x)       (instance? java.util.List x)))
      #(list 'sequential? %))
     vec
     (let [[singles multi] (parse-sequence-schema this)]
       (concat
        (for [^One s singles]
          (let [required? (not (.-optional? s))]
            (collection/one-element
             required? (named (.-schema s) (.-name s))
             (clojure.core/fn [item-fn x]
               (if-let [x (seq x)]
                 (do (item-fn (first x))
                     (rest x))
                 (do (when required?
                       (item-fn
                        (macros/validation-error
                         (.-schema s) ::missing
                         (list 'present? (.-name s)))))
                     nil))))))
        (when multi
          [(collection/all-elements multi)])))
     (clojure.core/fn [_ elts extra]
       (let [head (mapv utils/error-val elts)]
         (if (seq extra)
           (conj head (utils/error-val (macros/validation-error nil extra (list 'has-extra-elts? (count extra)))))
           head)))))
  (explain [this]
    (let [[singles multi] (parse-sequence-schema this)]
      (vec
       (concat
        (for [^One s singles]
          (list (if (.-optional? s) 'optional 'one) (explain (:schema s)) (:name s)))
        (when multi
          [(explain multi)]))))))</pre></td></tr><tr><td class="docs"><p>A schema for a pair of schemas and their names</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn pair
  [first-schema first-name second-schema second-name]
  [(one first-schema first-name)
   (one second-schema second-name)])</pre></td></tr><tr><td class="docs"><p>Record Schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A Record schema describes a value that must have the correct type, and its body must
also satisfy a map schema.  An optional :extra-validator-fn can also be attached to do
additional validation.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord Record [klass schema]
  Schema
  (spec [this]
    (collection/collection-spec
     (let [p (spec/precondition this #(instance? klass %) #(list 'instance? klass %))]
       (if-let [evf (:extra-validator-fn this)]
         (some-fn p (spec/precondition this evf #(list 'passes-extra-validation? %)))
         p))
     (:constructor (meta this))
     (map-elements schema)
     (map-error)))
  (explain [this]
    (list 'record       (symbol (.getName ^Class klass))                                (explain schema))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn record* [klass schema map-constructor]
        (macros/assert! (class? klass) &quot;Expected record class, got %s&quot; (utils/type-of klass))
  (macros/assert! (map? schema) &quot;Expected map, got %s&quot; (utils/type-of schema))
  (with-meta (Record. klass schema) {:constructor map-constructor}))</pre></td></tr><tr><td class="docs"><p>A Record instance of type klass, whose elements match map schema 'schema'.</p>

<p>   The final argument is the map constructor of the record type; if you do
   not pass one, an attempt is made to find the corresponding function
   (but this may fail in exotic circumstances).</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro record
  ([klass schema]
     `(record ~klass ~schema
              (macros/if-cljs
               ~(let [bits (str/split (name klass) #&quot;/&quot;)]
                  (symbol (str/join &quot;/&quot; (concat (butlast bits) [(str &quot;map-&gt;&quot; (last bits))]))))
               #(~(symbol (str (name klass) &quot;/create&quot;)) %))))
  ([klass schema map-constructor]
     `(record* ~klass ~schema #(~map-constructor (into {} %)))))</pre></td></tr><tr><td class="docs"><p>Function Schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A function schema describes a function of one or more arities.
The function can only have a single output schema (across all arities), and each input
schema is a sequence schema describing the argument vector.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Currently function schemas are purely descriptive, and do not carry any validation logic.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn explain-input-schema [input-schema]
  (let [[required more] (split-with #(instance? One %) input-schema)]
    (concat (map #(explain (.-schema ^One %)) required)
            (when (seq more)
              ['&amp; (mapv explain more)]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defrecord FnSchema [output-schema input-schemas] ;; input-schemas sorted by arity
  Schema
  (spec [this] (leaf/leaf-spec (spec/simple-precondition this ifn?)))
  (explain [this]
    (if (&gt; (count input-schemas) 1)
      (list* '=&gt;* (explain output-schema) (map explain-input-schema input-schemas))
      (list* '=&gt; (explain output-schema) (explain-input-schema (first input-schemas))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn- arity [input-schema]
  (if (seq input-schema)
    (if (instance? One (last input-schema))
      (count input-schema)
            Long/MAX_VALUE                           )
    0))</pre></td></tr><tr><td class="docs"><p>A function outputting a value in output schema, whose argument vector must match one of
   input-schemas, each of which should be a sequence schema.
   Currently function schemas are purely descriptive; they validate against any function,
   regardless of actual input and output types.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn make-fn-schema
  [output-schema input-schemas]
  (macros/assert! (seq input-schemas) &quot;Function must have at least one input schema&quot;)
  (macros/assert! (every? vector? input-schemas) &quot;Each arity must be a vector.&quot;)
  (macros/assert! (apply distinct? (map arity input-schemas)) &quot;Arities must be distinct&quot;)
  (FnSchema. output-schema (sort-by arity input-schemas)))</pre></td></tr><tr><td class="docs"><p>Produce a function schema from an output schema and a list of arity input schema specs,
   each of which is a vector of argument schemas, ending with an optional '&amp; more-schema'
   specification where more-schema must be a sequence schema.</p>

<p>   Currently function schemas are purely descriptive; there is no validation except for
   functions defined directly by s/fn or s/defn</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro =&gt;*
  [output-schema &amp; arity-schema-specs]
  `(make-fn-schema ~output-schema ~(mapv macros/parse-arity-spec arity-schema-specs)))</pre></td></tr><tr><td class="docs"><p>Convenience macro for defining function schemas with a single arity; like =>*, but
   there is no vector around the argument schemas for this arity.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro =&gt;
  [output-schema &amp; arg-schemas]
  `(=&gt;* ~output-schema ~(vec arg-schemas)))</pre></td></tr><tr><td class="docs"><p>Helpers for defining schemas (used in in-progress work, explanation coming soon)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Records name in schema's metadata.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn schema-with-name
  [schema name]
  (vary-meta schema assoc :name name))</pre></td></tr><tr><td class="docs"><p>Returns the name of a schema attached via schema-with-name (or defschema).</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn schema-name
  [schema]
  (-&gt; schema meta :name))</pre></td></tr><tr><td class="docs"><p>Returns the namespace of a schema attached via defschema.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn schema-ns
  [schema]
  (-&gt; schema meta :ns))</pre></td></tr><tr><td class="docs"><p>Convenience macro to make it clear to reader that body is meant to be used as a schema.
   The name of the schema is recorded in the metadata.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defschema
  ([name form]
     `(defschema ~name &quot;&quot; ~form))
  ([name docstring form]
     `(def ~name ~docstring
        (vary-meta
         (schema-with-name ~form '~name)
         assoc :ns '~(ns-name *ns*)))))</pre></td></tr><tr><td class="docs"><p>Schematized defrecord and (de,let)fn macros</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Define a record with a schema.</p>

<p>   In addition to the ordinary behavior of defrecord, this macro produces a schema
   for the Record, which will automatically be used when validating instances of
   the Record class:</p>

<p>   (m/defrecord FooBar
    [foo :- Int
     bar :- String])</p>

<p>   (schema.utils/class-schema FooBar)
   ==> (record user.FooBar {:foo Int, :bar java.lang.String})</p>

<p>   (s/check FooBar (FooBar. 1.2 :not-a-string))
   ==> {:foo (not (integer? 1.2)), :bar (not (instance? java.lang.String :not-a-string))}</p>

<p>   See (doc schema.core) for details of the :- syntax for record elements.</p>

<p>   Moreover, optional arguments extra-key-schema? and extra-validator-fn? can be
   passed to augment the record schema.
    - extra-key-schema is a map schema that defines validation for additional
      key-value pairs not in the record base (the default is to not allow extra
       mappings).
    - extra-validator-fn? is an additional predicate that will be used as part
      of validating the record value.</p>

<p>   The remaining opts+specs (i.e., protocol and interface implementations) are
   passed through directly to defrecord.</p>

<p>   Finally, this macro replaces Clojure's map->name constructor with one that is
   more than an order of magnitude faster (as of Clojure 1.5), and provides a
   new strict-map->name constructor that throws or drops extra keys not in the
   record base.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defrecord
  {:arglists '([name field-schema extra-key-schema? extra-validator-fn? &amp; opts+specs])}
  [name field-schema &amp; more-args]
  (apply macros/emit-defrecord 'clojure.core/defrecord &amp;env name field-schema more-args))</pre></td></tr><tr><td class="docs"><p>DEPRECATED -- canonical version moved to schema.potemkin
   Like defrecord, but emits a record using potemkin/defrecord+.  You must provide
   your own dependency on potemkin to use this.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defrecord+
  {:arglists '([name field-schema extra-key-schema? extra-validator-fn? &amp; opts+specs])}
  [name field-schema &amp; more-args]
  (apply macros/emit-defrecord 'potemkin/defrecord+ &amp;env name field-schema more-args))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro set-compile-fn-validation!
  [on?]
  (macros/set-compile-fn-validation! on?)
  nil)</pre></td></tr><tr><td class="docs"><p>Get the current global schema validation setting.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn fn-validation?
  []
  (.get_cell utils/use-fn-validation))</pre></td></tr><tr><td class="docs"><p>Globally turn on (or off) schema validation for all s/fn and s/defn instances.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn set-fn-validation!
  [on?]
  (.set_cell utils/use-fn-validation on?))</pre></td></tr><tr><td class="docs"><p>Execute body with input and output schema validation turned on for
   all s/defn and s/fn instances globally (across all threads). After
   all forms have been executed, resets function validation to its
   previously set value. Not concurrency-safe.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-fn-validation
  [&amp; body]
  `(let [body# (fn [] ~@body)]
     (if (fn-validation?)
       (body#)
       (do
         (set-fn-validation! true)
         (try (body#) (finally (set-fn-validation! false)))))))</pre></td></tr><tr><td class="docs"><p>Execute body with input and output schema validation turned off for
   all s/defn and s/fn instances globally (across all threads). After
   all forms have been executed, resets function validation to its
   previously set value. Not concurrency-safe.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro without-fn-validation
  [&amp; body]
  `(let [body# (fn [] ~@body)]
     (if (fn-validation?)
       (do
         (set-fn-validation! false)
         (try (body#) (finally (set-fn-validation! true))))
       (body#))))</pre></td></tr><tr><td class="docs"><p>Attach the schema to fn f at runtime, extractable by fn-schema.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn schematize-fn
  [f schema]
  (vary-meta f assoc :schema schema))</pre></td></tr><tr><td class="docs"><p>Produce the schema for a function defined with s/fn or s/defn.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn ^FnSchema fn-schema
  [f]
  (macros/assert! (fn? f) &quot;Non-function %s&quot; (utils/type-of f))
  (or (utils/class-schema (utils/fn-schema-bearer f))
      (macros/safe-get (meta f) :schema)))</pre></td></tr><tr><td class="docs"><p>work around bug in extend-protocol (refers to bare 'fn, so we can't exclude it).</p>
</td><td class="codes"><pre class="brush: clojure">      (when-not clj-1195-fixed? (ns-unmap *ns* 'fn))</pre></td></tr><tr><td class="docs"><p>s/fn : s/defn :: clojure.core/fn : clojure.core/defn</p>

<p>   See (doc s/defn) for details.</p>

<p>   Additional gotchas and limitations:
    - Like s/defn, the output schema must go on the fn name. If you
      don't supply a name, schema will gensym one for you and attach
      the schema.
    - Unlike s/defn, the function schema is stored in metadata on the
      fn.  Clojure's implementation for metadata on fns currently
      produces a wrapper fn, which will decrease performance and
      negate the benefits of primitive type hints compared to
      clojure.core/fn.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro fn
  [&amp; fn-args]
  (let [fn-args (if (symbol? (first fn-args))
                  fn-args
                  (cons (gensym &quot;fn&quot;) fn-args))
        [name more-fn-args] (macros/extract-arrow-schematized-element &amp;env fn-args)
        {:keys [outer-bindings schema-form fn-body]} (macros/process-fn- &amp;env name more-fn-args)]
    `(let ~outer-bindings
       (schematize-fn
        ~(vary-meta `(clojure.core/fn ~name ~@fn-body) #(merge (meta &amp;form) %))
        ~schema-form))))</pre></td></tr><tr><td class="docs"><p>Like clojure.core/defn, except that schema-style typehints can be given on
   the argument symbols and on the function name (for the return value).</p>

<p>   You can call s/fn-schema on the defined function to get its schema back, or
   use with-fn-validation to enable runtime checking of function inputs and
   outputs.</p>

<p>   (s/defn foo :- s/Num
    [x :- s/Int
     y :- s/Num]
    (* x y))</p>

<p>   (s/fn-schema foo)
   ==> (=> java.lang.Number Int java.lang.Number)</p>

<p>   (s/with-fn-validation (foo 1 2))
   ==> 2</p>

<p>   (s/with-fn-validation (foo 1.5 2))
   ==> Input to foo does not match schema: [(named (not (integer? 1.5)) x) nil]</p>

<p>   See (doc schema.core) for details of the :- syntax for arguments and return
   schemas.</p>

<p>   The overhead for checking if run-time validation should be used is very
   small -- about 5% of a very small fn call.  On top of that, actual
   validation costs what it costs.</p>

<p>   You can also turn on validation unconditionally for this fn only by
   putting ^:always-validate metadata on the fn name.</p>

<p>   Gotchas and limitations:
    - The output schema always goes on the fn name, not the arg vector. This
      means that all arities must share the same output schema. Schema will
      automatically propagate primitive hints to the arg vector and class hints
      to the fn name, so that you get the behavior you expect from Clojure.
    - All primitive schemas will be passed through as type hints to Clojure,
      despite their legality in a particular position.  E.g.,
        (s/defn foo [x :- int])
      will fail because Clojure does not allow primitive ints as fn arguments;
      in such cases, use the boxed Classes instead (e.g., Integer).
    - Schema metadata is only processed on top-level arguments.  I.e., you can
      use destructuring, but you must put schema metadata on the top-level
      arguments, not the destructured variables.</p>

<pre><code>  Bad:  (s/defn foo [{:keys [x :- s/Int]}])
  Good: (s/defn foo [{:keys [x]} :- {:x s/Int}])
- Only a specific subset of rest-arg destructuring is supported:
  - &amp; rest works as expected
  - &amp; [a b] works, with schemas for individual elements parsed out of the binding,
    or an overall schema on the vector
  - &amp; {} is not supported.
- Unlike clojure.core/defn, a final attr-map on multi-arity functions
  is not supported.
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defmacro defn
  [&amp; defn-args]
  (let [[name &amp; more-defn-args] (macros/normalized-defn-args &amp;env defn-args)
        {:keys [doc tag] :as standard-meta} (meta name)
        {:keys [outer-bindings schema-form fn-body arglists raw-arglists]} (macros/process-fn- &amp;env name more-defn-args)]
    `(let ~outer-bindings
       (let [ret# (clojure.core/defn ~(with-meta name {})
                    ~(assoc (apply dissoc standard-meta (when (macros/primitive-sym? tag) [:tag]))
                       :doc (str
                             (str &quot;Inputs: &quot; (if (= 1 (count raw-arglists))
                                               (first raw-arglists)
                                               (apply list raw-arglists)))
                             (when-let [ret (when (= (second defn-args) :-) (nth defn-args 2))]
                               (str &quot;\n  Returns: &quot; ret))
                             (when doc (str  &quot;\n\n  &quot; doc)))
                       :raw-arglists (list 'quote raw-arglists)
                       :arglists (list 'quote arglists)
                       :schema schema-form)
                    ~@fn-body)]
         (utils/declare-class-schema! (utils/fn-schema-bearer ~name) ~schema-form)
         ret#))))</pre></td></tr><tr><td class="docs"><p>Like clojure.core/defmethod, except that schema-style typehints can be given on
   the argument symbols and after the dispatch-val (for the return value).</p>

<p>   See (doc s/defn) for details.</p>

<p>   Examples:</p>

<pre><code> (s/defmethod mymultifun :a-dispatch-value :- s/Num [x :- s/Int y :- s/Num] (* x y))

 ;; You can also use meta tags like ^:always-validate by placing them
 ;; before the multifunction name:

 (s/defmethod ^:always-validate mymultifun :a-dispatch-value [x y] (* x y))
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defmacro defmethod
  [multifn dispatch-val &amp; fn-tail]
  `(macros/if-cljs
    (cljs.core/-add-method
     ~(with-meta multifn {:tag 'cljs.core/MultiFn})
     ~dispatch-val
     (fn ~(with-meta (gensym) (meta multifn)) ~@fn-tail))
    (. ~(with-meta multifn {:tag 'clojure.lang.MultiFn})
       addMethod
       ~dispatch-val
       (fn ~(with-meta (gensym) (meta multifn)) ~@fn-tail))))</pre></td></tr><tr><td class="docs"><p>s/letfn : s/fn :: clojure.core/letfn : clojure.core/fn</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro letfn
  [fnspecs &amp; body]
  (list `let
        (vec (interleave (map first fnspecs)
                         (map #(cons `fn %) fnspecs)))
        `(do ~@body)))</pre></td></tr><tr><td class="docs"><p>Like def, but takes a schema on the var name (with the same format
   as the output schema of s/defn), requires an initial value, and
   asserts that the initial value matches the schema on the var name
   (regardless of the status of with-fn-validation).  Due to
   limitations of add-watch!, cannot enforce validation of subsequent
   rebindings of var.  Throws at compile-time for clj, and client-side
   load-time for cljs.</p>

<p>   Example:</p>

<p>   (s/def foo :- long "a long" 2)</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro def
  [&amp; def-args]
  (let [[name more-def-args] (macros/extract-arrow-schematized-element &amp;env def-args)
        [doc-string? more-def-args] (if (= (count more-def-args) 2)
                                      (macros/maybe-split-first string? more-def-args)
                                      [nil more-def-args])
        init (first more-def-args)]
    (macros/assert! (= 1 (count more-def-args)) &quot;Illegal args passed to schema def: %s&quot; def-args)
    `(let [output-schema# ~(macros/extract-schema-form name)]
       (def ~name
         ~@(when doc-string? [doc-string?])
         (validate output-schema# ~init)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* false)</pre></td></tr><tr><td class="docs"><p>Sets the maximum length of value to be output before it is contracted to a prettier name.</p>
</td><td class="codes"><pre class="brush: clojure">(clojure.core/defn set-max-value-length!
  [max-length]
  (reset! utils/max-value-length max-length))</pre></td></tr><tr><td class="docs"><p>This file autogenerated from src/cljx/schema/core.cljx</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.core-test" name="schema.core-test"><h1 class="project-name">schema.core-test</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Tests for schema.</p>

<p>   Uses helpers defined in schema.test-macros (for cljs sake):
    - (valid! s x) asserts that (s/check s x) returns nil
    - (invalid! s x) asserts that (s/check s x) returns a validation failure
      - The optional last argument also checks the printed Clojure representation of the error.
    - (invalid-call! s x) asserts that calling the function throws an error.</p>
</td><td class="codes"><pre class="brush: clojure">(ns schema.core-test
        (:use clojure.test [schema.test-macros :only [valid! invalid! invalid-call!]])
  (:require
   clojure.data
   [schema.utils :as utils]
   [schema.core :as s]
   [schema.spec.core :as spec]
   [schema.spec.collection :as collection]
         [schema.macros :as macros]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest if-cljs-test
  (is (=                   false (macros/if-cljs true false))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest try-catchall-test
  (let [a (atom 0)]
    (is (= 2 (macros/try-catchall (reset! a 1) (swap! a inc) (catch e (swap! a - 10)))))
    (is (= 2 @a)))
  (let [a (atom 0)]
    (is (= -9 (macros/try-catchall (reset! a 1) (swap! a #(throw (macros/error! (str %)))) (catch e (swap! a - 10)))))
    (is (= -9 @a))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest validate-return-test
  (is (= 1 (s/validate s/Int 1))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn foo-bar [])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest fn-name-test
  (is (= &quot;odd?&quot; (utils/fn-name odd?)))
  (is (=       &quot;schema.core-test/foo-bar&quot;                 
         (utils/fn-name foo-bar)))
        (is (= &quot;schema.core-test$fn&quot; (subs (utils/fn-name (fn foo [x] (+ x x))) 0 19))))</pre></td></tr><tr><td class="docs"><p>Platform-specific leaf Schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(do
  (deftest class-test
    (valid! String &quot;a&quot;)
    (invalid! String nil &quot;(not (instance? java.lang.String nil))&quot;)
    (invalid! String :a &quot;(not (instance? java.lang.String :a))&quot;))
  (deftest primitive-test
    (valid! double 1.0)
    (invalid! double (float 1.0) &quot;(not (instance? java.lang.Double 1.0))&quot;)
    (valid! float (float 1.0))
    (invalid! float 1.0)
    (valid! long 1)
    (invalid! long (byte 1))
    (valid! boolean true)
    (invalid! boolean 1)
    (valid! longs (long-array 10))
    (invalid! longs (int-array 10))
    (doseq [f [byte char short int]]
      (valid! f (f 1))
      (invalid! f 1))
    (is (= 'double (s/explain double))))
  (deftest array-test
    (valid! (Class/forName&quot;[Ljava.lang.String;&quot;) (into-array String [&quot;a&quot;]))
    (invalid! (Class/forName &quot;[Ljava.lang.Long;&quot;) (into-array String [&quot;a&quot;]))
    (valid! (Class/forName &quot;[Ljava.lang.Double;&quot;) (into-array Double [1.0]))
    (valid! (Class/forName &quot;[D&quot;) (double-array [1.0]))
    (invalid! (Class/forName &quot;[D&quot;) (into-array Double [1.0]))
    (valid! doubles (double-array [1.0]))
    (is (= 'doubles (s/explain doubles)))))</pre></td></tr><tr><td class="docs"><p>Cross-platform Schema leaves</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest any-test
  (valid! s/Any 10)
  (valid! s/Any nil)
  (valid! s/Any :whatever)
  (is (= 'Any (s/explain s/Any))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest eq-test
  (let [schema (s/eq 10)]
    (valid! schema 10)
    (invalid! schema 9 &quot;(not (= 10 9))&quot;)
    (is (= '(eq 10) (s/explain schema)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest isa-test
  (let [h (make-hierarchy)
        h (derive h ::square ::shape)
        schema (s/isa h ::shape)]
    (valid! schema ::square)
    (invalid! schema ::form)
    (valid! (s/isa java.lang.Number) java.lang.Long)
    (is (= '(isa? ::shape) (s/explain schema)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest enum-test
  (let [schema (s/enum :a :b 1)]
    (valid! schema :a)
    (valid! schema 1)
    (invalid! schema :c)
    (invalid! (s/enum :a) 2 &quot;(not (#{:a} 2))&quot;)
    (is (= '(1 :a :b enum) (sort-by str (s/explain schema))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest pred-test
  (let [schema (s/pred odd? 'odd?)]
    (valid! schema 1)
    (invalid! schema 2 &quot;(not (odd? 2))&quot;)
    (invalid! schema :foo &quot;(throws? (odd? :foo))&quot;)
    (is (= '(pred odd?) (s/explain schema)))
    (invalid! (s/pred odd?) 2 &quot;(not (odd? 2))&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol ATestProtocol)</pre></td></tr><tr><td class="docs"><p>Compile the schema before extending, make sure it works as expected</p>
</td><td class="codes"><pre class="brush: clojure">(s/defn ^:always-validate a-test-protocol-fn
  [x :- (s/protocol ATestProtocol)]
  x)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord DirectTestProtocolSatisfier [] ATestProtocol)
(defrecord IndirectTestProtocolSatisfier []) (extend-type IndirectTestProtocolSatisfier ATestProtocol)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord IndirectTestProtocolSatisfier []) (extend-type IndirectTestProtocolSatisfier ATestProtocol)
(defrecord NonTestProtocolSatisfier [])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest protocol-test
  (let [schema (s/protocol ATestProtocol)]
    (valid! schema (DirectTestProtocolSatisfier.))
    (valid! schema (IndirectTestProtocolSatisfier.))
    (invalid! schema (NonTestProtocolSatisfier.))
    (invalid! schema nil)
    (invalid! schema 117 &quot;(not (satisfies? ATestProtocol 117))&quot;)
    (is (a-test-protocol-fn (DirectTestProtocolSatisfier.)))
    (is (a-test-protocol-fn (IndirectTestProtocolSatisfier.)))
    (invalid-call! a-test-protocol-fn (NonTestProtocolSatisfier.))
    (is (= '(protocol ATestProtocol) (s/explain schema)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest regex-test
  (valid! #&quot;lex&quot; &quot;Alex B&quot;)
  (valid! #&quot;lex&quot; &quot;lex&quot;)
  (invalid! #&quot;lex&quot; nil &quot;(not (string? nil))&quot;)
  (invalid! #&quot;lex&quot; &quot;Ale&quot; &quot;(not (re-find #\&quot;lex\&quot; \&quot;Ale\&quot;))&quot;)
  (is (= (symbol &quot;#\&quot;lex\) (s/explain #&quot;lex&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest leaf-bool-test
  (valid! s/Bool true)
  (invalid! s/Bool nil &quot;(not (instance? java.lang.Boolean nil))&quot;)
  (is (= 'Bool (s/explain s/Bool))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest leaf-string-test
  (valid! s/Str &quot;asdf&quot;)
  (invalid! s/Str nil &quot;(not (instance? java.lang.String nil))&quot;)
  (invalid! s/Str :a &quot;(not (instance? java.lang.String :a))&quot;)
  (is (= 'Str (s/explain s/Str))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest leaf-number-test
  (valid! s/Num 1)
  (valid! s/Num 1.2)
  (valid! s/Num (/ 1 2))
  (invalid! s/Num nil &quot;(not (instance? java.lang.Number nil))&quot;)
  (invalid! s/Num &quot;1&quot; &quot;(not (instance? java.lang.Number \&quot;1\&quot;))&quot;)
  (is (= 'Num (s/explain s/Num))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest leaf-int-test
  (valid! s/Int 1)
  (invalid! s/Int 1.2 &quot;(not (integer? 1.2))&quot;)
        (invalid! s/Int 1.0 &quot;(not (integer? 1.0))&quot;)
  (invalid! s/Int nil &quot;(not (integer? nil))&quot;)
  (is (= 'Int (s/explain s/Int))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest leaf-keyword-test
  (valid! s/Keyword :a)
  (valid! s/Keyword ::a)
  (invalid! s/Keyword nil &quot;(not (keyword? nil))&quot;)
  (invalid! s/Keyword &quot;:a&quot; &quot;(not (keyword? \&quot;:a\&quot;))&quot;)
  (is (= 'Keyword (s/explain s/Keyword))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest leaf-symbol-test
  (valid! s/Symbol 'foo)
  (invalid! s/Symbol nil &quot;(not (symbol? nil))&quot;)
  (invalid! s/Symbol &quot;'a&quot; &quot;(not (symbol? \&quot;'a\&quot;))&quot;)
  (is (= 'Symbol (s/explain s/Symbol))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest leaf-regex-test
  (valid! s/Regex #&quot;.*&quot;)
  (invalid! s/Regex &quot;.*&quot;)
  (is (= 'Regex (s/explain s/Regex))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest leaf-inst-test
  (valid! s/Inst #inst &quot;2013-01-01T01:15:01.840-00:00&quot;)
  (invalid! s/Inst &quot;2013-01-01T01:15:01.840-00:00&quot;)
  (is (= 'Inst (s/explain s/Inst))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest leaf-uuid-test
  (valid! s/Uuid #uuid &quot;0e98ce5b-9aca-4bf7-b5fd-d90576c80fdf&quot;)
  (invalid! s/Uuid &quot;0e98ce5b-9aca-4bf7-b5fd-d90576c80fdf&quot;)
  (is (= 'Uuid (s/explain s/Uuid))))</pre></td></tr><tr><td class="docs"><p>Simple composite Schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest maybe-test
  (let [schema (s/maybe s/Int)]
    (valid! schema nil)
    (valid! schema 1)
    (invalid! schema 1.1 &quot;(not (integer? 1.1))&quot;)
    (is (= '(maybe Int) (s/explain schema)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest named-test
  (let [schema (s/named s/Int :score)]
    (valid! schema 12)
    (invalid! schema :a &quot;(named (not (integer? :a)) :score)&quot;)
    (is (= '(named Int :score) (s/explain schema)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest either-test
  (let [schema (s/either
                {:num s/Int}
                {:str s/Str})]
    (valid! schema {:num 1})
    (valid! schema {:str &quot;hello&quot;})
    (invalid! schema {:num &quot;bad!&quot;})
    (invalid! schema {:str 1})
    (is (= '(either {:a Int} Int) (s/explain (s/either {:a s/Int} s/Int))))
    (is (s/explain schema))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest both-test
  (let [schema (s/both
                (s/pred (fn equal-keys? [m] (every? (fn [[k v]] (= k v)) m)) 'equal-keys?)
                {s/Keyword s/Keyword})]
    (valid! schema {})
    (valid! schema {:foo :foo :bar :bar})
    (invalid! schema {&quot;foo&quot; &quot;foo&quot;})
    (invalid! schema {:foo :bar} &quot;(not (equal-keys? {:foo :bar}))&quot;)
    (invalid! schema {:foo 1} &quot;(not (equal-keys? {:foo 1}))&quot;)
    (is (= '(both (pred vector?) [Int])
           (s/explain (s/both (s/pred vector? 'vector?) [s/Int]))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest conditional-test
  (let [schema (s/conditional #(= (:type %) :foo) {:type (s/eq :foo) :baz s/Num}
                              #(= (:type %) :bar) {:type (s/eq :bar) :baz s/Str})]
    (valid! schema {:type :foo :baz 10})
    (valid! schema {:type :bar :baz &quot;10&quot;})
    (invalid! schema {:type :foo :baz &quot;10&quot;})
    (invalid! schema {:type :bar :baz 10} &quot;{:baz (not (instance? java.lang.String 10))}&quot;)
    (invalid! schema {:type :zzz :baz 10}
              &quot;(not (some-matching-condition? a-clojure.lang.PersistentArrayMap))&quot;)
    (is (s/explain schema)))
  (testing &quot;as simple constraint&quot;
    (let [schema (s/conditional
                  (fn [m] (every? (fn [[k v]] (= k v)) m))
                  {s/Keyword s/Keyword}
                  'equal-keys?)]
      (valid! schema {})
      (valid! schema {:foo :foo :bar :bar})
      (invalid! schema {&quot;foo&quot; &quot;foo&quot;})
      (invalid! schema {:foo :bar} &quot;(not (equal-keys? {:foo :bar}))&quot;)
      (invalid! schema {:foo 1} &quot;(not (equal-keys? {:foo 1}))&quot;)
      (invalid! (s/conditional odd? s/Int) 2 &quot;(not (odd? 2))&quot;)
      (invalid! (s/conditional odd? s/Int) &quot;1&quot; &quot;(throws? (odd? \&quot;1\&quot;))&quot;)
      (is (= '(conditional odd? Int)
             (s/explain (s/conditional odd? s/Int))))
      (is (= '(conditional odd? Int weird?)
             (s/explain (s/conditional odd? s/Int 'weird?)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest cond-pre-test
  (let [s (s/cond-pre
           s/Int
           (s/maybe s/Str)
           (s/cond-pre s/Keyword {:x s/Int})
           (s/both [s/Num] (s/pred (fn [xs] (even? (count xs))) 'even-len?))
           [s/Str])]
    (valid! s 1)
    (valid! s &quot;hello&quot;)
    (valid! s nil)
    (valid! s :hello)
    (valid! s {:x 3})
    (valid! s [1 2])
    (valid! s [&quot;hello&quot;])
    (invalid! s 3.14)
    (invalid! s [1 2 3])
    (invalid! s {:x 3.14})
    (invalid! s [1 2 3])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest constrained-test
  (let [s (s/constrained s/Int odd?)]
    (is (= '(constrained Int odd?) (s/explain s)))
    (valid! s 1)
    (valid! s 5)
    (invalid! s 2 &quot;(not (odd? 2))&quot;)
    (invalid! s &quot;2&quot; &quot;(not (integer? \&quot;2\&quot;))&quot;)
    (invalid! (s/constrained s/Str odd?) &quot;2&quot; &quot;(throws? (odd? \&quot;2\&quot;))&quot; ))
  (let [s (s/constrained {:a s/Int} #(odd? (:a %)))]
    (valid! s {:a 1})
    (invalid! s {:b 1})
    (invalid! s {:a 2})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest if-test
  (let [schema (s/if #(= (:type %) :foo)
                 {:type (s/eq :foo) :baz s/Num}
                 {:type (s/eq :bar) :baz s/Str})]
    (valid! schema {:type :foo :baz 10})
    (valid! schema {:type :bar :baz &quot;10&quot;})
    (invalid! schema {:type :foo :baz &quot;10&quot;})
    (invalid! schema {:type :bar :baz 10})
    (invalid! schema {:type :zzz :baz 10})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def NestedVecs
  [(s/one s/Num &quot;Node ID&quot;)
   (s/recursive #'NestedVecs)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def NestedMaps
  {:node-id s/Num
   (s/optional-key :children) [(s/recursive #'NestedMaps)]})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare TestBlackNode)
(def TestRedNode {(s/optional-key :red) (s/recursive #'TestBlackNode)})
(def TestBlackNode {:black TestRedNode})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest recursive-test
  (valid! NestedVecs [1 [2 [3 [4]]]])
  (invalid! NestedVecs [1 [2 [&quot;invalid-id&quot; [4]]]])
  (invalid! NestedVecs [1 [2 [3 &quot;invalid-content&quot;]]])
  (valid! NestedMaps
          {:node-id 1
           :children [{:node-id 1
                       :children [{:node-id 4}]}
                      {:node-id 3}]})
  (invalid! NestedMaps
            {:node-id 1
             :children [{:invalid-node-id 1
                         :children [{:node-id 4}]}
                        {:node-id 3}]})
  (invalid! NestedMaps
            {:node-id 1
             :children [{:node-id 1
                         :children [{:node-id 4}]}
                        {:node-id &quot;invalid-id&quot;}]})
  (valid! TestBlackNode {:black {}})
  (valid! TestBlackNode {:black {:red {:black {}}}})
  (invalid! TestBlackNode {:black {:black {}}})
  (invalid! TestBlackNode {:black {:red {}}})
  (let [rec (atom nil)
        schema {(s/optional-key :x) (s/recursive rec)}]
    (reset! rec schema)
    (valid! schema {})
    (valid! schema {:x {:x {:x {}}}})
    (invalid! schema {:x {:x {:y {}}}})
    (let [explanation (first (s/explain schema))]
      (is (= '(optional-key :x) (key explanation)))
            (is (= 'recursive (first (val explanation))))
            (is (re-matches #&quot;clojure.lang.Atom.*&quot; (second (val explanation))))))
  (is (= '{:black {(optional-key :red) (recursive (var schema.core-test/TestBlackNode))}}
         (s/explain TestBlackNode))))</pre></td></tr><tr><td class="docs"><p>Atom schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest atom-test
  (let [s (s/atom s/Str)]
    (is (not (s/check s (atom &quot;asdf&quot;)))) ;; don't expect identity after walking
    (invalid! s (delay &quot;asdf&quot;) &quot;(not (atom? a-clojure.lang.Delay))&quot;)
    (invalid! s (atom 1))))</pre></td></tr><tr><td class="docs"><p>Map Schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest uniform-map-test
  (let [schema {s/Keyword s/Int}]
    (valid! schema {})
    (valid! schema {:a 1 :b 2})
    (invalid! schema {'a 1 :b 2} &quot;{(not (keyword? a)) invalid-key}&quot;)
    (invalid! schema {:a :b} &quot;{:a (not (integer? :b))}&quot;)
    (is (= '{Keyword Int} (s/explain {s/Keyword s/Int})))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest simple-specific-key-map-test
  (let [schema-args [:foo s/Keyword :bar s/Int]]
    (doseq [[t schema] {&quot;hash-map&quot; (apply hash-map schema-args)
                        &quot;array-map&quot; (apply array-map schema-args)}]
      (testing t
        (valid! schema {:foo :a :bar 2})
        (invalid! schema [[:foo :a] [:bar 2]] &quot;(not (map? a-clojure.lang.PersistentVector))&quot;)
        (invalid! schema {:foo :a} &quot;{:bar missing-required-key}&quot;)
        (invalid! schema {:foo :a :bar 2 :baz 1} &quot;{:baz disallowed-key}&quot;)
        (invalid! schema {:foo :a :bar 1.5} &quot;{:bar (not (integer? 1.5))}&quot;)
        (is (= '{:foo Keyword, :bar Int} (s/explain schema)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest fancier-map-schema-test
  (let [schema {:foo s/Int
                s/Str s/Num}]
    (valid! schema {:foo 1})
    (valid! schema {:foo 1 &quot;bar&quot; 2.0})
    (valid! schema {:foo 1 &quot;bar&quot; 2.0 &quot;baz&quot; 10.0})
    (invalid! schema {:foo 1 :bar 2.0})
    (invalid! schema {:foo 1 :bar 2.0})
    (invalid! schema {:foo 1 :bar 2.0 &quot;baz&quot; 2.0})
    (invalid! schema {:foo 1 &quot;bar&quot; &quot;a&quot;})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest another-fancy-map-schema-test
  (let [schema {:foo (s/maybe s/Int)
                (s/optional-key :bar) s/Num
                :baz {:b1 (s/pred odd?)}
                s/Keyword s/Any}]
    (valid! schema {:foo 1 :bar 1.0 :baz {:b1 3}})
    (valid! schema {:foo 1 :baz {:b1 3}})
    (valid! schema {:foo nil :baz {:b1 3}})
    (valid! schema {:foo nil :baz {:b1 3} :whatever &quot;whatever&quot;})
    (invalid! schema {:foo 1 :bar 1.0 :baz [[:b1 3]]})
    (invalid! schema {:foo 1 :bar 1.0 :baz {:b2 3}})
    (invalid! schema {:foo 1 :bar 1.0 :baz {:b1 4}})
    (invalid! schema {:bar 1.0 :baz {:b1 3}})
    (invalid! schema {:foo 1 :bar nil :baz {:b1 3}})
    (invalid! schema {:foo 1 :bar &quot;z&quot; :baz {:b1 3}})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest throw-on-multiple-key-variants-test
  (is (thrown? Exception (s/checker {:foo s/Str (s/optional-key :foo) s/Str})))
  (is (thrown? Exception (s/checker {(s/required-key &quot;A&quot;) s/Str (s/optional-key &quot;A&quot;) s/Str}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol SomeProtocol
  (stuff [this]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord SomeRecord [x y z]
  SomeProtocol
  (stuff [_] x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest keys-and-protocol-test
  (let [field-subset {:x s/Keyword :y s/Num s/Keyword s/Any}
        schema (s/conditional #(satisfies? SomeProtocol %) field-subset)]
    (is (not (s/check schema (-&gt;SomeRecord :foo 42 &quot;extra&quot;)))) ;; comes out as map
    (invalid! schema {:x :foo :y 42})))</pre></td></tr><tr><td class="docs"><p>Handle Struct</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(do (defstruct ts1 :num :str :map :vec)
    (defstruct ts2 :num :str)
    (deftest struct-tests
      (let [schema {(s/required-key :num) s/Num
                    (s/required-key :str) s/Str
                    (s/required-key :map) {s/Keyword s/Str}
                    (s/required-key :vec) [s/Num]
                    (s/optional-key :opt) s/Num}]
        (valid! schema (struct ts1 1 &quot;str&quot; {:key &quot;str&quot;} [1]))
        (valid! schema {:num 1 :str &quot;str&quot; :map {:key &quot;str&quot;} :vec [1]})
        (valid! schema (struct ts1 1 &quot;str&quot; (struct ts1 &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;) [1]))
        (valid! schema (assoc (struct ts1 1 &quot;str&quot; {:key &quot;str&quot;} [1])
                         :opt 1))
        (valid! schema (assoc (struct ts2 1 &quot;str&quot;)
                         :map {}
                         :vec []))
        (invalid! schema (struct ts1 &quot;str&quot; &quot;str&quot; {:key &quot;str&quot;} [1]))
        (invalid! schema (struct ts1 1 1 {:key &quot;str&quot;} [1]))
        (invalid! schema (struct ts1 1 &quot;str&quot; {&quot;str&quot; &quot;str&quot;} [1]))
        (invalid! schema (struct ts1 1 &quot;str&quot; {:key 1} [1]))
        (invalid! schema (struct ts1 1 &quot;str&quot; {:key &quot;str&quot;} 1))
        (invalid! schema (struct ts1 1 &quot;str&quot; {:key &quot;str&quot;} [&quot;str&quot;]))
        (invalid! schema (assoc (struct ts1 1 &quot;str&quot; {:key &quot;str&quot;} [1])
                           :opt &quot;str&quot;))
        (invalid! schema (assoc (struct ts1 1 &quot;str&quot; {:key &quot;str&quot;} [1])
                           :extra-key 1))
        (invalid! schema (struct ts2 1 &quot;str&quot;))
        (invalid! schema (assoc (struct ts2 1 &quot;str&quot;)
                           :map {:key 1}
                           :vec [])))))</pre></td></tr><tr><td class="docs"><p>Set Schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest simple-set-test
  (testing &quot;set schemas must have exactly one entry&quot;
    (is (thrown? Exception (s/check #{s/Int s/Num} #{})))
    (is (thrown? Exception (s/check #{} #{}))))
  (testing &quot;basic set identification&quot;
    (let [schema #{s/Keyword}]
      (valid! schema #{:a :b :c})
      (invalid! schema [:a :b :c] &quot;(not (set? [:a :b :c]))&quot;)
      (invalid! schema {:a :a :b :b})
      (is (= '#{Keyword} (s/explain schema)))))
  (testing &quot;enforces matching with single simple entry&quot;
    (let [schema #{s/Int}]
      (valid! schema #{})
      (valid! schema #{1 2 3})
      (invalid! schema #{1 :a} &quot;#{(not (integer? :a))}&quot;)
      (invalid! schema #{:a &quot;c&quot; {}})))
  (testing &quot;more complex element schema&quot;
    (let [schema #{[s/Int]}]
      (valid! schema #{})
      (valid! schema #{[2 4] [3 6]})
      (invalid! schema #{2})
      (invalid! schema #{[[2 3]]}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest mixed-set-test
  (let [schema #{(s/either [s/Int] #{s/Int})}]
    (valid! schema #{})
    (valid! schema #{[3 4] [56 1] [-11 3]})
    (valid! schema #{#{3 4} #{56 1} #{-11 3}})
    (valid! schema #{[3 4] #{56 1} #{-11 3}})
    (invalid! schema #{#{[3 4]}})
    (invalid! schema #{[[3 4]]})))</pre></td></tr><tr><td class="docs"><p>Queue Schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest queue-test
  (testing &quot;queues of simple values&quot;
    (let [schema (s/queue s/Int)]
      (valid! schema (s/as-queue []))
      (valid! schema (s/as-queue [1]))
      (valid! schema (s/as-queue [1 2 3 4]))
      (invalid! schema [1 2 3])
      (invalid! schema (s/as-queue [1 :a 3])))))</pre></td></tr><tr><td class="docs"><p>Sequence Schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest simple-repeated-seq-test
  (let [schema [s/Int]]
    (valid! schema [])
    (valid! schema [1 2 3])
    (invalid! schema {})
          (invalid! schema [1 2 1.0])
    (invalid! schema [1 2 1.1])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest simple-one-seq-test
  (let [schema [(s/one s/Int &quot;int&quot;) (s/one s/Str &quot;str&quot;)]]
    (valid! schema [1 &quot;a&quot;])
    (invalid! schema [1])
    (invalid! schema [1 1.0 2])
    (invalid! schema [1 1])
    (invalid! schema [1.0 1.0])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest optional-seq-test
  (let [schema [(s/one s/Int &quot;int&quot;)
                (s/optional s/Str &quot;str&quot;)
                (s/optional s/Int &quot;int2&quot;)]]
    (valid! schema [1])
    (valid! schema [1 &quot;a&quot;])
    (valid! schema [1 &quot;a&quot; 2])
    (invalid! schema [])
    (invalid! schema [1 &quot;a&quot; 2 3])
    (invalid! schema [1 1])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest combo-seq-test
  (let [schema [(s/one (s/maybe s/Int) :maybe-long)
                (s/optional s/Keyword :key)
                s/Int]]
    (valid! schema [1])
    (valid! schema [1 :a])
    (valid! schema [1 :a 1 2 3])
    (valid! schema [nil :b 1 2 3])
    (invalid! schema {} &quot;(not (sequential? {}))&quot;)
    (invalid! schema &quot;asdf&quot; &quot;(not (sequential? \&quot;asdf\&quot;))&quot;)
    (invalid! schema [nil 1 1 2 3] &quot;[nil (named (not (keyword? 1)) :key) nil nil nil]&quot;)
    (invalid! schema [1.4 :A 2 3] &quot;[(named (not (integer? 1.4)) :maybe-long) nil nil nil]&quot;)
    (invalid! schema [] &quot;[(not (present? :maybe-long))]&quot;)
    (is (= '[(one (maybe Int) :maybe-long) (optional Keyword :key) Int] (s/explain schema)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest pair-test
  (let [schema (s/pair s/Str &quot;user-name&quot; s/Int &quot;count&quot;)]
    (valid! schema [&quot;user1&quot; 42])
    (invalid! schema [&quot;user2&quot; 42.1])
    (invalid! schema [42 &quot;user1&quot;])
    (invalid! schema [&quot;user1&quot; 42 42])
    (valid! schema [&quot;user2&quot; 41]) ))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest java-list-test
  (let [schema [s/Str]]
    (valid! schema (java.util.ArrayList. [&quot;hi&quot; &quot;bye&quot;]))
    (invalid! schema (java.util.ArrayList. [1 2]))
    (valid! schema (java.util.LinkedList. [&quot;hi&quot; &quot;bye&quot;]))
    (invalid! schema (java.util.LinkedList. [1 2]))
    (valid! schema java.util.Collections/EMPTY_LIST)
    (invalid! schema java.util.Collections/EMPTY_MAP)
    (invalid! schema #{&quot;hi&quot; &quot;bye&quot;})))</pre></td></tr><tr><td class="docs"><p>Record Schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord Foo [x y])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest record-test
  (let [schema (s/record Foo {:x s/Any (s/optional-key :y) s/Int})]
    (valid! schema (Foo. :foo 1))
    (invalid! schema {:x :foo :y 1})
    (invalid! schema (assoc (Foo. :foo 1) :bar 2))
          (is (= '(record schema.core_test.Foo {:x Any,  (optional-key :y) Int})
                 (s/explain schema)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest record-with-extra-keys-test
  (let [schema (s/record Foo {:x s/Any
                              :y s/Int
                              s/Keyword s/Any})]
    (valid! schema (Foo. :foo 1))
    (valid! schema (assoc (Foo. :foo 1) :bar 2))
    (invalid! schema {:x :foo :y 1})))</pre></td></tr><tr><td class="docs"><p>Function Schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest single-arity-fn-schema-test
  (let [schema (s/=&gt; s/Keyword s/Int s/Int)]
    (valid! schema (fn [x y] (keyword (str (+ x y)))))
    (valid! schema (fn [])) ;; we don't actually validate what the function does
    (valid! schema {})
    (is (= '(=&gt; Keyword Int Int) (s/explain schema)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest single-arity-and-more-fn-schema-test
  (let [schema (s/=&gt; s/Keyword s/Int s/Int &amp; [s/Keyword])]
    (valid! schema (fn [])) ;; we don't actually validate what the function does
    (valid! schema {})
    (is (= '(=&gt; Keyword Int Int &amp; [Keyword]) (s/explain schema)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest multi-arity-fn-schema-test
  (let [schema (s/=&gt;* s/Keyword [s/Int] [s/Int &amp; [s/Keyword]])]
    (valid! schema (fn [])) ;; we don't actually validate what the function does
    (valid! schema {})
    (is (= '(=&gt;* Keyword [Int] [Int &amp; [Keyword]]) (s/explain schema)))))</pre></td></tr><tr><td class="docs"><p>Schematized defrecord</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro test-normalized-meta [symbol ex-schema desired-meta]
  (let [normalized (macros/normalized-metadata &amp;env symbol ex-schema)]
    `(do (is (= '~symbol '~normalized))
         (is (= ~(select-keys desired-meta [:schema :tag])
                ~(select-keys (meta normalized) [:schema :tag]))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(do
  (def ASchema [long])
  (deftest normalized-metadata-test
    (testing &quot;empty&quot; (test-normalized-meta 'foo nil {:schema s/Any}))
    (testing &quot;primitive&quot; (test-normalized-meta ^long foo nil {:tag long :schema long}))
    (testing &quot;class&quot; (test-normalized-meta ^String foo nil {:tag String :schema String}))
    (testing &quot;non-tag&quot; (test-normalized-meta ^ASchema foo nil {:schema ASchema}))
    (testing &quot;explicit&quot; (test-normalized-meta ^Object foo String {:tag Object :schema String})))
  (defmacro test-meta-extraction [meta-form arrow-form]
    (let [meta-ized (macros/process-arrow-schematized-args {} arrow-form)]
      `(do (is (= '~meta-form '~meta-ized))
           (is (= ~(mapv #(select-keys (meta (macros/normalized-metadata {} % nil)) [:schema :tag]) meta-form)
                  ~(mapv #(select-keys (meta %) [:schema :tag]) meta-ized))))))
  (deftest extract-arrow-schematized-args-test
    (testing &quot;empty&quot; (test-meta-extraction [] []))
    (testing &quot;no-tag&quot; (test-meta-extraction [x] [x]))
    (testing &quot;old-tags&quot; (test-meta-extraction [^String x] [^String x]))
    (testing &quot;new-vs-old-tag&quot; (test-meta-extraction [^String x] [x :- String]))
    (testing &quot;multi vars&quot; (test-meta-extraction [x ^String y z] [x y :- String z]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol PProtocol
  (do-something [this]))</pre></td></tr><tr><td class="docs"><p>exercies some different arities</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defrecord Bar
    [^s/Int foo ^s/Str bar]
  {(s/optional-key :baz) s/Keyword})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defrecord Bar2
    [^s/Int foo ^s/Str bar]
  {(s/optional-key :baz) s/Keyword}
  PProtocol
  (do-something [this] 2))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defrecord Bar3
    [^s/Int foo ^s/Str bar]
  PProtocol
  (do-something [this] 3))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defrecord Bar4
    [foo :- [s/Int]
     bar :- (s/maybe {s/Str s/Str})]
  PProtocol
  (do-something [this] 4))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest defrecord-schema-test
  (is (= (utils/class-schema Bar)
         (s/record Bar {:foo s/Int
                        :bar s/Str
                        (s/optional-key :baz) s/Keyword})))
  (is (identity (Bar. 1 :foo)))
  (is (= #{:foo :bar} (set (keys (map-&gt;Bar {:foo 1})))))
  ;; (is (thrown? Exception (map-&gt;Bar {}))) ;; check for primitive long
  (valid! Bar (Bar. 1 &quot;test&quot;))
  (invalid! Bar (Bar. 1 :foo))
  (valid! Bar (assoc (Bar. 1 &quot;test&quot;) :baz :foo))
  (invalid! Bar (assoc (Bar. 1 &quot;test&quot;) :baaaz :foo))
  (invalid! Bar (assoc (Bar. 1 &quot;test&quot;) :baz &quot;foo&quot;))
  (valid! Bar2 (assoc (Bar2. 1 &quot;test&quot;) :baz :foo))
  (invalid! Bar2 (assoc (Bar2. 1 &quot;test&quot;) :baaaaz :foo))
  (is (= 2 (do-something (Bar2. 1 &quot;test&quot;))))
  (valid! Bar3 (Bar3. 1 &quot;test&quot;))
  (invalid! Bar3 (assoc (Bar3. 1 &quot;test&quot;) :foo :bar))
  (is (= 3 (do-something (Bar3. 1 &quot;test&quot;))))
  (valid! Bar4 (Bar4. [1] {&quot;test&quot; &quot;test&quot;}))
  (valid! Bar4 (Bar4. [1] nil))
  (invalid! Bar4 (Bar4. [&quot;a&quot;] {&quot;test&quot; &quot;test&quot;}))
  (is (= 4 (do-something (Bar4. 1 &quot;test&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defrecord BarNewStyle
    [foo :- s/Int
     bar :- s/Str
     zoo]
  {(s/optional-key :baz) s/Keyword})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest defrecord-new-style-schema-test
  (is (= (utils/class-schema BarNewStyle)
         (s/record BarNewStyle {:foo s/Int
                                :bar s/Str
                                :zoo s/Any
                                (s/optional-key :baz) s/Keyword})))
  (is (identity (BarNewStyle. 1 :foo &quot;a&quot;)))
  (is (= #{:foo :bar :zoo} (set (keys (map-&gt;BarNewStyle {:foo 1})))))
  ;; (is (thrown? Exception (map-&gt;BarNewStyle {}))) ;; check for primitive long
  (valid! BarNewStyle (BarNewStyle. 1 &quot;test&quot; &quot;a&quot;))
  (invalid! BarNewStyle (BarNewStyle. 1 :foo &quot;a&quot;))
  (valid! BarNewStyle (assoc (BarNewStyle. 1 &quot;test&quot; &quot;a&quot;) :baz :foo))
  (invalid! BarNewStyle (assoc (BarNewStyle. 1 &quot;test&quot; &quot;a&quot;) :baaaz :foo))
  (invalid! BarNewStyle (assoc (BarNewStyle. 1 &quot;test&quot; &quot;a&quot;) :baz &quot;foo&quot;)))</pre></td></tr><tr><td class="docs"><p>Now test that schemata and protocols work as type hints.
(auto-detecting protocols only works in clj currently)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def LongOrString (s/either s/Int s/Str))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">      (s/defrecord Nested [^Bar4 b ^LongOrString c p :- (s/protocol PProtocol)])
(s/defrecord NestedExplicit [b :- Bar4 c :- LongOrString p :- (s/protocol PProtocol)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn test-fancier-defrecord-schema [klass constructor]
  (let [bar1 (Bar. 1 &quot;a&quot;)
        bar2 (Bar2. 1 &quot;a&quot;)]
    (is (= (utils/class-schema klass)
           (s/record
            klass
            {:b Bar4
             :c LongOrString
             :p (s/protocol PProtocol)}
            constructor)))
    (valid! klass (constructor {:b (Bar4. [1] {}) :c 1 :p bar2}))
    (valid! klass (constructor {:b (Bar4. [1] {}) :c &quot;hi&quot; :p bar2}))
    (invalid! klass (constructor {:b (Bar4. [1] {}) :c &quot;hi&quot; :p bar1}))
    (invalid! klass (constructor {:b (Bar4. [1] {:foo :bar}) :c 1 :p bar2}))
    (invalid! klass (constructor {:b nil :c &quot;hi&quot; :p bar2}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest fancier-defrecord-schema-test
        (test-fancier-defrecord-schema Nested map-&gt;Nested)
  (test-fancier-defrecord-schema NestedExplicit map-&gt;NestedExplicit))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defrecord OddSum
    [a b]
  {}
  #(odd? (+ (:a %) (:b %))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest defrecord-extra-validation-test
  (valid! OddSum (OddSum. 1 2))
  (invalid! OddSum (OddSum. 1 3)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(do (s/defrecord RecordWithPrimitive [x :- long])
    (deftest record-with-primitive-test
      (valid! RecordWithPrimitive (RecordWithPrimitive. 1))
      (is (thrown? Exception (RecordWithPrimitive. &quot;a&quot;)))
      (is (thrown? Exception (RecordWithPrimitive. nil)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest map-&gt;record-test
  (let [subset {:foo 1 :bar &quot;a&quot;}
        exact (assoc subset :zoo :zoo)
        superset (assoc exact :baz :baz)]
    (testing &quot;map-&gt;record&quot;
      (is (= (assoc subset :zoo nil)
             (into {} (map-&gt;BarNewStyle subset))))
      (is (= exact
             (into {} (map-&gt;BarNewStyle exact))))
      (is (= superset
             (into {} (map-&gt;BarNewStyle superset)))))
    (testing &quot;strict-map-&gt;record&quot;
      (is (thrown? Exception (strict-map-&gt;BarNewStyle subset)))
      (is (= exact (into {} (strict-map-&gt;BarNewStyle exact))))
      (is (= exact (into {} (strict-map-&gt;BarNewStyle exact true))))
      (is (thrown? Exception (strict-map-&gt;BarNewStyle superset)))
      (is (= exact (into {} (strict-map-&gt;BarNewStyle superset true)))))))</pre></td></tr><tr><td class="docs"><p>Schematized functions</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest split-rest-arg-test
  (is (= (macros/split-rest-arg {} ['a '&amp; 'b])
         '[[a] b]))
  (is (= (macros/split-rest-arg {} ['a 'b])
         '[[a b] nil])))</pre></td></tr><tr><td class="docs"><p>fn</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def OddLong (s/both (s/pred odd?)                    long))</pre></td></tr><tr><td class="docs"><p>Schema for (s/fn ^String [^OddLong x y])</p>
</td><td class="codes"><pre class="brush: clojure">(def +test-fn-schema+
  (s/=&gt; s/Str OddLong s/Any))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest simple-validated-meta-test
  (let [f (s/fn ^s/Str foo [^OddLong arg0 arg1])]
    (is (= +test-fn-schema+ (s/fn-schema f)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest no-schema-fn-test
  (let [f (s/fn [arg0 arg1] (+ arg0 arg1))]
    (is (= (s/=&gt; s/Any s/Any s/Any) (s/fn-schema f)))
    (s/with-fn-validation
      (is (= 4 (f 1 3))))
    (is (= 4 (f 1 3)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest simple-validated-fn-test
  (let [f (s/fn test-fn :- (s/pred even?)
            [^s/Int x y :- {:foo (s/both s/Int (s/pred odd?))}]
            (+ x (:foo y -100)))]
    (s/with-fn-validation
      (is (= 4 (f 1 {:foo 3})))
      ;; Primitive Interface Test
            (is (thrown? Exception (.invokePrim f 1 {:foo 3}))) ;; primitive type hints don't work on fns
      (invalid-call! f 1 {:foo 4})  ;; foo not odd?
      (invalid-call! f 2 {:foo 3})) ;; return not even?
    (is (= 5 (f 1 {:foo 4})))     ;; foo not odd?
    (is (= 4.0 (f 1.0 {:foo 3}))) ;; first arg not long
    (is (= 5 (f 2 {:foo 3})))     ;; return not even?
    (testing
        &quot;Tests that the anonymous function schema macro can handle a
         name, a schema without a name and no return schema.&quot;
      (let [named-square (s/fn square :- s/Int [x :- s/Int]
                           (* x x))
            anon-square (s/fn :- s/Int [x :- s/Int]
                          (* x x))
            arg-only-square (s/fn [x :- s/Int] (* x x))]
        (is (= 100
               (named-square 10)
               (anon-square 10)
               (arg-only-square 10)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest always-validated-fn-test
  (let [f (s/fn ^:always-validate test-fn :- (s/pred even?)
            [x :- (s/pred pos?)]
            (inc x))]
    (is (= 2 (f 1)))
    (invalid-call! f 2)
    (invalid-call! f -1)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defn ^:never-validate never-validated-test-fn :- (s/pred even?)
  [x :- (s/pred pos?)]
  (inc x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest never-validated-fn-test
  (doseq [f [never-validated-test-fn
             (s/fn ^:never-validate test-fn :- (s/pred even?)
               [x :- (s/pred pos?)]
               (inc x))]]
    (s/with-fn-validation
      (is (= 2 (f 1)))
      (is (= 3 (f 2)))
      (is (= 0 (f -1))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defn ^:never-validate never-validated-rest-test-fn :- (s/pred even?)
  [arg0 &amp; [rest0 :- (s/pred pos?)]]
  (+ arg0 (or rest0 2)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest never-validated-rest-test
  (doseq [f [never-validated-rest-test-fn
             (s/fn ^:never-validate rest-test-fn :- (s/pred even?)
               [arg0 &amp; [rest0 :- (s/pred pos?)]]
               (+ arg0 (or rest0 2)))]]
    (s/with-fn-validation
      (is (= 2 (f 0)))
      (is (= 4 (f 2 2)))
      (is (= 1 (f 2 -1))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/set-compile-fn-validation! false)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defn elided-validation-test-fn :- (s/pred even?)
  [x :- (s/pred pos?)]
  (inc x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defn ^:always-validate elided-validation-always-test-fn :- (s/pred even?)
  [x :- (s/pred pos?)]
  (inc x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/set-compile-fn-validation! true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest elided-validation-test
  (doseq [f [elided-validation-test-fn
             elided-validation-always-test-fn]]
    (s/with-fn-validation
      (is (= 2 (f 1)))
      (is (= 3 (f 2)))
      (is (= 0 (f -1))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn parse-long [x]
        (Long/parseLong x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest destructured-validated-fn-test
  (let [LongPair [(s/one s/Int 'x) (s/one s/Int 'y)]
        f (s/fn foo :- s/Int
            [^LongPair [x y] ^s/Int arg1]
            (+ x y arg1))]
    (is (= (s/=&gt; s/Int LongPair s/Int)
           (s/fn-schema f)))
    (s/with-fn-validation
      (is (= 6 (f [1 2] 3)))
      (invalid-call! f [&quot;a&quot; 2] 3))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest two-arity-fn-test
  (let [f (s/fn foo :- s/Int
            ([^s/Str arg0 ^s/Int arg1] (+ arg1 (foo arg0)))
            ([^s/Str arg0] (parse-long arg0)))]
    (is (= (s/=&gt;* s/Int [s/Str] [s/Str s/Int])
           (s/fn-schema f)))
    (is (= 3 (f &quot;3&quot;)))
    (is (= 10 (f &quot;3&quot; 7)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest infinite-arity-fn-test
  (let [f (s/fn foo :- s/Int
            ([^s/Int arg0] (inc arg0))
            ([^s/Int arg0  &amp; strs :- [s/Str]]
               (reduce + (foo arg0) (map count strs))))]
    (is (= (s/=&gt;* s/Int [s/Int] [s/Int &amp; [s/Str]])
           (s/fn-schema f)))
    (s/with-fn-validation
      (is (= 5 (f 4)))
      (is (= 16 (f 4 &quot;55555&quot; &quot;666666&quot;)))
      (invalid-call! f 4 [3 3 3]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest rest-arg-destructuring-test
  (testing &quot;no schema&quot;
    (let [f (s/fn foo :- s/Int
              [^s/Int arg0 &amp; [rest0]] (+ arg0 (or rest0 2)))]
      (is (= (s/=&gt;* s/Int [s/Int &amp; [(s/optional s/Any 'rest0)]])
             (s/fn-schema f)))
      (s/with-fn-validation
        (is (= 6 (f 4)))
        (is (= 9 (f 4 5)))
        (invalid-call! f 4 9 2))))
  (testing &quot;arg schema&quot;
    (let [f (s/fn foo :- s/Int
              [^s/Int arg0 &amp; [rest0 :- s/Int]] (+ arg0 (or rest0 2)))]
      (is (= (s/=&gt;* s/Int [s/Int &amp; [(s/optional s/Int 'rest0)]])
             (s/fn-schema f)))
      (s/with-fn-validation
        (is (= 6 (f 4)))
        (is (= 9 (f 4 5)))
        (invalid-call! f 4 9 2)
        (invalid-call! f 4 1.5))))
  (testing &quot;list schema&quot;
    (let [f (s/fn foo :- s/Int
              [^s/Int arg0 &amp; [rest0] :- [s/Int]] (+ arg0 (or rest0 2)))]
      (is (= (s/=&gt;* s/Int [s/Int &amp; [s/Int]])
             (s/fn-schema f)))
      (s/with-fn-validation
        (is (= 6 (f 4)))
        (is (= 9 (f 4 5)))
        (is (= 9 (f 4 5 9)))
        (invalid-call! f 4 1.5)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest fn-recursion-test
  (testing &quot;non-tail recursion&quot;
    (let [f (s/fn fib :- s/Int [n :- s/Int]
              (if (&lt;= n 2) 1 (+ (fib (- n 1)) (fib (- n 2)))))]
      (is (= 8 (f 6)))
      (s/with-fn-validation
        (is (= 8 (f 6))))))
  (testing &quot;tail recursion&quot;
    (let [f (s/fn fact :- s/Int [n :- s/Int ret :- s/Int]
              (if (&lt;= n 1) ret (recur (dec n) (* ret n))))]
      (is (= 120 (f 5 1)))
      (s/with-fn-validation
        (is (= 120 (f 5 1)))))))</pre></td></tr><tr><td class="docs"><p>in ClojureScript, metadata on ordinary fn form does not propagate to fn either.</p>
</td><td class="codes"><pre class="brush: clojure">(deftest fn-metadata-test
  (let [-&gt;mkeys #(set (keys (meta %)))]
    (is (= (into (-&gt;mkeys (s/fn [])) [:blah])
           (-&gt;mkeys ^:blah (s/fn []))))))</pre></td></tr><tr><td class="docs"><p>defn</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def OddLongString
  (s/both s/Str (s/pred #(odd? (parse-long %)) 'odd-str?)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defn ^{:tag String} simple-validated-defn :- OddLongString
  &quot;I am a simple schema fn&quot;
  {:metadata :bla}
  [arg0 :- OddLong]
  (str arg0))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defn validated-pre-post-defn :- OddLong
  &quot;I have pre/post conditions&quot;
  [arg0 :- s/Num]
  {:pre  [(odd? arg0) (&gt; 10 arg0)]
   :post [(odd? %)    (&lt;  5 %)]}
  arg0)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def +simple-validated-defn-schema+
  (s/=&gt; OddLongString OddLong))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^String +bad-input-str+ &quot;Input to simple-validated-defn does not match schema&quot;)</pre></td></tr><tr><td class="docs"><p>Test that s/defn returns var</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(with-test
  (s/defn with-test-fn [a b] (+ a b))
  (is (= 3 (with-test-fn 1 2)))
  (is (= 0 (with-test-fn 10 -10))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defn ^String multi-arglist-validated-defn :- OddLongString
  &quot;I am a multi-arglist schema fn&quot;
  {:metadata :bla}
  ([arg0 :- OddLong]
     (str arg0))
  ([arg0 :- OddLong arg1 :- Long]
     (str (+ arg0 arg1))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest simple-validated-defn-test
  (is (= &quot;Inputs: [arg0 :- OddLong]\n  Returns: OddLongString\n\n  I am a simple schema fn&quot;
         (:doc (meta #'simple-validated-defn))))
  (is (= '([arg0]) (:arglists (meta #'simple-validated-defn))))
  (is (= &quot;Inputs: ([arg0 :- OddLong] [arg0 :- OddLong arg1 :- Long])\n  Returns: OddLongString\n\n  I am a multi-arglist schema fn&quot;
         (:doc (meta #'multi-arglist-validated-defn))))
  (is (= '([arg0] [arg0 arg1]) (:arglists (meta #'multi-arglist-validated-defn))))
  (s/with-fn-validation
    (testing &quot;pre/post&quot;
      (is (= 7 (validated-pre-post-defn 7)))
      (is (thrown-with-msg? AssertionError #&quot;Assert failed: \(odd\? arg0\)&quot;
                            (validated-pre-post-defn 0)))
      (is (thrown-with-msg? AssertionError #&quot;Assert failed: \(&gt; 10 arg0\)&quot;
                            (validated-pre-post-defn 11)))
      (is (thrown-with-msg? AssertionError #&quot;Assert failed: \(&lt; 5 %\)&quot;
                            (validated-pre-post-defn 1)))
      (invalid-call! validated-pre-post-defn &quot;a&quot;)))
  (let [{:keys [tag schema metadata]} (meta #'simple-validated-defn)]
          (is (= tag s/Str))
    (is (= +simple-validated-defn-schema+ schema))
    (is (= metadata :bla)))
  (is (= +simple-validated-defn-schema+ (s/fn-schema simple-validated-defn)))
  (s/with-fn-validation
    (is (= &quot;3&quot; (simple-validated-defn 3)))
    (invalid-call! simple-validated-defn 4)
    (invalid-call! simple-validated-defn &quot;a&quot;))
  (is (= &quot;4&quot; (simple-validated-defn 4)))
  (let [e ^Exception (try (s/with-fn-validation (simple-validated-defn 2)) nil (catch Exception e e))]
    (is (.contains (.getMessage e) +bad-input-str+))
    (is (.contains (.getClassName ^StackTraceElement (first (.getStackTrace e))) &quot;simple_validated_defn&quot;))
    (is (.startsWith (.getFileName ^StackTraceElement (first (.getStackTrace e))) &quot;core_test.clj&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defn ^:always-validate always-validated-defn :- (s/pred even?)
  [x :- (s/pred pos?)]
  (inc x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest always-validated-defn-test
  (is (= 2 (always-validated-defn 1)))
  (invalid-call! always-validated-defn 2)
  (invalid-call! always-validated-defn -1))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defn fib :- s/Int [n :- s/Int]
  (if (&lt;= n 2) 1 (+ (fib (- n 1)) (fib (- n 2)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defn fact :- s/Int [n :- s/Int ret :- s/Int]
  (if (&lt;= n 1) ret (recur (dec n) (* ret n))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest defn-recursion-test
  (testing &quot;non-tail recursion&quot;
    (is (= 8 (fib 6)))
    (s/with-fn-validation
      (is (= 8 (fib 6)))))
  (testing &quot;tail recursion&quot;
    (is (= 120 (fact 5 1)))
    (s/with-fn-validation
      (is (= 120 (fact 5 1))))))</pre></td></tr><tr><td class="docs"><p>letfn</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest minimal-letfn-test
  (is (= &quot;1&quot;
         (s/letfn
             []
           &quot;1&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest simple-letfn-test
  (is (= &quot;1&quot;
         (s/with-fn-validation
           (s/letfn
               [(x :- s/Num [] 1)
                (y :- s/Str [m :- s/Num] (str m))]
             (y (x)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest unannotated-letfn-test
  (is (= &quot;1&quot;
         (s/with-fn-validation
           (s/letfn
               [(x [] 1)
                (y [m] (str m))]
             (y (x)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest no-validation-letfn-test
  (is (= &quot;1&quot;
         (s/letfn
             [(x :- s/Num [] 1)
              (y :- s/Str [m :- s/Num] (str m))]
           (y (x))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest error-letfn-test
  (s/with-fn-validation
    (s/letfn
        [(x :- s/Num [] &quot;1&quot;)
         (y :- s/Str [m :- s/Num] (str m))]
      (invalid-call! y (x)))))</pre></td></tr><tr><td class="docs"><p>Primitive validation testing for JVM</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(do
  (def +primitive-validated-defn-schema+
    (s/=&gt; long OddLong))
  (s/defn primitive-validated-defn :- long
    [^long arg0 :- OddLong]
    (inc arg0))
  (deftest simple-primitive-validated-defn-test
    (is (= +primitive-validated-defn-schema+ (s/fn-schema primitive-validated-defn)))
    (is ((ancestors (class primitive-validated-defn)) clojure.lang.IFn$LL))
    (s/with-fn-validation
      (is (= 4 (primitive-validated-defn 3)))
      (is (= 4 (.invokePrim primitive-validated-defn 3)))
      (is (thrown? Exception (primitive-validated-defn 4))))
    (is (= 5 (primitive-validated-defn 4))))
  (s/defn another-primitive-fn :- double
    [^long arg0]
    1.0)
  (deftest another-primitive-fn-test
    (is ((ancestors (class another-primitive-fn)) clojure.lang.IFn$LD))
    (is (= 1.0 (another-primitive-fn 10)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest with-fn-validation-error-test
  (is (thrown?       RuntimeException                
               (s/with-fn-validation (throw       (RuntimeException.)                           ))))
  (is (false? (.get_cell utils/use-fn-validation))))</pre></td></tr><tr><td class="docs"><p>def</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest def-test ;; heh
  (s/def v 1)
  (is (= 1 v))
  (s/def v &quot;doc&quot; 2)
  (is (= 2 v))
        (is (= &quot;doc&quot; (:doc (meta #'v))))
  (s/def v :- s/Int &quot;doc&quot; 3)
  (is (= 3 v))
        (is (= &quot;doc&quot; (:doc (meta #'v))))
  (s/def v :- s/Int 3)
        (is (= String (:tag (meta (s/def v :- String &quot;a&quot;)))))
        (is (thrown? Exception (s/def v :- s/Int &quot;doc&quot; 1.0)))
        (is (thrown? Exception (s/def v :- s/Int 1.0)))
        (is (thrown? Exception (s/def ^s/Int v 1.0))))</pre></td></tr><tr><td class="docs"><p>defmethod</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti m #(:k (first %&amp;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest defmethod-unannotated-test
  (s/defmethod m :v [m x y] (+ x y))
  (is (= 3 (m {:k :v} 1 2))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest defmethod-input-annotated
  (s/defmethod m :v [m :- {:k s/Keyword} x :- s/Num y :- s/Num] (+ x y))
  (is (= 3
         (s/with-fn-validation (m {:k :v} 1 2)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest defmethod-output-annotated
  (s/defmethod m :v :- s/Num [m x y] (+ x y))
  (is (= 3
         (s/with-fn-validation (m {:k :v} 1 2)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest defmethod-all-annotated
  (s/defmethod m :v :- s/Num [m :- {:k s/Keyword} x :- s/Num y :- s/Num] (+ x y))
  (is (= 3
         (s/with-fn-validation (m {:k :v} 1 2)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest defmethod-input-error-test
  (s/defmethod m :v :- s/Num [m :- {:k s/Keyword} x :- s/Num y :- s/Num] (+ x y))
  (s/with-fn-validation (invalid-call! m {:k :v} 1 &quot;2&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest defmethod-output-error-test
  (s/defmethod m :v :- s/Num [m :- {:k s/Keyword} x :- s/Num y :- s/Num] &quot;wrong&quot;)
  (s/with-fn-validation (invalid-call! m {:k :v} 1 2)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest defmethod-metadata-test
  (s/defmethod ^:always-validate m :v :- s/Num [m :- {:k s/Keyword} x :- s/Num y :- s/Num] &quot;wrong&quot;)
  (is (thrown?       RuntimeException                
               (m {:k :v} 1 2))))</pre></td></tr><tr><td class="docs"><p>Composite Schemas (test a few combinations of above)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest nice-error-test
  (let [schema {:a #{[s/Int]}
                :b [(s/one s/Keyword :k) s/Int]
                :c s/Any}]
    (valid! schema {:a #{[1 2 3 4] [] [1 2]}
                    :b [:k 1 2 3]
                    :c :whatever})
    (invalid! schema {:a #{[1 2 3 4] [] [1 2] [:a :b]}
                      :b [:k]
                      :c nil}
              &quot;{:a #{[(not (integer? :a)) (not (integer? :b))]}}&quot;)
    (invalid! schema {:a #{}
                      :b [1 :a]
                      :c nil}
              &quot;{:b [(named (not (keyword? 1)) :k) (not (integer? :a))]}&quot;)
    (invalid! schema {:a #{}
                      :b [:k]}
              &quot;{:c missing-required-key}&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defrecord Explainer
    [^s/Int foo ^s/Keyword bar]
  {(s/optional-key :baz) s/Keyword})</pre></td></tr><tr><td class="docs"><p>clojurescript.test hangs on this test in phantom.js, so marking clj-only</p>
</td><td class="codes"><pre class="brush: clojure">(deftest fancy-explain-test
  (is (= (s/explain {(s/required-key 'x) s/Int
                     s/Keyword [(s/one s/Int &quot;foo&quot;) (s/maybe Explainer)]})
         `{~'(required-key x) ~'Int
           ~'Keyword [(~'one ~'Int &quot;foo&quot;)
                      (~'maybe
                       (~'record
                              Explainer                                  
                        {:foo ~'Int
                         :bar ~'Keyword
                         (~'optional-key :baz) ~'Keyword}))]})))</pre></td></tr><tr><td class="docs"><p> Regression tests</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord ItemTest [first second])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord CacheTest [schema]
  s/Schema
  (spec [this]
    (collection/collection-spec
      (let [p (spec/precondition this #(instance? ItemTest %) #(list 'instance? ItemTest %))]
        (if-let [evf (:extra-validator-fn this)]
          (some-fn p (spec/precondition this evf #(list 'passes-extra-validation? %)))
          p))
      (fn [x] x)
      [{:schema     s/Int
        :cardinality :exactly-one
        :parser     (fn [item-col m]
                      (item-col (:first m))
                      m)
        :error-wrap (fn [err] [:first (utils/error-val err)])
        }
       {:schema      schema
        :cardinality :exactly-one
        :parser      (fn [item-col m]
                       (item-col (:second m))
                       m)
        :error-wrap  (fn [err] [:second (utils/error-val err)])
        }
       {:schema s/Any
        :cardinality :exactly-one
        :parser (fn [_ _] nil)}]
      (fn [_ elts _] (map utils/error-val elts))))
  (explain [_]
    (list 'cache-test)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest issue-310-error-wrap-cache
  (are [schema value expected]
    (= expected (pr-str (s/check schema value)))
    (-&gt;CacheTest s/Int) (-&gt;ItemTest :a nil)
    &quot;([:first (not (integer? :a))] [:second (not (integer? nil))])&quot;
    (-&gt;CacheTest [s/Int]) (-&gt;ItemTest :a nil)
    &quot;([:first (not (integer? :a))] nil)&quot;
    (-&gt;CacheTest [s/Int]) (-&gt;ItemTest :a [nil])
    &quot;([:first (not (integer? :a))] [:second [(not (integer? nil))]])&quot;))</pre></td></tr><tr><td class="docs"><p> Helpers for defining schemas (used in in-progress work, expanlation coming soon)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defschema TestFoo {:bar s/Str})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest test-defschema
  (is (= 'TestFoo (:name (meta TestFoo))))
  (is (= 'schema.core-test (:ns (meta TestFoo)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest schema-with-name-test
  (let [schema (s/schema-with-name {:baz s/Num} 'Baz)]
    (valid! schema {:baz 123})
    (invalid! schema {:baz &quot;abc&quot;})
    (is (= 'Baz (s/schema-name schema)))
    (is (=  nil (s/schema-ns schema)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest schema-name-test
  (is (= 'TestFoo (s/schema-name TestFoo))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest schema-ns-test
  (is (= 'schema.core-test (s/schema-ns TestFoo))))</pre></td></tr><tr><td class="docs"><p>This file autogenerated from test/cljx/schema/core_test.cljx</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.experimental.abstract-map" name="schema.experimental.abstract-map"><h1 class="project-name">schema.experimental.abstract-map</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Schemas representing abstract classes and subclasses</p>
</td><td class="codes"><pre class="brush: clojure">(ns schema.experimental.abstract-map
  (:require
   [clojure.string :as str]
   [schema.core :as s :include-macros true]
   [schema.spec.core :as spec]
   [schema.spec.variant :as variant]))</pre></td></tr><tr><td class="docs"><p>Private: helpers</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol PExtensibleSchema
  (extend-schema! [this extension schema-name dispatch-values]))</pre></td></tr><tr><td class="docs"><p>a "subclass"</p>
</td><td class="codes"><pre class="brush: clojure">(defrecord SchemaExtension [schema-name base-schema extended-schema explain-value]
  s/Schema
  (spec [this]
    (variant/variant-spec spec/+no-precondition+ [{:schema extended-schema}]))
  (explain [this]
    (list 'extend-schema
          schema-name
          (s/schema-name base-schema)
          (s/explain explain-value))))</pre></td></tr><tr><td class="docs"><p>an "abstract class"</p>
</td><td class="codes"><pre class="brush: clojure">(defrecord AbstractSchema [sub-schemas dispatch-key schema open?]
  s/Schema
  (spec [this]
    (variant/variant-spec
     spec/+no-precondition+
     (concat
      (for [[k s] @sub-schemas]
        {:guard #(= (keyword (dispatch-key %)) (keyword k))
         :schema s})
      (when open?
        [{:schema (assoc schema dispatch-key s/Keyword s/Any s/Any)}]))
     (fn [v] (list (set (keys @sub-schemas)) (list dispatch-key v)))))
  (explain [this]
    (list 'abstract-map-schema dispatch-key (s/explain schema) (set (keys @sub-schemas))))
  PExtensibleSchema
  (extend-schema! [this extension schema-name dispatch-values]
    (let [sub-schema (assoc (merge schema extension)
                       dispatch-key (apply s/enum dispatch-values))
          ext-schema (s/schema-with-name
                      (SchemaExtension. schema-name this sub-schema extension)
                      (name schema-name))]
      (swap! sub-schemas merge (into {} (for [k dispatch-values] [k ext-schema])))
      ext-schema)))</pre></td></tr><tr><td class="docs"><p>Public</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A schema representing an 'abstract class' map that must match at least one concrete
   subtype (indicated by the value of dispatch-key, a keyword).  Add subtypes by calling
   <code>extend-schema</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(s/defn abstract-map-schema
  [dispatch-key :- s/Keyword schema :- (s/pred map?)]
  (AbstractSchema. (atom {}) dispatch-key schema false))</pre></td></tr><tr><td class="docs"><p>Like abstract-map-schema, but allows unknown types to validate (for, e.g. forward
   compatibility).</p>
</td><td class="codes"><pre class="brush: clojure">(s/defn open-abstract-map-schema
  [dispatch-key :- s/Keyword schema :- (s/pred map?)]
  (AbstractSchema. (atom {}) dispatch-key schema true))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro extend-schema
  [schema-name extensible-schema dispatch-values extension]
  `(def ~schema-name
     (extend-schema! ~extensible-schema ~extension '~schema-name ~dispatch-values)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sub-schemas [abstract-schema]
  @(.-sub-schemas ^AbstractSchema abstract-schema))</pre></td></tr><tr><td class="docs"><p>This file autogenerated from src/cljx/schema/experimental/abstract_map.cljx</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.experimental.abstract-map-test" name="schema.experimental.abstract-map-test"><h1 class="project-name">schema.experimental.abstract-map-test</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns schema.experimental.abstract-map-test
        (:use clojure.test [schema.test-macros :only [valid! invalid! invalid-call!]])
  (:require
   [schema.core :as s]
   [schema.coerce :as coerce]
   [schema.experimental.abstract-map :as abstract-map :include-macros true]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defschema Animal
  (abstract-map/abstract-map-schema
   :type
   {:age s/Num
    :vegan? s/Bool}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(abstract-map/extend-schema Cat Animal [:cat] {:fav-catnip s/Str})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest extend-schema-test
  (valid! Cat {:age 3 :vegan? false :fav-catnip &quot;cosmic&quot; :type :cat})
  (invalid! Cat {:age 3 :vegan? false :fav-catnip &quot;cosmic&quot; :type :cat :foobar false})
  (valid! Animal {:age 3 :vegan? false :fav-catnip &quot;cosmic&quot; :type :cat})
  (invalid! Animal {:age 3 :vegan? false :type :cat}
            &quot;{:fav-catnip missing-required-key}&quot;)
  (invalid! Animal {:age 3 :vegan? false :fav-catnip &quot;cosmic&quot; :type :dog}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defschema TV
  (abstract-map/open-abstract-map-schema
   :make
   {:channel s/Int
    :power? s/Bool}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(abstract-map/extend-schema HondaTV TV [:honda] {:num-wheels s/Int})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest open-abstract-map-schema-test
  (valid! TV {:channel 30 :power? true :num-wheels 1 :make :honda})
  (valid! HondaTV {:channel 30 :power? true :num-wheels 1 :make :honda})
  (valid! TV {:channel 30 :power? false :missiles &quot;short range&quot; :make :dod})
  (invalid! TV {:channel 30 :make :unknown} &quot;{:power? missing-required-key}&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest json-coercer-test
  (let [animal-coercer (coerce/coercer Animal coerce/json-coercion-matcher)
        cat-coercer (coerce/coercer Cat coerce/json-coercion-matcher)
        cat {:type :cat :age 12 :vegan? false :fav-catnip &quot;cosmic&quot;}]
    (is (= cat (animal-coercer (update-in cat [:type] name))))
    (is (= cat (cat-coercer (update-in cat [:type] name))))))</pre></td></tr><tr><td class="docs"><p>This file autogenerated from test/cljx/schema/experimental/abstract<em>map</em>test.cljx</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.experimental.complete" name="schema.experimental.complete"><h1 class="project-name">schema.experimental.complete</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>(Extremely) experimental support for 'completing' partial datums to match
   a schema. To use it, you must provide your own test.check dependency.</p>
</td><td class="codes"><pre class="brush: clojure">(ns schema.experimental.complete
  (:require
   [clojure.test.check.generators :as check-generators]
   [schema.spec.core :as spec]
   schema.spec.collection
   schema.spec.leaf
   schema.spec.variant
   [schema.coerce :as coerce]
   [schema.core :as s]
   [schema.macros :as macros]
   [schema.utils :as utils]
   [schema.experimental.generators :as generators]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def +missing+ ::missing)</pre></td></tr><tr><td class="docs"><p>Private helpers</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol Completer
  (completer* [spec s sub-checker generator-opts]
    &quot;A function applied to a datum as part of coercion to complete missing fields.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sample [g]
  (check-generators/generate g 10))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol Completer
  schema.spec.variant.VariantSpec
  (completer* [spec s sub-checker generator-opts]
    (let [g (apply generators/generator s generator-opts)]
      (if (and (class? s) (isa? s clojure.lang.IRecord) (utils/class-schema s))
        (fn record-completer [x]
          (sub-checker (into (sample g) x)))
        (fn variant-completer [x]
          (if (= +missing+ x)
            (sample g)
            (sub-checker x))))))

  schema.spec.collection.CollectionSpec
  (completer* [spec s sub-checker generator-opts]
    (if (instance? clojure.lang.APersistentMap s) ;; todo: pluggable
      (let [g (apply generators/generator s generator-opts)]
        (fn map-completer [x]
          (if (= +missing+ x)
            (sample g)
            ;; for now, just do required keys when user provides input.
            (let [ks (distinct (concat (keys x)
                                       (-&gt;&gt; s
                                            keys
                                            (filter s/required-key?)
                                            (map s/explicit-schema-key))))]
              (sub-checker
               (into {} (for [k ks] [k (get x k +missing+)])))))))
      (fn [x] (assert (not= x +missing+)) (sub-checker x))))

  schema.spec.leaf.LeafSpec
  (completer* [spec s sub-checker generator-opts]
    (let [g (apply generators/generator s generator-opts)]
      (fn leaf-completer [x]
        (if (= +missing+ x)
          (sample g)
          x)))))</pre></td></tr><tr><td class="docs"><p>Public</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Produce a function that simultaneously coerces, completes, and validates a datum.</p>
</td><td class="codes"><pre class="brush: clojure">(s/defn completer
  ([schema] (completer schema {}))
  ([schema coercion-matcher] (completer schema coercion-matcher {}))
  ([schema coercion-matcher leaf-generators]
     (completer schema coercion-matcher leaf-generators {}))
  ([schema
    coercion-matcher :- coerce/CoercionMatcher
    leaf-generators :- generators/LeafGenerators
    wrappers :- generators/GeneratorWrappers]
     (spec/run-checker
      (fn [s params]
        (let [c (spec/checker (s/spec s) params)
              coercer (or (coercion-matcher s) identity)
              completr (completer* (s/spec s) s c [leaf-generators wrappers])]
          (fn [x]
            (macros/try-catchall
             (let [v (coercer x)]
               (if (utils/error? v)
                 v
                 (completr v)))
             (catch t (macros/validation-error s x t))))))
      true
      schema)))</pre></td></tr><tr><td class="docs"><p>Fill in partial-datum to make it validate schema.</p>
</td><td class="codes"><pre class="brush: clojure">(defn complete
  [partial-datum &amp; completer-args]
  ((apply completer completer-args) partial-datum))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.experimental.complete-test" name="schema.experimental.complete-test"><h1 class="project-name">schema.experimental.complete-test</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns schema.experimental.complete-test
  (:use clojure.test)
  (:require
   [schema.coerce :as coerce]
   [schema.core :as s]
   [schema.experimental.abstract-map :as abstract-map]
   [schema.experimental.complete :as complete]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest complete-test
  (let [s [{:a s/Int :b s/Str}]
        [r1 r2 :as rs] (complete/complete [{:a 1} {:b &quot;bob&quot;}] s)]
    (is (not (s/check s rs)))
    (is (= (:a r1) 1))
    (is (= (:b r2) &quot;bob&quot;)))
  (testing &quot;complete through variant&quot;
    (let [s (s/cond-pre s/Str {:foo s/Int})]
      (is (= &quot;test&quot; (complete/complete &quot;test&quot; s)))
      (is (integer? (:foo (complete/complete {} s)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defschema Animal
  (abstract-map/abstract-map-schema
   :type
   {:name s/Str}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(abstract-map/extend-schema Cat Animal [:cat] {:claws? s/Bool})
(abstract-map/extend-schema Dog Animal [:dog] {:barks? s/Bool})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defrecord User
    [id :- long
     cash :- double
     friends :- [User]
     pet :- (s/maybe Animal)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def complete-user
  (complete/completer
   User
   {User (fn [x] (if (number? x) {:id x} x))
    Animal (fn [x] (if (keyword? x) {:type x} x))}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pull-pattern-matcher [s]
  (when (and (instance? clojure.lang.APersistentMap s)
             (not (s/find-extra-keys-schema s)))
    (fn [x]
      (select-keys x (-&gt;&gt; s keys (map s/explicit-schema-key))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pull [s x]
  ((coerce/coercer s pull-pattern-matcher) x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest fancy-complete-test
  (is (s/validate User (complete-user {})))
  (is (= {:id 2}
         (pull {:id long} (complete-user 2))))
  (is (= {:id 2 :pet {:type :cat}}
         (pull {:id s/Any :pet {:type s/Keyword}} (complete-user {:id 2 :pet :cat}))))
  (is (= {:id 10 :friends [{:id 2} {:id 3}]}
         (pull {:id s/Any :friends [{:id long}]}
               (complete-user {:id 10 :friends [2 {:id 3}]}))))
  (is (= {:id 10 :friends [{:id 2 :pet nil} {:id 3 :pet {:type :dog}}]}
         (pull {:id s/Any :friends [{:id long :pet (s/maybe {:type s/Keyword})}]}
               (complete-user {:id 10 :friends [{:id 2 :pet nil} {:id 3 :pet :dog}]})))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.experimental.generators" name="schema.experimental.generators"><h1 class="project-name">schema.experimental.generators</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>(Very) experimental support for compiling schemas to test.check generators.
   To use it, you must provide your own test.check dependency.</p>

<p>   TODO: add cljs support.</p>
</td><td class="codes"><pre class="brush: clojure">(ns schema.experimental.generators
  (:require
   [clojure.test.check.generators :as generators]
   [schema.spec.core :as spec]
   schema.spec.collection
   schema.spec.leaf
   schema.spec.variant
   [schema.core :as s]
   [schema.macros :as macros]))</pre></td></tr><tr><td class="docs"><p>Private helpers for composite schemas</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn g-by [f &amp; args]
  (generators/fmap
   (partial apply f)
   (apply generators/tuple args)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn g-apply-by [f args]
  (generators/fmap f (apply generators/tuple args)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- sub-generator
  [{:keys [schema]}
   {:keys [subschema-generator ^java.util.Map cache] :as params}]
  (spec/with-cache cache schema
    (fn [d] (#'generators/make-gen (fn [r s] (generators/call-gen @d r (quot s 2)))))
    (fn [] (subschema-generator schema params))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol CompositeGenerator
  (composite-generator [s params]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol CompositeGenerator
  schema.spec.variant.VariantSpec
  (composite-generator [s params]
    (generators/such-that
     (fn [x]
       (let [pre (.-pre ^schema.spec.variant.VariantSpec s)
             post (.-post ^schema.spec.variant.VariantSpec s)]
         (not
          (or (pre x)
              (and post (post x))))))
     (generators/one-of
      (for [o (macros/safe-get s :options)]
        (if-let [g (:guard o)]
          (generators/such-that g (sub-generator o params))
          (sub-generator o params))))))

  ;; TODO: this does not currently capture proper semantics of maps with
  ;; both specific keys and key schemas that can override them.
  schema.spec.collection.CollectionSpec
  (composite-generator [s params]
    (generators/such-that
     (complement (.-pre ^schema.spec.collection.CollectionSpec s))
     (generators/fmap
      (comp (:constructor s) (partial apply concat))
      (apply
       generators/tuple
       (for [{:keys [cardinality] :as e} (:elements s)]
         (let [g (sub-generator e params)]
           (case cardinality
             :exactly-one (generators/fmap vector g)
             :at-most-one (generators/one-of [(generators/return nil) (generators/fmap vector g)])
             :zero-or-more (generators/vector g))))))))

  schema.spec.leaf.LeafSpec
  (composite-generator [s params]
    (macros/assert! false &quot;You must provide a leaf generator for %s&quot; s)))</pre></td></tr><tr><td class="docs"><p>Public</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A Schema for Schemas</p>
</td><td class="codes"><pre class="brush: clojure">(def Schema
  (s/protocol s/Schema))</pre></td></tr><tr><td class="docs"><p>A test.check generator</p>
</td><td class="codes"><pre class="brush: clojure">(def Generator
  s/Any)</pre></td></tr><tr><td class="docs"><p>A mapping from schemas to generating functions that should be used.</p>
</td><td class="codes"><pre class="brush: clojure">(def LeafGenerators
  (s/=&gt; (s/maybe Generator) Schema))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def +primitive-generators+
  {Double generators/double
   ;; using unchecked-float here will unfortunately generate a lot of
   ;; infinities, since lots of doubles are out of the float range
   Float (generators/fmap unchecked-float generators/double)
   Long generators/large-integer
   Integer (generators/fmap unchecked-int generators/large-integer)
   Short (generators/fmap unchecked-short generators/large-integer)
   Character (generators/fmap unchecked-char generators/large-integer)
   Byte (generators/fmap unchecked-byte generators/large-integer)
   Boolean generators/boolean})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def +simple-leaf-generators+
  (merge
   +primitive-generators+
   {s/Str generators/string-ascii
    s/Bool generators/boolean
    s/Num (generators/one-of [generators/large-integer generators/double])
    s/Int (generators/one-of
           [generators/large-integer
            (generators/fmap unchecked-int generators/large-integer)
            (generators/fmap bigint generators/large-integer)])
    s/Keyword generators/keyword
    clojure.lang.Keyword generators/keyword
    s/Symbol (generators/fmap (comp symbol name) generators/keyword)
    Object generators/any
    s/Any generators/any
    s/Uuid generators/uuid
    s/Inst (generators/fmap (fn [ms] (java.util.Date. ms)) generators/int)}
   (into {}
         (for [[f ctor c] [[doubles double-array Double]
                           [floats float-array Float]
                           [longs long-array Long]
                           [ints int-array Integer]
                           [shorts short-array Short]
                           [chars char-array Character]
                           [bytes byte-array Byte]
                           [booleans boolean-array Boolean]]]
           [f (generators/fmap ctor (generators/vector (macros/safe-get +primitive-generators+ c)))]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn eq-generators [s]
  (when (instance? schema.core.EqSchema s)
    (generators/return (.-v ^schema.core.EqSchema s))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn enum-generators [s]
  (when (instance? schema.core.EnumSchema s)
    (let [vs (vec (.-vs ^schema.core.EqSchema s))]
      (generators/fmap #(nth vs %) (generators/choose 0 (dec (count vs)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn default-leaf-generators
  [leaf-generators]
  (some-fn
   leaf-generators
   +simple-leaf-generators+
   eq-generators
   enum-generators))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn always [x] (generators/return x))</pre></td></tr><tr><td class="docs"><p>A mapping from schemas to wrappers that should be used around the default
   generators.</p>
</td><td class="codes"><pre class="brush: clojure">(def GeneratorWrappers
  (s/=&gt; (s/maybe (s/=&gt; Generator Generator))
        Schema))</pre></td></tr><tr><td class="docs"><p>Helper wrapper that filters to values that match predicate.</p>
</td><td class="codes"><pre class="brush: clojure">(defn such-that
  [f]
  (partial generators/such-that f))</pre></td></tr><tr><td class="docs"><p>Helper wrapper that maps f over all values.</p>
</td><td class="codes"><pre class="brush: clojure">(defn fmap
  [f]
  (partial generators/fmap f))</pre></td></tr><tr><td class="docs"><p>Helper wrapper that merges some keys into a schema</p>
</td><td class="codes"><pre class="brush: clojure">(defn merged
  [m]
  (fmap #(merge % m)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defn generator :- Generator
  &quot;Produce a test.check generator for schema.
   leaf-generators must return generators for all leaf schemas, and can also return
   generators for non-leaf schemas to override default generation logic.
   constraints is an optional mapping from schema to wrappers for the default generators,
   which can impose constraints, fix certain values, etc.&quot;
  ([schema]
     (generator schema {}))
  ([schema leaf-generators]
     (generator schema leaf-generators {}))
  ([schema :- Schema
    leaf-generators :- LeafGenerators
    wrappers :- GeneratorWrappers]
     (let [leaf-generators (default-leaf-generators leaf-generators)
           gen (fn [s params]
                 ((or (wrappers s) identity)
                  (or (leaf-generators s)
                      (composite-generator (s/spec s) params))))]
       (generators/fmap
        (s/validator schema)
        (gen schema {:subschema-generator gen :cache (java.util.IdentityHashMap.)})))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/defn sample :- [s/Any]
  &quot;Sample k elements from generator.&quot;
  [k &amp; generator-args]
  (generators/sample (apply generator generator-args) k))</pre></td></tr><tr><td class="docs"><p>Sample a single element of low to moderate size.</p>
</td><td class="codes"><pre class="brush: clojure">(s/defn generate
  [&amp; generator-args]
  (generators/generate (apply generator generator-args) 10))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.experimental.generators-test" name="schema.experimental.generators-test"><h1 class="project-name">schema.experimental.generators-test</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns schema.experimental.generators-test
  (:use clojure.test)
  (:require
   [clojure.test.check.properties :as properties]
   [clojure.test.check.generators :as check-generators]
   [clojure.test.check.clojure-test :as check-clojure-test]
   [schema.core :as s]
   [schema.experimental.generators :as generators]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def OGInner
  {(s/required-key &quot;l&quot;) [s/Int]
   s/Keyword s/Str})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def OGInner2
  {:c OGInner
   :d s/Str})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def OGSchema
  {:a [s/Str]
   :b OGInner2})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def FinalSchema
  {:a (s/eq [&quot;bob&quot;])
   :b {:c (s/conditional (fn [{:strs [l]}] (and (every? even? l) (seq l))) OGInner)
       :d (s/eq &quot;mary&quot;)}})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest sample-test
  (let [res (generators/sample
             20 OGSchema
             {[s/Str] (generators/always [&quot;bob&quot;])
              s/Int ((generators/fmap #(inc (* % 2))) check-generators/int)}
             {[s/Int] (comp (generators/such-that seq)
                            (generators/fmap (partial mapv inc)))
              OGInner2 (generators/merged {:d &quot;mary&quot;})})]
    (is (= (count res) 20))
    (is (s/validate [FinalSchema] res))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest simple-leaf-generators-smoke-test
  (doseq [leaf-schema [double float long int short char byte boolean
                       Double Float Long Integer Short Character Byte Boolean
                       doubles floats longs ints shorts chars bytes booleans
                       s/Str String s/Bool s/Num s/Int s/Keyword s/Symbol s/Inst
                       Object s/Any s/Uuid (s/eq &quot;foo&quot;) (s/enum :a :b :c)]]
    (testing (str leaf-schema)
      (is (= 10 (count (generators/sample 10 leaf-schema)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(check-clojure-test/defspec spec-test
  100
  (properties/for-all [x (generators/generator OGSchema)]
                      (not (s/check OGSchema x))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.macros" name="schema.macros"><h1 class="project-name">schema.macros</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Macros and macro helpers used in schema.core.</p>
</td><td class="codes"><pre class="brush: clojure">(ns schema.macros
  (:require
   [clojure.string :as str]
   [schema.utils :as utils]))</pre></td></tr><tr><td class="docs"><p>Helpers used in schema.core.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Take the &amp;env from a macro, and tell whether we are expanding into cljs.</p>
</td><td class="codes"><pre class="brush: clojure">(defn cljs-env?
  [env]
  (boolean (:ns env)))</pre></td></tr><tr><td class="docs"><p>Return then if we are generating cljs code and else for Clojure code.
   https://groups.google.com/d/msg/clojurescript/iBY5HaQda4A/w1lAQi9_AwsJ</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro if-cljs
  [then else]
  (if (cljs-env? &amp;env) then else))</pre></td></tr><tr><td class="docs"><p>A cross-platform variant of try-catch that catches all exceptions.
   Does not (yet) support finally, and does not need or want an exception class.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro try-catchall
  [&amp; body]
  (let [try-body (butlast body)
        [catch sym &amp; catch-body :as catch-form] (last body)]
    (assert (= catch 'catch))
    (assert (symbol? sym))
    `(if-cljs
      (try ~@try-body (~'catch js/Object ~sym ~@catch-body))
      (try ~@try-body (~'catch Throwable ~sym ~@catch-body)))))</pre></td></tr><tr><td class="docs"><p>Generate a cross-platform exception appropriate to the macroexpansion context</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro error!
  ([s]
     `(if-cljs
       (throw (js/Error. ~s))
       (throw (RuntimeException. ~(with-meta s `{:tag java.lang.String})))))
  ([s m]
     (let [m (merge {:type :schema.core/error} m)]
       `(if-cljs
         (throw (ex-info ~s ~m))
         (throw (clojure.lang.ExceptionInfo. ~(with-meta s `{:tag java.lang.String}) ~m))))))</pre></td></tr><tr><td class="docs"><p>Like get but throw an exception if not found.  A macro just to work around cljx function
   placement restrictions. </p>
</td><td class="codes"><pre class="brush: clojure">(defmacro safe-get
  [m k]
  `(let [m# ~m k# ~k]
     (if-let [pair# (find m# k#)]
       (val pair#)
       (error! (utils/format* &quot;Key %s not found in %s&quot; k# m#)))))</pre></td></tr><tr><td class="docs"><p>Like assert, but throws a RuntimeException (in Clojure) and takes args to format.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro assert!
  [form &amp; format-args]
  `(when-not ~form
     (error! (utils/format* ~@format-args))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro validation-error [schema value expectation &amp; [fail-explanation]]
  `(schema.utils/error
    (utils/make-ValidationError ~schema ~value (delay ~expectation) ~fail-explanation)))</pre></td></tr><tr><td class="docs"><p>Helpers for processing and normalizing element/argument schemas in s/defrecord and s/(de)fn</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn maybe-split-first [pred s]
  (if (pred (first s))
    [(first s) (next s)]
    [nil s]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def primitive-sym? '#{float double boolean byte char short int long
                       floats doubles booleans bytes chars shorts ints longs objects})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn valid-tag? [env tag]
  (and (symbol? tag) (or (primitive-sym? tag) (class? (resolve env tag)))))</pre></td></tr><tr><td class="docs"><p>Take an object with optional metadata, which may include a :tag,
   plus an optional explicit schema, and normalize the
   object to have a valid Clojure :tag plus a :schema field.</p>
</td><td class="codes"><pre class="brush: clojure">(defn normalized-metadata
  [env imeta explicit-schema]
  (let [{:keys [tag s s? schema]} (meta imeta)]
    (assert! (not (or s s?)) &quot;^{:s schema} style schemas are no longer supported.&quot;)
    (assert! (&lt; (count (remove nil? [schema explicit-schema])) 2)
             &quot;Expected single schema, got meta %s, explicit %s&quot; (meta imeta) explicit-schema)
    (let [schema (or explicit-schema schema tag `schema.core/Any)]
      (with-meta imeta
        (-&gt; (or (meta imeta) {})
            (dissoc :tag)
            (utils/assoc-when :schema schema
                              :tag (let [t (or tag schema)]
                                     (when (valid-tag? env t)
                                       t))))))))</pre></td></tr><tr><td class="docs"><p>Pull out the schema stored on a thing.  Public only because of its use in a public macro.</p>
</td><td class="codes"><pre class="brush: clojure">(defn extract-schema-form
  [symbol]
  (let [s (:schema (meta symbol))]
    (assert! s &quot;%s is missing a schema&quot; symbol)
    s))</pre></td></tr><tr><td class="docs"><p>Take a nonempty seq, which may start like [a ...] or [a :- schema ...], and return
   a list of [first-element-with-schema-attached rest-elements]</p>
</td><td class="codes"><pre class="brush: clojure">(defn extract-arrow-schematized-element
  [env s]
  (assert (seq s))
  (let [[f &amp; more] s]
    (if (= :- (first more))
      [(normalized-metadata env f (second more)) (drop 2 more)]
      [(normalized-metadata env f nil) more])))</pre></td></tr><tr><td class="docs"><p>Take an arg vector, in which each argument is followed by an optional :- schema,
   and transform into an ordinary arg vector where the schemas are metadata on the args.</p>
</td><td class="codes"><pre class="brush: clojure">(defn process-arrow-schematized-args
  [env args]
  (loop [in args out []]
    (if (empty? in)
      out
      (let [[arg more] (extract-arrow-schematized-element env in)]
        (recur more (conj out arg))))))</pre></td></tr><tr><td class="docs"><p>Helpers for schematized fn/defn</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn split-rest-arg [env bind]
  (let [[pre-&amp; [_ rest-arg :as post-&amp;]] (split-with #(not= % '&amp;) bind)]
    (if (seq post-&amp;)
      (do (assert! (= (count post-&amp;) 2) &quot;&amp; must be followed by a single binding&quot; (vec post-&amp;))
          (assert! (or (symbol? rest-arg)
                       (and (vector? rest-arg)
                            (not-any? #{'&amp;} rest-arg)))
                   &quot;Bad &amp; binding form: currently only bare symbols and vectors supported&quot; (vec post-&amp;))
          [(vec pre-&amp;)
           (if (vector? rest-arg)
             (with-meta (process-arrow-schematized-args env rest-arg) (meta rest-arg))
             rest-arg)])
      [bind nil])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn single-arg-schema-form [rest? [index arg]]
  `(~(if rest? `schema.core/optional `schema.core/one)
    ~(extract-schema-form arg)
    ~(if (symbol? arg)
       `'~arg
       `'~(symbol (str (if rest? &quot;rest&quot; &quot;arg&quot;) index)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn simple-arglist-schema-form [rest? regular-args]
  (mapv (partial single-arg-schema-form rest?) (map-indexed vector regular-args)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn rest-arg-schema-form [arg]
  (let [s (extract-schema-form arg)]
    (if (= s `schema.core/Any)
      (if (vector? arg)
        (simple-arglist-schema-form true arg)
        [`schema.core/Any])
      (do (assert! (vector? s) &quot;Expected seq schema for rest args, got %s&quot; s)
          s))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn input-schema-form [regular-args rest-arg]
  (let [base (simple-arglist-schema-form false regular-args)]
    (if rest-arg
      (vec (concat base (rest-arg-schema-form rest-arg)))
      base)))</pre></td></tr><tr><td class="docs"><p>Replicate pre/postcondition logic from clojure.core/fn.</p>
</td><td class="codes"><pre class="brush: clojure">(defn apply-prepost-conditions
  [body]
  (let [[conds body] (maybe-split-first #(and (map? %) (next body)) body)]
    (concat (map (fn [c] `(assert ~c)) (:pre conds))
            (if-let [post (:post conds)]
              `((let [~'% (do ~@body)]
                  ~@(map (fn [c] `(assert ~c)) post)
                  ~'%))
              body))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *compile-fn-validation* (atom true))</pre></td></tr><tr><td class="docs"><p>Returns true if validation should be included at compile time, otherwise false.
   Validation is elided for any of the following cases:
   *   function has :never-validate metadata
   *   <em>compile-fn-validation</em> is false
   *   <em>assert</em> is false AND function is not :always-validate</p>
</td><td class="codes"><pre class="brush: clojure">(defn compile-fn-validation?
  [env fn-name]
  (let [fn-meta (meta fn-name)]
    (and
     @*compile-fn-validation*
     (not (:never-validate fn-meta))
     (or (:always-validate fn-meta)
         *assert*))))</pre></td></tr><tr><td class="docs"><p>Process a single (bind &amp; body) form, producing an output tag, schema-form,
   and arity-form which has asserts for validation purposes added that are
   executed when turned on, and have very low overhead otherwise.
   tag? is a prospective tag for the fn symbol based on the output schema.
   schema-bindings are bindings to lift eval outwards, so we don't build the schema
   every time we do the validation.</p>
</td><td class="codes"><pre class="brush: clojure">(defn process-fn-arity
  [env fn-name output-schema-sym bind-meta [bind &amp; body]]
  (assert! (vector? bind) &quot;Got non-vector binding form %s&quot; bind)
  (when-let [bad-meta (seq (filter (or (meta bind) {}) [:tag :s? :s :schema]))]
    (throw (RuntimeException. (str &quot;Meta not supported on bindings, put on fn name&quot; (vec bad-meta)))))
  (let [original-arglist bind
        bind (with-meta (process-arrow-schematized-args env bind) bind-meta)
        [regular-args rest-arg] (split-rest-arg env bind)
        input-schema-sym (gensym &quot;input-schema&quot;)
        input-checker-sym (gensym &quot;input-checker&quot;)
        output-checker-sym (gensym &quot;output-checker&quot;)
        compile-validation (compile-fn-validation? env fn-name)]
    {:schema-binding [input-schema-sym (input-schema-form regular-args rest-arg)]
     :more-bindings (when compile-validation
                      [input-checker-sym `(delay (schema.core/checker ~input-schema-sym))
                       output-checker-sym `(delay (schema.core/checker ~output-schema-sym))])
     :arglist bind
     :raw-arglist original-arglist
     :arity-form (if compile-validation
                   (let [bind-syms (vec (repeatedly (count regular-args) gensym))
                         rest-sym (when rest-arg (gensym &quot;rest&quot;))
                         metad-bind-syms (with-meta (mapv #(with-meta %1 (meta %2)) bind-syms bind) bind-meta)]
                     (list
                      (if rest-arg
                        (into metad-bind-syms ['&amp; rest-sym])
                        metad-bind-syms)
                      `(let [validate# ~(if (:always-validate (meta fn-name))
                                          `true
                                          `(.get_cell ~'ufv__))]
                         (when validate#
                           (let [args# ~(if rest-arg
                                          `(list* ~@bind-syms ~rest-sym)
                                          bind-syms)]
                             (when-let [error# (@~input-checker-sym args#)]
                               (error! (utils/format* &quot;Input to %s does not match schema: %s&quot;
                                                      '~fn-name (pr-str error#))
                                       {:schema ~input-schema-sym :value args# :error error#}))))
                         (let [o# (loop ~(into (vec (interleave (map #(with-meta % {}) bind) bind-syms))
                                               (when rest-arg [rest-arg rest-sym]))
                                    ~@(apply-prepost-conditions body))]
                           (when validate#
                             (when-let [error# (@~output-checker-sym o#)]
                               (error! (utils/format* &quot;Output of %s does not match schema: %s&quot;
                                                      '~fn-name (pr-str error#))
                                       {:schema ~output-schema-sym :value o# :error error#})))
                           o#))))
                   (cons (into regular-args (when rest-arg ['&amp; rest-arg]))
                         body))}))</pre></td></tr><tr><td class="docs"><p>Process the fn args into a final tag proposal, schema form, schema bindings, and fn form</p>
</td><td class="codes"><pre class="brush: clojure">(defn process-fn-
  [env name fn-body]
  (let [compile-validation (compile-fn-validation? env name)
        output-schema (extract-schema-form name)
        output-schema-sym (gensym &quot;output-schema&quot;)
        bind-meta (or (when-let [t (:tag (meta name))]
                        (when (primitive-sym? t)
                          {:tag t}))
                      {})
        processed-arities (map (partial process-fn-arity env name output-schema-sym bind-meta)
                               (if (vector? (first fn-body))
                                 [fn-body]
                                 fn-body))
        schema-bindings (map :schema-binding processed-arities)
        fn-forms (map :arity-form processed-arities)]
    {:outer-bindings (vec (concat
                           (when compile-validation
                             `[^schema.utils.PSimpleCell ~'ufv__ schema.utils/use-fn-validation])
                           [output-schema-sym output-schema]
                           (apply concat schema-bindings)
                           (mapcat :more-bindings processed-arities)))
     :arglists (map :arglist processed-arities)
     :raw-arglists (map :raw-arglist processed-arities)
     :schema-form (if (= 1 (count processed-arities))
                    `(schema.core/-&gt;FnSchema ~output-schema-sym ~[(ffirst schema-bindings)])
                    `(schema.core/make-fn-schema ~output-schema-sym ~(mapv first schema-bindings)))
     :fn-body fn-forms}))</pre></td></tr><tr><td class="docs"><p>Helper for schema.core/=>*.</p>
</td><td class="codes"><pre class="brush: clojure">(defn parse-arity-spec
  [spec]
  (assert! (vector? spec) &quot;An arity spec must be a vector&quot;)
  (let [[init more] ((juxt take-while drop-while) #(not= '&amp; %) spec)
        fixed (mapv (fn [i s] `(schema.core/one ~s '~(symbol (str &quot;arg&quot; i)))) (range) init)]
    (if (empty? more)
      fixed
      (do (assert! (and (= (count more) 2) (vector? (second more)))
                   &quot;An arity with &amp; must be followed by a single sequence schema&quot;)
          (into fixed (second more))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn emit-defrecord
  [defrecord-constructor-sym env name field-schema &amp; more-args]
  (let [[extra-key-schema? more-args] (maybe-split-first map? more-args)
        [extra-validator-fn? more-args] (maybe-split-first (complement symbol?) more-args)
        field-schema (process-arrow-schematized-args env field-schema)]
    `(do
       (let [bad-keys# (seq (filter #(schema.core/required-key? %)
                                    (keys ~extra-key-schema?)))]
         (assert! (not bad-keys#) &quot;extra-key-schema? can not contain required keys: %s&quot;
                  (vec bad-keys#)))
       ~(when extra-validator-fn?
          `(assert! (fn? ~extra-validator-fn?) &quot;Extra-validator-fn? not a fn: %s&quot;
                    (type ~extra-validator-fn?)))
       (~defrecord-constructor-sym ~name ~field-schema ~@more-args)
       (utils/declare-class-schema!
        ~name
        (utils/assoc-when
         (schema.core/record
          ~name
          (merge ~(into {}
                        (for [k field-schema]
                          [(keyword (clojure.core/name k))
                           (do (assert! (symbol? k)
                                        &quot;Non-symbol in record binding form: %s&quot; k)
                               (extract-schema-form k))]))
                 ~extra-key-schema?)
          ~(symbol (str 'map-&gt; name)))
         :extra-validator-fn ~extra-validator-fn?))
       ~(let [map-sym (gensym &quot;m&quot;)]
          `(if-cljs
            nil
            (defn ~(symbol (str 'map-&gt; name))
              ~(str &quot;Factory function for class &quot; name &quot;, taking a map of keywords to field values, but not much\n&quot;
                    &quot; slower than -&gt;x like the clojure.core version.\n&quot;
                    &quot; (performance is fixed in Clojure 1.7, so this should eventually be removed.)&quot;)
              [~map-sym]
              (let [base# (new ~(symbol (str name))
                               ~@(map (fn [s] `(get ~map-sym ~(keyword s))) field-schema))
                    remaining# (dissoc ~map-sym ~@(map keyword field-schema))]
                (if (seq remaining#)
                  (merge base# remaining#)
                  base#)))))
       ~(let [map-sym (gensym &quot;m&quot;)]
          `(defn ~(symbol (str 'strict-map-&gt; name))
             ~(str &quot;Factory function for class &quot; name &quot;, taking a map of keywords to field values.  All&quot;
                   &quot; keys are required, and no extra keys are allowed.  Even faster than map-&gt;&quot;)
             [~map-sym &amp; [drop-extra-keys?#]]
             (when-not (or drop-extra-keys?# (= (count ~map-sym) ~(count field-schema)))
               (error! (utils/format* &quot;Wrong number of keys: expected %s, got %s&quot;
                                      (sort ~(mapv keyword field-schema)) (sort (keys ~map-sym)))))
             (new ~(symbol (str name))
                  ~@(map (fn [s] `(safe-get ~map-sym ~(keyword s))) field-schema)))))))</pre></td></tr><tr><td class="docs"><p>Public: helpers for schematized functions</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Helper for defining defn-like macros with schemas.  Env is &amp;env
   from the macro body.  Reads optional docstring, return type and
   attribute-map and normalizes them into the metadata of the name,
   returning the normalized arglist.  Based on
   clojure.tools.macro/name-with-attributes.</p>
</td><td class="codes"><pre class="brush: clojure">(defn normalized-defn-args
  [env macro-args]
  (let [[name macro-args] (extract-arrow-schematized-element env macro-args)
        [maybe-docstring macro-args] (maybe-split-first string? macro-args)
        [maybe-attr-map macro-args] (maybe-split-first map? macro-args)]
    (cons (vary-meta name merge
                     (or maybe-attr-map {})
                     (when maybe-docstring {:doc maybe-docstring}))
          macro-args)))</pre></td></tr><tr><td class="docs"><p>Globally turn on or off function validation from being compiled into s/fn and s/defn.
   Enabled by default.
   See (doc compile-fn-validation?) for all conditions which control fn validation compilation</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-compile-fn-validation!
  [on?]
  (reset! *compile-fn-validation* on?))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.macros-test" name="schema.macros-test"><h1 class="project-name">schema.macros-test</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns schema.macros-test
  (:use clojure.test)
  (:require
   [schema.core :as s]
   [schema.macros :as macros]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest normalized-defn-args-test
  (doseq [explicit-meta [{} {:a -1 :c 3}]
          [schema-attrs schema-forms] {{:schema `s/Any} []
                                       {:schema 'Long :tag 'Long} [:- 'Long]}
          [doc-attrs doc-forms] {{} []
                                 {:doc &quot;docstring&quot;} [&quot;docstring&quot;]}
          [attr-map attr-forms] {{} {}
                                 {:a 1 :b 2} [{:a 1 :b 2}]}]
    (let [simple-body ['[x] `(+ 1 1)]
          full-args (concat [(with-meta 'abc explicit-meta)] schema-forms doc-forms attr-forms simple-body)
          [name &amp; more] (macros/normalized-defn-args {} full-args)]
      (testing (vec full-args)
        (is (= (concat ['abc (merge explicit-meta schema-attrs doc-attrs attr-map) simple-body])
               (concat [name (meta name) more])))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftest compile-fn-validation?-test
  (is (macros/compile-fn-validation? {} 'foo))
  (is (not (macros/compile-fn-validation? {} (with-meta 'foo {:never-validate true}))))
  (macros/set-compile-fn-validation! false)
  (is (not (macros/compile-fn-validation? {} 'foo)))
  (is (not (macros/compile-fn-validation? {} (with-meta 'foo {:always-validate true}))))
  (macros/set-compile-fn-validation! true)
  (binding [*assert* false]
    (is (not (macros/compile-fn-validation? {} 'foo)))
    (is (macros/compile-fn-validation? {} (with-meta 'foo {:always-validate true})))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.potemkin" name="schema.potemkin"><h1 class="project-name">schema.potemkin</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Features that require an explicit potemkin dependency to be provided by the consumer.</p>
</td><td class="codes"><pre class="brush: clojure">(ns schema.potemkin
  (:require [schema.macros :as macros]
            [potemkin]))</pre></td></tr><tr><td class="docs"><p>Like defrecord, but emits a record using potemkin/defrecord+.  You must provide
   your own dependency on potemkin to use this.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defrecord+
  {:arglists '([name field-schema extra-key-schema? extra-validator-fn? &amp; opts+specs])}
  [name field-schema &amp; more-args]
  (apply macros/emit-defrecord 'potemkin/defrecord+ &amp;env name field-schema more-args))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.spec.collection" name="schema.spec.collection"><h1 class="project-name">schema.spec.collection</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A collection spec represents a collection of elements,
   each of which is itself schematized.</p>
</td><td class="codes"><pre class="brush: clojure">(ns schema.spec.collection
  (:require
   [schema.utils :as utils]
   [schema.spec.core :as spec]))</pre></td></tr><tr><td class="docs"><p>Collection Specs</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- element-transformer [e params then]
  (let [parser (:parser e)
        c (spec/sub-checker e params)]
          (fn [^java.util.List res x]
            (then res (parser (fn [t] (.add res (if (utils/error? t) t (c t)))) x)))))</pre></td></tr><tr><td class="docs"><p>for performance</p>
</td><td class="codes"><pre class="brush: clojure">(defn- has-error? [^java.util.List l]
  (let [it (.iterator l)]
    (loop []
      (if (.hasNext it)
        (if (utils/error? (.next it))
          true
          (recur))
        false))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord CollectionSpec [pre constructor elements on-error]
  spec/CoreSpec
  (subschemas [this] (map :schema elements))
  (checker [this params]
    (let [constructor (if (:return-walked? params) constructor (fn [_] nil))
          t (reduce
             (fn [f e]
               (element-transformer e params f))
             (fn [_ x] x)
             (reverse elements))]
      (fn [x]
        (or (pre x)
            (let [res       (java.util.ArrayList.)                 
                  remaining (t res x)
                  res       res            ]
              (if (or (seq remaining) (has-error? res))
                (utils/error (on-error x res remaining))
                (constructor res))))))))</pre></td></tr><tr><td class="docs"><p>A collection represents a collection of elements, each of which is itself
   schematized.  At the top level, the collection has a precondition
   (presumably on the overall type), a constructor for the collection from a
   sequence of items, an element spec, and a function that constructs a
   descriptive error on failure.</p>

<p>   The element spec is a sequence of maps, each of which provides an element
   schema, cardinality, parser (allowing for efficient processing of
   structured collections), and optional error wrapper.</p>
</td><td class="codes"><pre class="brush: clojure">(defn collection-spec
  [pre ;- spec/Precondition
   constructor ;- (s/=&gt; s/Any [(s/named s/Any 'checked-value)])
   elements ;- [{:schema (s/protocol Schema)
   ;;            :cardinality (s/enum :exactly-one :at-most-one :zero-or-more)
   ;;            :parser (s/=&gt; s/Any (s/=&gt; s/Any s/Any) s/Any) ; takes [item-fn coll], calls item-fn on matching items, returns remaining.
   ;;            (s/optional-key :error-wrap) (s/pred fn?)}]
   on-error ;- (=&gt; s/Any (s/named s/Any 'value) [(s/named s/Any 'checked-element)] [(s/named s/Any 'unmatched-element)])
   ]
  (-&gt;CollectionSpec pre constructor elements on-error))</pre></td></tr><tr><td class="docs"><p>Helpers for creating 'elements'</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn all-elements [schema]
  {:schema schema
   :cardinality :zero-or-more
   :parser (fn [item-fn coll] (doseq [x coll] (item-fn x)) nil)})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn one-element [required? schema parser]
  {:schema schema
   :cardinality (if required? :exactly-one :at-most-one)
   :parser parser})</pre></td></tr><tr><td class="docs"><p>This file autogenerated from src/cljx/schema/spec/collection.cljx</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.spec.core" name="schema.spec.core"><h1 class="project-name">schema.spec.core</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Protocol and preliminaries for Schema 'specs', which are a common language
   for schemas to use to express their structure.</p>
</td><td class="codes"><pre class="brush: clojure">(ns schema.spec.core
  (:require
         [schema.macros :as macros]
   [schema.utils :as utils]))</pre></td></tr><tr><td class="docs"><p>Core spec protocol</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Specs are a common language for Schemas to express their structure.
   These two use-cases aren't priveledged, just the two that are considered core
   to being a Spec.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol CoreSpec
  (subschemas [this]
    &quot;List all subschemas&quot;)
  (checker [this params]
    &quot;Create a function that takes [data], and either returns a walked version of data
     (by default, usually just data), or a utils/ErrorContainer containing value that looks
     like the 'bad' parts of data with ValidationErrors at the leaves describing the failures.
     params are: subschema-checker, return-walked?, and cache.
     params is a map specifying:
      - subschema-checker - a function for checking subschemas
      - returned-walked? - a boolean specifying whether to return a walked version of the data
        (otherwise, nil is returned which increases performance)
      - cache - a map structure from schema to checker, which speeds up checker creation
        when the same subschema appears multiple times, and also facilitates handling
        recursive schemas.&quot;))</pre></td></tr><tr><td class="docs"><p>Preconditions</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A Precondition is a function of a value that returns a
ValidationError if the value does not satisfy the precondition,
and otherwise returns nil.
e.g., (s/defschema Precondition (s/=> (s/maybe schema.utils.ValidationError) s/Any))
as such, a precondition is essentially a very simple checker.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def +no-precondition+ (fn [_] nil))</pre></td></tr><tr><td class="docs"><p>Helper for making preconditions.
   Takes a schema, predicate p, and error function err-f.
   If the datum passes the predicate, returns nil.
   Otherwise, returns a validation error with description (err-f datum-description),
   where datum-description is a (short) printable standin for the datum.</p>
</td><td class="codes"><pre class="brush: clojure">(defn precondition
  [s p err-f]
  (fn [x]
    (when-let [reason (macros/try-catchall (when-not (p x) 'not) (catch e# 'throws?))]
      (macros/validation-error s x (err-f (utils/value-name x)) reason))))</pre></td></tr><tr><td class="docs"><p>A simple precondition where f-sym names a predicate (e.g. (simple-precondition s map?))</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro simple-precondition
  [s f-sym]
  `(precondition ~s ~f-sym #(list (quote ~f-sym) %)))</pre></td></tr><tr><td class="docs"><p>Helpers</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A helper to start a checking run, by setting the appropriate params.
   For examples, see schema.core/checker or schema.coerce/coercer.</p>
</td><td class="codes"><pre class="brush: clojure">(defn run-checker
  [f return-walked? s]
  (f
   s
   {:subschema-checker f
    :return-walked? return-walked?
    :cache       (java.util.IdentityHashMap.)                 }))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn with-cache [cache cache-key wrap-recursive-delay result-fn]
  (if-let [w       (.get ^java.util.Map cache cache-key)                          ]
    (if (= ::in-progress w) ;; recursive
      (wrap-recursive-delay (delay       (.get ^java.util.Map cache cache-key)                          ))
      w)
    (do       (.put ^java.util.Map cache cache-key ::in-progress)                                                   
        (let [res (result-fn)]
                (.put ^java.util.Map cache cache-key res)                                         
          res))))</pre></td></tr><tr><td class="docs"><p>Should be called recursively on each subschema in the 'checker' method of a spec.
   Handles caching and error wrapping behavior.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sub-checker
  [{:keys [schema error-wrap]}
   {:keys [subschema-checker cache] :as params}]
  (let [sub (with-cache cache schema
              (fn [d] (fn [x] (@d x)))
              (fn [] (subschema-checker schema params)))]
    (if error-wrap
      (fn [x]
        (let [res (sub x)]
          (if-let [e (utils/error-val res)]
            (utils/error (error-wrap res))
            res)))
      sub)))</pre></td></tr><tr><td class="docs"><p>This file autogenerated from src/cljx/schema/spec/core.cljx</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.spec.leaf" name="schema.spec.leaf"><h1 class="project-name">schema.spec.leaf</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns schema.spec.leaf
  (:require
   [schema.spec.core :as spec]))</pre></td></tr><tr><td class="docs"><p>Leaf Specs</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord LeafSpec [pre]
  spec/CoreSpec
  (subschemas [this] nil)
  (checker [this params]
    (fn [x] (or (pre x) x))))</pre></td></tr><tr><td class="docs"><p>A leaf spec represents an atomic datum that is checked completely
   with a single precondition, and is otherwise a black box to Schema.</p>
</td><td class="codes"><pre class="brush: clojure">(defn leaf-spec
  [pre ;- spec/Precondition
   ]
  (-&gt;LeafSpec pre))</pre></td></tr><tr><td class="docs"><p>This file autogenerated from src/cljx/schema/spec/leaf.cljx</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.spec.variant" name="schema.spec.variant"><h1 class="project-name">schema.spec.variant</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns schema.spec.variant
  (:require
         [schema.macros :as macros]
   [schema.utils :as utils]
   [schema.spec.core :as spec]))</pre></td></tr><tr><td class="docs"><p>Variant Specs</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- option-step [o params else]
  (let [g (:guard o)
        c (spec/sub-checker o params)
        step (if g
               (fn [x]
                 (let [guard-result (macros/try-catchall
                                     (g x)
                                     (catch e# ::exception))]
                   (cond (= ::exception guard-result)
                         (macros/validation-error
                          (:schema o)
                          x
                          (list (symbol (utils/fn-name g)) (utils/value-name x))
                          'throws?)
                         guard-result
                         (c x)
                         :else
                         (else x))))
               c)]
    (if-let [wrap-error (:wrap-error o)]
      (fn [x]
        (let [res (step x)]
          (if-let [e (utils/error-val res)]
            (utils/error (wrap-error e))
            res)))
      step)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord VariantSpec [pre options err-f post]
  spec/CoreSpec
  (subschemas [this] (map :schema options))
  (checker [this params]
    (let [t (reduce
             (fn [f o]
               (option-step o params f))
             (fn [x] (macros/validation-error this x (err-f (utils/value-name x))))
             (reverse options))]
      (if post
        (fn [x]
          (or (pre x)
              (let [v (t x)]
                (if (utils/error? v)
                  v
                  (or (post (if (:return-walked? params) v x)) v)))))
        (fn [x]
          (or (pre x)
              (t x)))))))</pre></td></tr><tr><td class="docs"><p>A variant spec represents a choice between a set of alternative
   subschemas, e.g., a tagged union. It has an overall precondition,
   set of options, and error function.</p>

<p>   The semantics of <code>options</code> is that the options are processed in
   order. During checking, the datum must match the schema for the
   first option for which <code>guard</code> passes. During generation, any datum
   generated from an option will pass the corresponding <code>guard</code>.</p>

<p>   err-f is a function to produce an error message if none
   of the guards match (and must be passed unless the last option has no
   guard).</p>
</td><td class="codes"><pre class="brush: clojure">(defn variant-spec
  ([pre options]
     (variant-spec pre options nil))
  ([pre options err-f]
     (variant-spec pre options err-f nil))
  ([pre ;- spec/Precondition
    options ;- [{:schema (s/protocol Schema)
    ;;           (s/optional-key :guard) (s/pred fn?)
    ;;           (s/optional-key :error-wrap) (s/pred fn?)}]
    err-f ;- (s/pred fn?)
    post ;- (s/maybe spec/Precondition)
    ]
     (macros/assert! (or err-f (nil? (:guard (last options))))
                     &quot;when last option has a guard, err-f must be provided&quot;)
     (-&gt;VariantSpec pre options err-f post)))</pre></td></tr><tr><td class="docs"><p>This file autogenerated from src/cljx/schema/spec/variant.cljx</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.test" name="schema.test"><h1 class="project-name">schema.test</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Utilities for testing with schemas</p>
</td><td class="codes"><pre class="brush: clojure">(ns schema.test
  (:require [schema.core :as s :include-macros true]
                  clojure.test))</pre></td></tr><tr><td class="docs"><p>A fixture for tests: put
   (use-fixtures :once schema.test/validate-schemas)
   in your test file to turn on schema validation globally during all test executions.</p>
</td><td class="codes"><pre class="brush: clojure">(defn validate-schemas
  [fn-test]
  (s/with-fn-validation (fn-test)))</pre></td></tr><tr><td class="docs"><p>A test with schema validation turned on globally during execution of the body.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro deftest
  [name &amp; body]
  `(clojure.test/deftest ~name
     (s/with-fn-validation
       ~@body)))</pre></td></tr><tr><td class="docs"><p>This file autogenerated from src/cljx/schema/test.cljx</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.test-macros" name="schema.test-macros"><h1 class="project-name">schema.test-macros</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Macros to help cross-language testing of schemas.</p>
</td><td class="codes"><pre class="brush: clojure">(ns schema.test-macros
  (:require
   clojure.test
   [schema.core :as s]
   [schema.macros :as sm]
   [schema.spec.core :as spec]))</pre></td></tr><tr><td class="docs"><p>Assert that x satisfies schema s, and the walked value is equal to the original.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro valid!
  [s x]
  `(let [x# ~x] (~'is (= x# ((spec/run-checker #(spec/checker (s/spec %1) %2) true ~s) x#)))))</pre></td></tr><tr><td class="docs"><p>Assert that x does not satisfy schema s, optionally checking the stringified return value</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro invalid!
  ([s x]
     `(~'is (s/check ~s ~x)))
  ([s x expected]
     `(do (invalid! ~s ~x)
          (sm/if-cljs nil (~'is (= ~expected (pr-str (s/check ~s ~x))))))))</pre></td></tr><tr><td class="docs"><p>Assert that f throws (presumably due to schema validation error) when called on args.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro invalid-call!
  [f &amp; args]
  (when (sm/compile-fn-validation? &amp;env f)
    `(~'is (~'thrown? ~'Throwable (~f ~@args)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.test-test" name="schema.test-test"><h1 class="project-name">schema.test-test</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns schema.test-test
        (:use clojure.test)
  (:require
   [schema.core :as s]
   [schema.test :as st]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(do
  (s/defn test-fn :- s/Str [] 5)
  (deftest validation-off-test
    (is (= 5 (test-fn))))
  (st/deftest validation-on-test
    (is (thrown? Exception (test-fn)))))</pre></td></tr><tr><td class="docs"><p>This file autogenerated from test/cljx/schema/test_test.cljx</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#schema.utils" name="schema.utils"><h1 class="project-name">schema.utils</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Private utilities used in schema implementation.</p>
</td><td class="codes"><pre class="brush: clojure">(ns schema.utils
  (:refer-clojure :exclude [record?])
        (:require [clojure.string :as string]))</pre></td></tr><tr><td class="docs"><p>Miscellaneous helpers</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Like assoc but only assocs when value is truthy.  Copied from plumbing.core so that
   schema need not depend on plumbing.</p>
</td><td class="codes"><pre class="brush: clojure">(defn assoc-when
  [m &amp; kvs]
  (assert (even? (count kvs)))
  (into (or m {})
        (for [[k v] (partition 2 kvs)
              :when v]
          [k v])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn type-of [x]
        (class x))</pre></td></tr><tr><td class="docs"><p>What class can we associate the fn schema with? In Clojure use the class of the fn; in
   cljs just use the fn itself.</p>
</td><td class="codes"><pre class="brush: clojure">(defn fn-schema-bearer
  [f]
        (class f))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn format* [fmt &amp; args]
  (apply       format                       fmt args))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def max-value-length (atom 19))</pre></td></tr><tr><td class="docs"><p>Provide a descriptive short name for a value.</p>
</td><td class="codes"><pre class="brush: clojure">(defn value-name
  [value]
  (let [t (type-of value)]
    (if (&lt;= (count (str value)) @max-value-length)
      value
      (symbol (str &quot;a-&quot;       (.getName ^Class t)         )))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro char-map []
  clojure.lang.Compiler/CHAR_MAP)</pre></td></tr><tr><td class="docs"><p>TODO: eventually use built in demunge in latest cljs.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unmunge
  [s]
  (-&gt;&gt; (char-map)
       (sort-by #(- (count (second %))))
       (reduce (fn [^String s [to from]] (string/replace s from (str to))) s)))</pre></td></tr><tr><td class="docs"><p>A meaningful name for a function that looks like its symbol, if applicable.</p>
</td><td class="codes"><pre class="brush: clojure">(defn fn-name
  [f]
        (let [s (.getName (class f))
              slash (.lastIndexOf s &quot;$&quot;)
              raw (unmunge
                   (if (&gt;= slash 0)
                     (str (subs s 0 slash) &quot;/&quot; (subs s (inc slash)))
                     s))]
          (string/replace raw #&quot;^clojure.core/&quot; &quot;&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn record? [x]
        (instance? clojure.lang.IRecord x))</pre></td></tr><tr><td class="docs"><p>Error descriptions</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A leaf schema validation error, describing the schema and value and why it failed to
match the schema.  In Clojure, prints like a form describing the failure that would
return true.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare validation-error-explain)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype ValidationError [schema value expectation-delay fail-explanation])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn validation-error-explain [^ValidationError err]
  (list (or (.-fail-explanation err) 'not) @(.-expectation-delay err)))</pre></td></tr><tr><td class="docs"><p>Validation errors print like forms that would return false</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method ValidationError [err writer]
  (print-method (validation-error-explain err) writer))</pre></td></tr><tr><td class="docs"><p>for cljs sake (easier than normalizing imports in macros.clj)</p>
</td><td class="codes"><pre class="brush: clojure">(defn make-ValidationError
  [schema value expectation-delay fail-explanation]
  (ValidationError. schema value expectation-delay fail-explanation))</pre></td></tr><tr><td class="docs"><p>Attach a name to an error from a named schema.</p>
</td><td class="codes"><pre class="brush: clojure">(declare named-error-explain)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype NamedError [name error])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn named-error-explain [^NamedError err]
  (list 'named (.-error err) (.-name err)))</pre></td></tr><tr><td class="docs"><p>Validation errors print like forms that would return false</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method NamedError [err writer]
  (print-method (named-error-explain err) writer))</pre></td></tr><tr><td class="docs"><p>Monoidish error containers, which wrap errors (to distinguish from success values).</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord ErrorContainer [error])</pre></td></tr><tr><td class="docs"><p>Distinguish a value (must be non-nil) as an error.</p>
</td><td class="codes"><pre class="brush: clojure">(defn error
  [x] (assert x) (-&gt;ErrorContainer x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn error? [x]
  (instance? ErrorContainer x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn error-val [x]
  (when (error? x)
    (.-error ^ErrorContainer x)))</pre></td></tr><tr><td class="docs"><p>Registry for attaching schemas to classes, used for defn and defrecord</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(let [^java.util.Map +class-schemata+ (java.util.Collections/synchronizedMap (java.util.WeakHashMap.))]
  (defn declare-class-schema! [klass schema]
    &quot;Globally set the schema for a class (above and beyond a simple instance? check).
   Use with care, i.e., only on classes that you control.  Also note that this
   schema only applies to instances of the concrete type passed, i.e.,
   (= (class x) klass), not (instance? klass x).&quot;
    (assert (class? klass)
            (format* &quot;Cannot declare class schema for non-class %s&quot; (class klass)))
    (.put +class-schemata+ klass schema))
  (defn class-schema [klass]
    &quot;The last schema for a class set by declare-class-schema!, or nil.&quot;
    (.get +class-schemata+ klass)))</pre></td></tr><tr><td class="docs"><p>Utilities for fast-as-possible reference to use to turn fn schema validation on/off</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(definterface PSimpleCell
  (get_cell ^boolean [])
  (set_cell [^boolean x]))</pre></td></tr><tr><td class="docs"><p>adds ~5% overhead compared to no check</p>
</td><td class="codes"><pre class="brush: clojure">(deftype SimpleVCell [^:volatile-mutable ^boolean q]
  PSimpleCell
  (get_cell [this] q)
  (set_cell [this x] (set! q x)))</pre></td></tr><tr><td class="docs"><p>Turn on run-time function validation for functions compiled when
   s/compile-fn-validation was true -- has no effect for functions compiled
   when it is false.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^schema.utils.PSimpleCell use-fn-validation
  (SimpleVCell. false))</pre></td></tr><tr><td class="docs"><p>This file autogenerated from src/cljx/schema/utils.cljx</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr></table><div class="footer">Generated by <a href="https://github.com/gdeer81/marginalia">Marginalia</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a><div id="floating-toc"><ul><li class="floating-toc-li" id="floating-toc_schema.coerce">schema.coerce</li><li class="floating-toc-li" id="floating-toc_schema.coerce-test">schema.coerce-test</li><li class="floating-toc-li" id="floating-toc_schema.core">schema.core</li><li class="floating-toc-li" id="floating-toc_schema.core-test">schema.core-test</li><li class="floating-toc-li" id="floating-toc_schema.experimental.abstract-map">schema.experimental.abstract-map</li><li class="floating-toc-li" id="floating-toc_schema.experimental.abstract-map-test">schema.experimental.abstract-map-test</li><li class="floating-toc-li" id="floating-toc_schema.experimental.complete">schema.experimental.complete</li><li class="floating-toc-li" id="floating-toc_schema.experimental.complete-test">schema.experimental.complete-test</li><li class="floating-toc-li" id="floating-toc_schema.experimental.generators">schema.experimental.generators</li><li class="floating-toc-li" id="floating-toc_schema.experimental.generators-test">schema.experimental.generators-test</li><li class="floating-toc-li" id="floating-toc_schema.macros">schema.macros</li><li class="floating-toc-li" id="floating-toc_schema.macros-test">schema.macros-test</li><li class="floating-toc-li" id="floating-toc_schema.potemkin">schema.potemkin</li><li class="floating-toc-li" id="floating-toc_schema.spec.collection">schema.spec.collection</li><li class="floating-toc-li" id="floating-toc_schema.spec.core">schema.spec.core</li><li class="floating-toc-li" id="floating-toc_schema.spec.leaf">schema.spec.leaf</li><li class="floating-toc-li" id="floating-toc_schema.spec.variant">schema.spec.variant</li><li class="floating-toc-li" id="floating-toc_schema.test">schema.test</li><li class="floating-toc-li" id="floating-toc_schema.test-macros">schema.test-macros</li><li class="floating-toc-li" id="floating-toc_schema.test-test">schema.test-test</li><li class="floating-toc-li" id="floating-toc_schema.utils">schema.utils</li></ul></div></div><script type="text/javascript">SyntaxHighlighter.defaults['gutter'] = false;
SyntaxHighlighter.all();

// hackity hack
$(window).load(function() {
    var ft = $("#floating-toc");
    var ul = ft.find('ul');
    var lis = ft.find('li');
    var liHeight = $(lis.first()).height();

    ul.css('margin', '0px');
    ft.css('height', liHeight + 'px');

    showNs = function(ns) {
        var index = 0;

        for(i in nsPositions.nss) {
            if(ns == nsPositions.nss[i]) index = i;
        }

        if(index != lastNsIndex) {
            lastNsIndex = index;
            ul.animate({marginTop: (-1 * liHeight * index) + 'px'},
               300);
        }

    }

    var calcNsPositions = function() {
        var hheight = $('.docs-header').first().height();
        var nss = [];
        var anchors = [];
        var positions = [];
        $.each(lis, function(i, el) {
            var ns = $(el).attr('id').split('_')[1];
            nss.push(ns);
            var a = $("a[name='"+ns+"']");
            anchors.push(a);
            positions.push(a.offset().top - hheight);
            // console.log(a.offset().top)
        });

        return {nss: nss, positions: positions};
    }

    var nsPositions = calcNsPositions();
    // console.log(nsPositions)
    var lastNsIndex = -1;
    var $window = $(window);

    var currentSection = function(nsp) {
        var ps = nsp.positions;
        var scroll = $window.scrollTop();
        var nsIndex = -1;

        for(var i = 0, length = ps.length; i < length; i++) {
            if(ps[i] >= scroll) {
                nsIndex = i-1;
                break;
            }
        }

        if(nsIndex == -1) {
             if(scroll >= ps[0]) {
                 nsIndex = ps.length - 1;
             } else {
                 nsIndex = 0;
             }
        }

        return nsp.nss[nsIndex];
    }

    $(window).scroll(function(e) {
        showNs(currentSection(nsPositions));
    });
});
</script></body></html>